package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
)

// generateFile generates the _arpc.pb.go file for a given proto file.
func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_arpc.syn.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	// Header and package declaration
	g.P("// Code generated by protoc-gen-arpc. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P()
	g.P(`import (`)
	g.P(`  "context"`)
	g.P(`  "github.com/appnet-org/arpc/pkg/rpc"`)
	g.P(`)`)
	g.P()

	// Generate code for each service in the file
	for _, service := range file.Services {
		genService(g, service)
	}
}

// genService generates the client and server code for a single service.
func genService(g *protogen.GeneratedFile, service *protogen.Service) {
	svcName := service.GoName
	clientName := svcName + "Client"

	// === Client interface ===
	g.P("// ", clientName, " is the client API for ", svcName, " service.")
	g.P("type ", clientName, " interface {")
	for _, m := range service.Methods {
		g.P(m.GoName, "(ctx context.Context, req *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P()

	// === Client implementation ===
	implName := "arpc" + clientName
	g.P("type ", implName, " struct {")
	g.P("  client *rpc.Client")
	g.P("}")
	g.P()

	// Constructor for the client implementation
	g.P("func New", clientName, "(client *rpc.Client) ", clientName, " {")
	g.P("  return &", implName, "{client: client}")
	g.P("}")
	g.P()

	// Implement each client method by calling rpc.Client.Call
	for _, m := range service.Methods {
		serviceName := service.GoName
		methodName := m.GoName

		g.P("func (c *", implName, ") ", methodName,
			"(ctx context.Context, req *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", error) {")

		g.P("  resp := new(", m.Output.GoIdent, ")")
		g.P("  if err := c.client.Call(ctx, \"", serviceName, "\", \"", methodName, "\", req, resp); err != nil {")
		g.P("    return nil, err")
		g.P("  }")
		g.P("  return resp, nil")
		g.P("}")
		g.P()
	}

	// === Server interface ===
	g.P("type ", svcName, "Server interface {")
	for _, m := range service.Methods {
		g.P(m.GoName, "(ctx context.Context, req *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", context.Context, error)")
	}
	g.P("}")
	g.P()

	// === Service registration ===
	g.P("func Register", svcName, "Server(s *rpc.Server, srv ", svcName, "Server) {")
	g.P("  s.RegisterService(&rpc.ServiceDesc{")
	g.P("    ServiceName: \"", service.GoName, "\",")
	g.P("    ServiceImpl: srv,")
	g.P("    Methods: map[string]*rpc.MethodDesc{")
	for _, m := range service.Methods {
		handlerName := fmt.Sprintf("_%s_%s_Handler", svcName, m.GoName)
		g.P("      \"", m.GoName, "\": {")
		g.P("        MethodName: \"", m.GoName, "\",")
		g.P("        Handler: ", handlerName, ",")
		g.P("      },")
	}
	g.P("    },")
	g.P("  }, srv)")
	g.P("}")

	// === Method handler implementations ===
	for _, m := range service.Methods {
		handlerName := fmt.Sprintf("_%s_%s_Handler", svcName, m.GoName)
		inputType := m.Input.GoIdent.GoName

		// Each handler decodes the request and invokes the appropriate method
		g.P("func ", handlerName, "(srv any, ctx context.Context, dec func(any) error) (any, context.Context, error) {")
		g.P("  in := new(", inputType, ")")
		g.P("  if err := dec(in); err != nil { return nil, ctx, err }")
		g.P("  out, newCtx, err := srv.(", svcName, "Server).", m.GoName, "(ctx, in)")
		g.P("  return out, newCtx, err")
		g.P("}")
	}
}
