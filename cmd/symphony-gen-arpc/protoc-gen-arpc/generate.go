package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
)

// generateFile generates the _arpc.pb.go file for a given proto file.
func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_arpc.syn.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	// Header and package declaration
	g.P("// Code generated by protoc-gen-arpc. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P()
	g.P(`import (`)
	g.P(`  "context"`)
	g.P(`  "github.com/appnet-org/arpc/pkg/rpc"`)
	g.P(`  "github.com/appnet-org/arpc/pkg/rpc/element"`)
	g.P(`)`)
	g.P()

	// Assign sequential IDs to services
	serviceIDs := make(map[*protogen.Service]uint32)
	for i, service := range file.Services {
		serviceIDs[service] = uint32(i + 1) // Start from 1
	}

	// Generate service ID constants
	if len(file.Services) > 0 {
		g.P("// Service IDs")
		g.P("const (")
		for _, service := range file.Services {
			g.P("  ServiceID_", service.GoName, " = ", serviceIDs[service])
		}
		g.P(")")
		g.P()

		// Generate service name <-> ID lookup maps
		g.P("// Service name <-> ID mappings")
		g.P("var serviceNameToID = map[string]uint32{")
		for _, service := range file.Services {
			g.P("  \"", service.GoName, "\": ServiceID_", service.GoName, ",")
		}
		g.P("}")
		g.P()

		g.P("var serviceIDToName = map[uint32]string{")
		for _, service := range file.Services {
			g.P("  ServiceID_", service.GoName, ": \"", service.GoName, "\",")
		}
		g.P("}")
		g.P()
	}

	// Generate code for each service in the file
	for _, service := range file.Services {
		genService(g, service, serviceIDs[service])
	}
}

// genService generates the client and server code for a single service.
func genService(g *protogen.GeneratedFile, service *protogen.Service, serviceID uint32) {
	svcName := service.GoName
	clientName := svcName + "Client"

	// Assign sequential IDs to methods
	methodIDs := make(map[*protogen.Method]uint32)
	for i, method := range service.Methods {
		methodIDs[method] = uint32(i + 1) // Start from 1
	}

	// Generate method ID constants
	if len(service.Methods) > 0 {
		g.P("// Method IDs for ", svcName)
		g.P("const (")
		for _, method := range service.Methods {
			g.P("  ", svcName, "_MethodID_", method.GoName, " = ", methodIDs[method])
		}
		g.P(")")
		g.P()

		// Generate method name <-> ID lookup maps
		g.P("// Method name <-> ID mappings for ", svcName)
		g.P("var ", svcName, "_methodNameToID = map[string]uint32{")
		for _, method := range service.Methods {
			g.P("  \"", method.GoName, "\": ", svcName, "_MethodID_", method.GoName, ",")
		}
		g.P("}")
		g.P()

		g.P("var ", svcName, "_methodIDToName = map[uint32]string{")
		for _, method := range service.Methods {
			g.P("  ", svcName, "_MethodID_", method.GoName, ": \"", method.GoName, "\",")
		}
		g.P("}")
		g.P()
	}

	// === Client interface ===
	g.P("// ", clientName, " is the client API for ", svcName, " service.")
	g.P("type ", clientName, " interface {")
	for _, m := range service.Methods {
		g.P(m.GoName, "(ctx context.Context, req *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P()

	// === Client implementation ===
	implName := "arpc" + clientName
	g.P("type ", implName, " struct {")
	g.P("  client *rpc.Client")
	g.P("}")
	g.P()

	// Constructor for the client implementation
	g.P("func New", clientName, "(client *rpc.Client) ", clientName, " {")
	g.P("  // Create and register service registry")
	g.P("  registry := rpc.NewServiceRegistry()")
	g.P("  registry.RegisterService(\"", service.GoName, "\", ServiceID_", service.GoName, ", ", svcName, "_methodNameToID)")
	g.P("  client.SetServiceRegistry(registry)")
	g.P("  return &", implName, "{client: client}")
	g.P("}")
	g.P()

	// Implement each client method by calling rpc.Client.Call
	for _, m := range service.Methods {
		serviceName := service.GoName
		methodName := m.GoName

		g.P("func (c *", implName, ") ", methodName,
			"(ctx context.Context, req *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", error) {")

		g.P("  resp := new(", m.Output.GoIdent, ")")
		g.P("  if err := c.client.Call(ctx, \"", serviceName, "\", \"", methodName, "\", req, resp); err != nil {")
		g.P("    return nil, err")
		g.P("  }")
		g.P("  return resp, nil")
		g.P("}")
		g.P()
	}

	// === Server interface ===
	g.P("type ", svcName, "Server interface {")
	for _, m := range service.Methods {
		g.P(m.GoName, "(ctx context.Context, req *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", context.Context, error)")
	}
	g.P("}")
	g.P()

	// === Service registration ===
	g.P("func Register", svcName, "Server(s *rpc.Server, srv ", svcName, "Server) {")
	g.P("  s.RegisterService(&rpc.ServiceDesc{")
	g.P("    ServiceName: \"", service.GoName, "\",")
	g.P("    ServiceID: ServiceID_", service.GoName, ",")
	g.P("    ServiceImpl: srv,")
	g.P("    MethodsByID: map[uint32]*rpc.MethodDesc{")
	for _, m := range service.Methods {
		handlerName := fmt.Sprintf("_%s_%s_Handler", svcName, m.GoName)
		g.P("      ", svcName, "_MethodID_", m.GoName, ": {")
		g.P("        MethodName: \"", m.GoName, "\",")
		g.P("        MethodID: ", svcName, "_MethodID_", m.GoName, ",")
		g.P("        Handler: ", handlerName, ",")
		g.P("      },")
	}
	g.P("    },")
	g.P("  }, srv)")
	g.P("}")
	g.P("")

	// === Method handler implementations ===
	for _, m := range service.Methods {
		handlerName := fmt.Sprintf("_%s_%s_Handler", svcName, m.GoName)
		inputType := m.Input.GoIdent.GoName

		// Each handler decodes the request and invokes the appropriate method
		g.P("func ", handlerName, "(srv any, ctx context.Context, dec func(any) error, req *element.RPCRequest, chain *element.RPCElementChain) (*element.RPCResponse, context.Context, error) {")
		g.P("  req.Payload = new(", inputType, ")")
		g.P("  if err := dec(req.Payload); err != nil { return nil, ctx, err }")
		g.P("  req, ctx, err := chain.ProcessRequest(ctx, req)")
		g.P("  if err != nil { return nil, ctx, err }")
		g.P("  result, ctx, err := srv.(", svcName, "Server).", m.GoName, "(ctx, req.Payload.(*", inputType, "))")
		g.P("  if err != nil { return nil, ctx, err }")
		g.P("  resp := &element.RPCResponse{")
		g.P("    ID:     req.ID,")
		g.P("    Result: result,")
		g.P("  }")
		g.P("  resp, ctx, err = chain.ProcessResponse(ctx, resp)")
		g.P("  if err != nil { return nil, ctx, err }")
		g.P("  return resp, ctx, err")
		g.P("}")
		g.P("")
	}
}
