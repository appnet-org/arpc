// Code generated by protoc-gen-symphony. DO NOT EDIT.
package Test

import (
	math "math"
)

import (
	"encoding/binary"
	"fmt"
)

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Fixed) MarshalSymphonyPublic() ([]byte, error) {
	size := 0
	size += 17 // table
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 17
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (FInt32): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(m.FInt32))

	// Field 3 (FUint32): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+4:], m.FUint32)

	// Field 5 (FBool): fixed-length (1 bytes)
	if m.FBool {
		buf[tableStart+8] = 1
	} else {
		buf[tableStart+8] = 0
	}

	// Field 7 (FDouble): fixed-length (8 bytes)
	binary.LittleEndian.PutUint64(buf[tableStart+9:], math.Float64bits(m.FDouble))

	return buf, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Fixed) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 20 // table
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 20
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 2 (FInt64): fixed-length (8 bytes)
	binary.LittleEndian.PutUint64(buf[tableStart+0:], uint64(m.FInt64))

	// Field 4 (FUint64): fixed-length (8 bytes)
	binary.LittleEndian.PutUint64(buf[tableStart+8:], m.FUint64)

	// Field 6 (FFloat): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+16:], math.Float32bits(m.FFloat))

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Fixed) UnmarshalSymphonyPublic(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (FInt32): fixed-length (4 bytes)
	if len(data) < tableStart+4 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FInt32 = int32(binary.LittleEndian.Uint32(data[tableStart+0:]))

	// Field 3 (FUint32): fixed-length (4 bytes)
	if len(data) < tableStart+8 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FUint32 = binary.LittleEndian.Uint32(data[tableStart+4:])

	// Field 5 (FBool): fixed-length (1 bytes)
	if len(data) < tableStart+9 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FBool = data[tableStart+8] != 0

	// Field 7 (FDouble): fixed-length (8 bytes)
	if len(data) < tableStart+17 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FDouble = math.Float64frombits(binary.LittleEndian.Uint64(data[tableStart+9:]))

	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Fixed) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 2 (FInt64): fixed-length (8 bytes)
	if len(data) < tableStart+8 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FInt64 = int64(binary.LittleEndian.Uint64(data[tableStart+0:]))

	// Field 4 (FUint64): fixed-length (8 bytes)
	if len(data) < tableStart+16 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FUint64 = binary.LittleEndian.Uint64(data[tableStart+8:])

	// Field 6 (FFloat): fixed-length (4 bytes)
	if len(data) < tableStart+20 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FFloat = math.Float32frombits(binary.LittleEndian.Uint32(data[tableStart+16:]))

	return nil
}

func (m *Fixed) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	size += 17 // table entries
	// Private segment:
	size += 1  // version byte
	size += 20 // table entries

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13
	publicSegmentSize += 4 // field FInt32
	publicSegmentSize += 4 // field FUint32
	publicSegmentSize += 1 // field FBool
	publicSegmentSize += 8 // field FDouble

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 17
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// Field 1 (FInt32): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[publicTableStart+0:], uint32(m.FInt32))

	// Field 3 (FUint32): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[publicTableStart+4:], m.FUint32)

	// Field 5 (FBool): fixed-length (1 bytes)
	if m.FBool {
		buf[publicTableStart+8] = 1
	} else {
		buf[publicTableStart+8] = 0
	}

	// Field 7 (FDouble): fixed-length (8 bytes)
	binary.LittleEndian.PutUint64(buf[publicTableStart+9:], math.Float64bits(m.FDouble))

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 20 bytes table
	privatePayloadStart := privateTableStart + 20
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 2 (FInt64): fixed-length (8 bytes)
	binary.LittleEndian.PutUint64(buf[privateTableStart+0:], uint64(m.FInt64))

	// Field 4 (FUint64): fixed-length (8 bytes)
	binary.LittleEndian.PutUint64(buf[privateTableStart+8:], m.FUint64)

	// Field 6 (FFloat): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[privateTableStart+16:], math.Float32bits(m.FFloat))

	return buf, nil
}

func (m *Fixed) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// Field 1 (FInt32): fixed-length (4 bytes)
	if len(data) < publicTableStart+4 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FInt32 = int32(binary.LittleEndian.Uint32(data[publicTableStart+0:]))

	// Field 3 (FUint32): fixed-length (4 bytes)
	if len(data) < publicTableStart+8 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FUint32 = binary.LittleEndian.Uint32(data[publicTableStart+4:])

	// Field 5 (FBool): fixed-length (1 bytes)
	if len(data) < publicTableStart+9 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FBool = data[publicTableStart+8] != 0

	// Field 7 (FDouble): fixed-length (8 bytes)
	if len(data) < publicTableStart+17 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FDouble = math.Float64frombits(binary.LittleEndian.Uint64(data[publicTableStart+9:]))

	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 2 (FInt64): fixed-length (8 bytes)
	if len(data) < privateTableStart+8 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FInt64 = int64(binary.LittleEndian.Uint64(data[privateTableStart+0:]))

	// Field 4 (FUint64): fixed-length (8 bytes)
	if len(data) < privateTableStart+16 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FUint64 = binary.LittleEndian.Uint64(data[privateTableStart+8:])

	// Field 6 (FFloat): fixed-length (4 bytes)
	if len(data) < privateTableStart+20 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FFloat = math.Float32frombits(binary.LittleEndian.Uint32(data[privateTableStart+16:]))

	return nil
}

type FixedRaw []byte

func (m FixedRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *FixedRaw) UnmarshalSymphony(data []byte) error {
	*m = FixedRaw(data)
	return nil
}

func (m FixedRaw) GetFInt32() int32 {
	// Field 1 (FInt32): fixed-length (4 bytes)
	if len(m) < 13+4 {
		return 0
	}
	return int32(binary.LittleEndian.Uint32(m[13:]))
}

func (m FixedRaw) GetFInt64() int64 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (FInt64): fixed-length (8 bytes)
	if len(m) < offsetToPrivate+1+8 {
		return 0
	}
	return int64(binary.LittleEndian.Uint64(m[offsetToPrivate+1:]))
}

func (m FixedRaw) GetFUint32() uint32 {
	// Field 3 (FUint32): fixed-length (4 bytes)
	if len(m) < 17+4 {
		return 0
	}
	return binary.LittleEndian.Uint32(m[17:])
}

func (m FixedRaw) GetFUint64() uint64 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 4 (FUint64): fixed-length (8 bytes)
	if len(m) < offsetToPrivate+9+8 {
		return 0
	}
	return binary.LittleEndian.Uint64(m[offsetToPrivate+9:])
}

func (m FixedRaw) GetFBool() bool {
	// Field 5 (FBool): fixed-length (1 bytes)
	if len(m) < 21+1 {
		return false
	}
	return m[21] != 0
}

func (m FixedRaw) GetFFloat() float32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 6 (FFloat): fixed-length (4 bytes)
	if len(m) < offsetToPrivate+17+4 {
		return 0
	}
	return math.Float32frombits(binary.LittleEndian.Uint32(m[offsetToPrivate+17:]))
}

func (m FixedRaw) GetFDouble() float64 {
	// Field 7 (FDouble): fixed-length (8 bytes)
	if len(m) < 22+8 {
		return 0
	}
	return math.Float64frombits(binary.LittleEndian.Uint64(m[22:]))
}

func (m *FixedRaw) SetFInt32(v int32) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 1 (FInt32): fixed-length (4 bytes)
	if len(*m) < 13+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[13:], uint32(v))
	return nil
}

func (m *FixedRaw) SetFInt64(v int64) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (FInt64): fixed-length (8 bytes)
	if len(*m) < offsetToPrivate+1+8 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint64((*m)[offsetToPrivate+1:], uint64(v))
	return nil
}

func (m *FixedRaw) SetFUint32(v uint32) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 3 (FUint32): fixed-length (4 bytes)
	if len(*m) < 17+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[17:], v)
	return nil
}

func (m *FixedRaw) SetFUint64(v uint64) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 4 (FUint64): fixed-length (8 bytes)
	if len(*m) < offsetToPrivate+9+8 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint64((*m)[offsetToPrivate+9:], v)
	return nil
}

func (m *FixedRaw) SetFBool(v bool) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 5 (FBool): fixed-length (1 bytes)
	if len(*m) < 21+1 {
		return fmt.Errorf("buffer too short")
	}
	if v {
		(*m)[21] = 1
	} else {
		(*m)[21] = 0
	}
	return nil
}

func (m *FixedRaw) SetFFloat(v float32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 6 (FFloat): fixed-length (4 bytes)
	if len(*m) < offsetToPrivate+17+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[offsetToPrivate+17:], math.Float32bits(v))
	return nil
}

func (m *FixedRaw) SetFDouble(v float64) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 7 (FDouble): fixed-length (8 bytes)
	if len(*m) < 22+8 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint64((*m)[22:], math.Float64bits(v))
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Var) MarshalSymphonyPublic() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.VString)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (VString): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.VString)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.VString)
	payloadOffset += 4 + len(m.VString)

	return buf, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Var) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.VBytes)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 2 (VBytes): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.VBytes)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.VBytes)
	payloadOffset += 4 + len(m.VBytes)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Var) UnmarshalSymphonyPublic(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (VString): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.VString = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Var) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 2 (VBytes): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.VBytes = make([]byte, dataLen)
				copy(m.VBytes, data[payloadOffset+4:payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *Var) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	size += 4  // table entries
	// Field 1 (VString): variable-length payload
	size += 4 + len(m.VString) // 4 bytes length prefix + data
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 2 (VBytes): variable-length payload
	size += 4 + len(m.VBytes) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13
	publicSegmentSize += 4                  // offset placeholder
	publicSegmentSize += 4 + len(m.VString) // field 1 payload

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 4
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// Field 1 (VString): variable-length
	binary.LittleEndian.PutUint32(buf[publicTableStart+0:], uint32(publicPayloadStart+publicPayloadOffset))
	dataLen = len(m.VString)
	binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(dataLen))
	copy(buf[publicPayloadStart+publicPayloadOffset+4:], m.VString)
	publicPayloadOffset += 4 + len(m.VString)

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 2 (VBytes): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.VBytes)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.VBytes)
	privatePayloadOffset += 4 + len(m.VBytes)

	return buf, nil
}

func (m *Var) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// Field 1 (VString): variable-length
	if len(data) >= publicTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.VString = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 2 (VBytes): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.VBytes = make([]byte, dataLen)
				copy(m.VBytes, data[payloadOffset+4:payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type VarRaw []byte

func (m VarRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *VarRaw) UnmarshalSymphony(data []byte) error {
	*m = VarRaw(data)
	return nil
}

func (m VarRaw) GetVString() string {
	// Field 1 (VString): variable-length
	if len(m) < 13+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[13:]))
	if payloadOffset == 0 {
		return ""
	}
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m VarRaw) GetVBytes() []byte {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (VBytes): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return nil
	}
	result := make([]byte, dataLen)
	copy(result, m[payloadOffset+4:payloadOffset+4+dataLen])
	return result
}

func (m *VarRaw) SetVString(v string) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 1 (VString): variable-length
	if len(*m) < 13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[13:]))
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	// Preserve reserved bytes (serviceID at bytes 5-9, methodID at bytes 9-13) from original buffer
	var originalServiceID, originalMethodID uint32
	if len(*m) >= 13 {
		originalServiceID = binary.LittleEndian.Uint32((*m)[5:9])
		originalMethodID = binary.LittleEndian.Uint32((*m)[9:13])
	}
	var temp Var
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 4                                    // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.VString = v
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	// Restore reserved bytes (serviceID and methodID) in the marshaled payload
	if len(fullData) >= 13 {
		binary.LittleEndian.PutUint32(fullData[5:9], originalServiceID)
		binary.LittleEndian.PutUint32(fullData[9:13], originalMethodID)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = VarRaw(fullData[:offsetToPrivate])
	return nil
}

func (m *VarRaw) SetVBytes(v []byte) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (VBytes): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Var
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.VBytes = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = VarRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *RepeatedFixed) MarshalSymphonyPublic() ([]byte, error) {
	size := 0
	size += 12 // table
	size += 4 + 8*len(m.RInt64)
	size += 4 + 8*len(m.RUint64)
	size += 4 + 8*len(m.RDouble)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 12
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 2 (RInt64): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	count = len(m.RInt64)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	for i, v := range m.RInt64 {
		binary.LittleEndian.PutUint64(buf[payloadStart+payloadOffset+4+8*i:], uint64(v))
	}
	payloadOffset += 4 + 8*len(m.RInt64)

	// Field 4 (RUint64): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	count = len(m.RUint64)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	for i, v := range m.RUint64 {
		binary.LittleEndian.PutUint64(buf[payloadStart+payloadOffset+4+8*i:], v)
	}
	payloadOffset += 4 + 8*len(m.RUint64)

	// Field 6 (RDouble): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[tableStart+8:], uint32(payloadStart+payloadOffset))
	count = len(m.RDouble)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	for i, v := range m.RDouble {
		binary.LittleEndian.PutUint64(buf[payloadStart+payloadOffset+4+8*i:], math.Float64bits(v))
	}
	payloadOffset += 4 + 8*len(m.RDouble)

	return buf, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *RepeatedFixed) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 16 // table
	size += 4 + 4*len(m.RInt32)
	size += 4 + 4*len(m.RUint32)
	size += 4 + 4*len(m.RFloat)
	size += 4 + 1*len(m.RBool)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 16
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (RInt32): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	count = len(m.RInt32)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	for i, v := range m.RInt32 {
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset+4+4*i:], uint32(v))
	}
	payloadOffset += 4 + 4*len(m.RInt32)

	// Field 3 (RUint32): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	count = len(m.RUint32)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	for i, v := range m.RUint32 {
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset+4+4*i:], v)
	}
	payloadOffset += 4 + 4*len(m.RUint32)

	// Field 5 (RFloat): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[tableStart+8:], uint32(payloadStart+payloadOffset))
	count = len(m.RFloat)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	for i, v := range m.RFloat {
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset+4+4*i:], math.Float32bits(v))
	}
	payloadOffset += 4 + 4*len(m.RFloat)

	// Field 7 (RBool): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[tableStart+12:], uint32(payloadStart+payloadOffset))
	count = len(m.RBool)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	for i, v := range m.RBool {
		if v {
			buf[payloadStart+payloadOffset+4+1*i] = 1
		} else {
			buf[payloadStart+payloadOffset+4+1*i] = 0
		}
	}
	payloadOffset += 4 + 1*len(m.RBool)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *RepeatedFixed) UnmarshalSymphonyPublic(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 2 (RInt64): repeated fixed-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*8 {
				m.RInt64 = make([]int64, count)
				for i := 0; i < count; i++ {
					m.RInt64[i] = int64(binary.LittleEndian.Uint64(data[payloadOffset+4+8*i:]))
				}
			}
		}
	}

	// Field 4 (RUint64): repeated fixed-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*8 {
				m.RUint64 = make([]uint64, count)
				for i := 0; i < count; i++ {
					m.RUint64[i] = binary.LittleEndian.Uint64(data[payloadOffset+4+8*i:])
				}
			}
		}
	}

	// Field 6 (RDouble): repeated fixed-length
	if len(data) >= tableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+8:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*8 {
				m.RDouble = make([]float64, count)
				for i := 0; i < count; i++ {
					m.RDouble[i] = math.Float64frombits(binary.LittleEndian.Uint64(data[payloadOffset+4+8*i:]))
				}
			}
		}
	}

	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *RepeatedFixed) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (RInt32): repeated fixed-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*4 {
				m.RInt32 = make([]int32, count)
				for i := 0; i < count; i++ {
					m.RInt32[i] = int32(binary.LittleEndian.Uint32(data[payloadOffset+4+4*i:]))
				}
			}
		}
	}

	// Field 3 (RUint32): repeated fixed-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*4 {
				m.RUint32 = make([]uint32, count)
				for i := 0; i < count; i++ {
					m.RUint32[i] = binary.LittleEndian.Uint32(data[payloadOffset+4+4*i:])
				}
			}
		}
	}

	// Field 5 (RFloat): repeated fixed-length
	if len(data) >= tableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+8:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*4 {
				m.RFloat = make([]float32, count)
				for i := 0; i < count; i++ {
					m.RFloat[i] = math.Float32frombits(binary.LittleEndian.Uint32(data[payloadOffset+4+4*i:]))
				}
			}
		}
	}

	// Field 7 (RBool): repeated fixed-length
	if len(data) >= tableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+12:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*1 {
				m.RBool = make([]bool, count)
				for i := 0; i < count; i++ {
					m.RBool[i] = data[payloadOffset+4+1*i] != 0
				}
			}
		}
	}

	return nil
}

func (m *RepeatedFixed) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	size += 12 // table entries
	// Field 2 (RInt64): repeated fixed-length payload
	size += 4 + 8*len(m.RInt64) // 4 bytes count + data
	// Field 4 (RUint64): repeated fixed-length payload
	size += 4 + 8*len(m.RUint64) // 4 bytes count + data
	// Field 6 (RDouble): repeated fixed-length payload
	size += 4 + 8*len(m.RDouble) // 4 bytes count + data
	// Private segment:
	size += 1  // version byte
	size += 16 // table entries
	// Field 1 (RInt32): repeated fixed-length payload
	size += 4 + 4*len(m.RInt32) // 4 bytes count + data
	// Field 3 (RUint32): repeated fixed-length payload
	size += 4 + 4*len(m.RUint32) // 4 bytes count + data
	// Field 5 (RFloat): repeated fixed-length payload
	size += 4 + 4*len(m.RFloat) // 4 bytes count + data
	// Field 7 (RBool): repeated fixed-length payload
	size += 4 + 1*len(m.RBool) // 4 bytes count + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13
	publicSegmentSize += 4                    // offset placeholder
	publicSegmentSize += 4                    // offset placeholder
	publicSegmentSize += 4                    // offset placeholder
	publicSegmentSize += 4 + 8*len(m.RInt64)  // field 2 payload
	publicSegmentSize += 4 + 8*len(m.RUint64) // field 4 payload
	publicSegmentSize += 4 + 8*len(m.RDouble) // field 6 payload

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 12
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// Field 2 (RInt64): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[publicTableStart+0:], uint32(publicPayloadStart+publicPayloadOffset))
	count = len(m.RInt64)
	binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(count))
	for i, v := range m.RInt64 {
		binary.LittleEndian.PutUint64(buf[publicPayloadStart+publicPayloadOffset+4+8*i:], uint64(v))
	}
	publicPayloadOffset += 4 + 8*len(m.RInt64)

	// Field 4 (RUint64): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[publicTableStart+4:], uint32(publicPayloadStart+publicPayloadOffset))
	count = len(m.RUint64)
	binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(count))
	for i, v := range m.RUint64 {
		binary.LittleEndian.PutUint64(buf[publicPayloadStart+publicPayloadOffset+4+8*i:], v)
	}
	publicPayloadOffset += 4 + 8*len(m.RUint64)

	// Field 6 (RDouble): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[publicTableStart+8:], uint32(publicPayloadStart+publicPayloadOffset))
	count = len(m.RDouble)
	binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(count))
	for i, v := range m.RDouble {
		binary.LittleEndian.PutUint64(buf[publicPayloadStart+publicPayloadOffset+4+8*i:], math.Float64bits(v))
	}
	publicPayloadOffset += 4 + 8*len(m.RDouble)

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 16 bytes table
	privatePayloadStart := privateTableStart + 16
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (RInt32): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.RInt32)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	for i, v := range m.RInt32 {
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset+4+4*i:], uint32(v))
	}
	privatePayloadOffset += 4 + 4*len(m.RInt32)

	// Field 3 (RUint32): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.RUint32)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	for i, v := range m.RUint32 {
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset+4+4*i:], v)
	}
	privatePayloadOffset += 4 + 4*len(m.RUint32)

	// Field 5 (RFloat): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+8:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.RFloat)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	for i, v := range m.RFloat {
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset+4+4*i:], math.Float32bits(v))
	}
	privatePayloadOffset += 4 + 4*len(m.RFloat)

	// Field 7 (RBool): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+12:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.RBool)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	for i, v := range m.RBool {
		if v {
			buf[privatePayloadStart+privatePayloadOffset+4+1*i] = 1
		} else {
			buf[privatePayloadStart+privatePayloadOffset+4+1*i] = 0
		}
	}
	privatePayloadOffset += 4 + 1*len(m.RBool)

	return buf, nil
}

func (m *RepeatedFixed) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// Field 2 (RInt64): repeated fixed-length
	if len(data) >= publicTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*8 {
				m.RInt64 = make([]int64, count)
				for i := 0; i < count; i++ {
					m.RInt64[i] = int64(binary.LittleEndian.Uint64(data[payloadOffset+4+8*i:]))
				}
			}
		}
	}

	// Field 4 (RUint64): repeated fixed-length
	if len(data) >= publicTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*8 {
				m.RUint64 = make([]uint64, count)
				for i := 0; i < count; i++ {
					m.RUint64[i] = binary.LittleEndian.Uint64(data[payloadOffset+4+8*i:])
				}
			}
		}
	}

	// Field 6 (RDouble): repeated fixed-length
	if len(data) >= publicTableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+8:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*8 {
				m.RDouble = make([]float64, count)
				for i := 0; i < count; i++ {
					m.RDouble[i] = math.Float64frombits(binary.LittleEndian.Uint64(data[payloadOffset+4+8*i:]))
				}
			}
		}
	}

	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (RInt32): repeated fixed-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*4 {
				m.RInt32 = make([]int32, count)
				for i := 0; i < count; i++ {
					m.RInt32[i] = int32(binary.LittleEndian.Uint32(data[payloadOffset+4+4*i:]))
				}
			}
		}
	}

	// Field 3 (RUint32): repeated fixed-length
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*4 {
				m.RUint32 = make([]uint32, count)
				for i := 0; i < count; i++ {
					m.RUint32[i] = binary.LittleEndian.Uint32(data[payloadOffset+4+4*i:])
				}
			}
		}
	}

	// Field 5 (RFloat): repeated fixed-length
	if len(data) >= privateTableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+8:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*4 {
				m.RFloat = make([]float32, count)
				for i := 0; i < count; i++ {
					m.RFloat[i] = math.Float32frombits(binary.LittleEndian.Uint32(data[payloadOffset+4+4*i:]))
				}
			}
		}
	}

	// Field 7 (RBool): repeated fixed-length
	if len(data) >= privateTableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+12:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*1 {
				m.RBool = make([]bool, count)
				for i := 0; i < count; i++ {
					m.RBool[i] = data[payloadOffset+4+1*i] != 0
				}
			}
		}
	}

	return nil
}

type RepeatedFixedRaw []byte

func (m RepeatedFixedRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *RepeatedFixedRaw) UnmarshalSymphony(data []byte) error {
	*m = RepeatedFixedRaw(data)
	return nil
}

func (m RepeatedFixedRaw) GetRInt32() []int32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (RInt32): repeated fixed-length
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+4*count {
		return nil
	}
	result := make([]int32, count)
	for i := 0; i < count; i++ {
		result[i] = int32(binary.LittleEndian.Uint32(m[payloadOffset+4+4*i:]))
	}
	return result
}

func (m RepeatedFixedRaw) GetRInt64() []int64 {
	// Field 2 (RInt64): repeated fixed-length
	if len(m) < 13+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[13:]))
	if payloadOffset == 0 {
		return nil
	}
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+8*count {
		return nil
	}
	result := make([]int64, count)
	for i := 0; i < count; i++ {
		result[i] = int64(binary.LittleEndian.Uint64(m[payloadOffset+4+8*i:]))
	}
	return result
}

func (m RepeatedFixedRaw) GetRUint32() []uint32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 3 (RUint32): repeated fixed-length
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+4*count {
		return nil
	}
	result := make([]uint32, count)
	for i := 0; i < count; i++ {
		result[i] = binary.LittleEndian.Uint32(m[payloadOffset+4+4*i:])
	}
	return result
}

func (m RepeatedFixedRaw) GetRUint64() []uint64 {
	// Field 4 (RUint64): repeated fixed-length
	if len(m) < 17+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[17:]))
	if payloadOffset == 0 {
		return nil
	}
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+8*count {
		return nil
	}
	result := make([]uint64, count)
	for i := 0; i < count; i++ {
		result[i] = binary.LittleEndian.Uint64(m[payloadOffset+4+8*i:])
	}
	return result
}

func (m RepeatedFixedRaw) GetRFloat() []float32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 5 (RFloat): repeated fixed-length
	if len(m) < offsetToPrivate+9+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+9:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+4*count {
		return nil
	}
	result := make([]float32, count)
	for i := 0; i < count; i++ {
		result[i] = math.Float32frombits(binary.LittleEndian.Uint32(m[payloadOffset+4+4*i:]))
	}
	return result
}

func (m RepeatedFixedRaw) GetRDouble() []float64 {
	// Field 6 (RDouble): repeated fixed-length
	if len(m) < 21+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[21:]))
	if payloadOffset == 0 {
		return nil
	}
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+8*count {
		return nil
	}
	result := make([]float64, count)
	for i := 0; i < count; i++ {
		result[i] = math.Float64frombits(binary.LittleEndian.Uint64(m[payloadOffset+4+8*i:]))
	}
	return result
}

func (m RepeatedFixedRaw) GetRBool() []bool {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 7 (RBool): repeated fixed-length
	if len(m) < offsetToPrivate+13+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+13:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+1*count {
		return nil
	}
	result := make([]bool, count)
	for i := 0; i < count; i++ {
		result[i] = m[payloadOffset+4+1*i] != 0
	}
	return result
}

func (m *RepeatedFixedRaw) SetRInt32(v []int32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (RInt32): repeated fixed-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		oldDataSize = 4 + 4*oldCount // 4 bytes count + data
	}
	newCount := len(v)
	newDataSize := 4 + 4*newCount // 4 bytes count + data
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		for i, val := range v {
			binary.LittleEndian.PutUint32((*m)[oldPayloadOffset+4+4*i:], uint32(val))
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp RepeatedFixed
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RInt32 = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = RepeatedFixedRaw(newData)
	return nil
}

func (m *RepeatedFixedRaw) SetRInt64(v []int64) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 2 (RInt64): repeated fixed-length
	if len(*m) < 13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[13:]))
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		oldDataSize = 4 + 8*oldCount // 4 bytes count + data
	}
	newCount := len(v)
	newDataSize := 4 + 8*newCount // 4 bytes count + data
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		for i, val := range v {
			binary.LittleEndian.PutUint64((*m)[oldPayloadOffset+4+8*i:], uint64(val))
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	// Preserve reserved bytes (serviceID at bytes 5-9, methodID at bytes 9-13) from original buffer
	var originalServiceID, originalMethodID uint32
	if len(*m) >= 13 {
		originalServiceID = binary.LittleEndian.Uint32((*m)[5:9])
		originalMethodID = binary.LittleEndian.Uint32((*m)[9:13])
	}
	var temp RepeatedFixed
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 16                                   // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RInt64 = v
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	// Restore reserved bytes (serviceID and methodID) in the marshaled payload
	if len(fullData) >= 13 {
		binary.LittleEndian.PutUint32(fullData[5:9], originalServiceID)
		binary.LittleEndian.PutUint32(fullData[9:13], originalMethodID)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = RepeatedFixedRaw(fullData[:offsetToPrivate])
	return nil
}

func (m *RepeatedFixedRaw) SetRUint32(v []uint32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 3 (RUint32): repeated fixed-length
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		oldDataSize = 4 + 4*oldCount // 4 bytes count + data
	}
	newCount := len(v)
	newDataSize := 4 + 4*newCount // 4 bytes count + data
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		for i, val := range v {
			binary.LittleEndian.PutUint32((*m)[oldPayloadOffset+4+4*i:], val)
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp RepeatedFixed
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RUint32 = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = RepeatedFixedRaw(newData)
	return nil
}

func (m *RepeatedFixedRaw) SetRUint64(v []uint64) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 4 (RUint64): repeated fixed-length
	if len(*m) < 17+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[17:]))
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		oldDataSize = 4 + 8*oldCount // 4 bytes count + data
	}
	newCount := len(v)
	newDataSize := 4 + 8*newCount // 4 bytes count + data
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		for i, val := range v {
			binary.LittleEndian.PutUint64((*m)[oldPayloadOffset+4+8*i:], val)
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	// Preserve reserved bytes (serviceID at bytes 5-9, methodID at bytes 9-13) from original buffer
	var originalServiceID, originalMethodID uint32
	if len(*m) >= 13 {
		originalServiceID = binary.LittleEndian.Uint32((*m)[5:9])
		originalMethodID = binary.LittleEndian.Uint32((*m)[9:13])
	}
	var temp RepeatedFixed
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 16                                   // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RUint64 = v
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	// Restore reserved bytes (serviceID and methodID) in the marshaled payload
	if len(fullData) >= 13 {
		binary.LittleEndian.PutUint32(fullData[5:9], originalServiceID)
		binary.LittleEndian.PutUint32(fullData[9:13], originalMethodID)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = RepeatedFixedRaw(fullData[:offsetToPrivate])
	return nil
}

func (m *RepeatedFixedRaw) SetRFloat(v []float32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 5 (RFloat): repeated fixed-length
	if len(*m) < offsetToPrivate+9+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+9:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		oldDataSize = 4 + 4*oldCount // 4 bytes count + data
	}
	newCount := len(v)
	newDataSize := 4 + 4*newCount // 4 bytes count + data
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		for i, val := range v {
			binary.LittleEndian.PutUint32((*m)[oldPayloadOffset+4+4*i:], math.Float32bits(val))
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp RepeatedFixed
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RFloat = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = RepeatedFixedRaw(newData)
	return nil
}

func (m *RepeatedFixedRaw) SetRDouble(v []float64) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 6 (RDouble): repeated fixed-length
	if len(*m) < 21+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[21:]))
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		oldDataSize = 4 + 8*oldCount // 4 bytes count + data
	}
	newCount := len(v)
	newDataSize := 4 + 8*newCount // 4 bytes count + data
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		for i, val := range v {
			binary.LittleEndian.PutUint64((*m)[oldPayloadOffset+4+8*i:], math.Float64bits(val))
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	// Preserve reserved bytes (serviceID at bytes 5-9, methodID at bytes 9-13) from original buffer
	var originalServiceID, originalMethodID uint32
	if len(*m) >= 13 {
		originalServiceID = binary.LittleEndian.Uint32((*m)[5:9])
		originalMethodID = binary.LittleEndian.Uint32((*m)[9:13])
	}
	var temp RepeatedFixed
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 16                                   // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RDouble = v
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	// Restore reserved bytes (serviceID and methodID) in the marshaled payload
	if len(fullData) >= 13 {
		binary.LittleEndian.PutUint32(fullData[5:9], originalServiceID)
		binary.LittleEndian.PutUint32(fullData[9:13], originalMethodID)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = RepeatedFixedRaw(fullData[:offsetToPrivate])
	return nil
}

func (m *RepeatedFixedRaw) SetRBool(v []bool) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 7 (RBool): repeated fixed-length
	if len(*m) < offsetToPrivate+13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+13:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		oldDataSize = 4 + 1*oldCount // 4 bytes count + data
	}
	newCount := len(v)
	newDataSize := 4 + 1*newCount // 4 bytes count + data
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		for i, val := range v {
			if val {
				(*m)[oldPayloadOffset+4+1*i] = 1
			} else {
				(*m)[oldPayloadOffset+4+1*i] = 0
			}
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp RepeatedFixed
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RBool = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = RepeatedFixedRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *RepeatedVar) MarshalSymphonyPublic() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 // count for RString
	for _, item := range m.RString {
		size += 4 + len(item)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (RString): repeated variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	count = len(m.RString)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	currentOffset = payloadStart + payloadOffset + 4
	for _, item := range m.RString {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	payloadOffset += 4 // count
	for _, item := range m.RString {
		payloadOffset += 4 + len(item)
	}

	return buf, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *RepeatedVar) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 // count for RBytes
	for _, item := range m.RBytes {
		size += 4 + len(item)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 2 (RBytes): repeated variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	count = len(m.RBytes)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	currentOffset = payloadStart + payloadOffset + 4
	for _, item := range m.RBytes {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	payloadOffset += 4 // count
	for _, item := range m.RBytes {
		payloadOffset += 4 + len(item)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *RepeatedVar) UnmarshalSymphonyPublic(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (RString): repeated variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.RString = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.RString = append(m.RString, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *RepeatedVar) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 2 (RBytes): repeated variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.RBytes = make([][]byte, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						itemData := make([]byte, itemLen)
						copy(itemData, data[currentOffset+4:currentOffset+4+itemLen])
						m.RBytes = append(m.RBytes, itemData)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *RepeatedVar) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	size += 4  // table entries
	// Field 1 (RString): repeated variable-length payload
	size += 4 // count
	for _, item := range m.RString {
		size += 4 + len(item) // 4 bytes length prefix + data
	}
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 2 (RBytes): repeated variable-length payload
	size += 4 // count
	for _, item := range m.RBytes {
		size += 4 + len(item) // 4 bytes length prefix + data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13
	publicSegmentSize += 4 // offset placeholder
	publicSegmentSize += 4 // field 1 count
	for _, item := range m.RString {
		publicSegmentSize += 4 + len(item)
	}

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 4
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// Field 1 (RString): repeated variable-length
	binary.LittleEndian.PutUint32(buf[publicTableStart+0:], uint32(publicPayloadStart+publicPayloadOffset))
	count = len(m.RString)
	binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(count))
	currentOffset = publicPayloadStart + publicPayloadOffset + 4
	for _, item := range m.RString {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	publicPayloadOffset += 4 // count
	for _, item := range m.RString {
		publicPayloadOffset += 4 + len(item)
	}

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 2 (RBytes): repeated variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.RBytes)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	currentOffset = privatePayloadStart + privatePayloadOffset + 4
	for _, item := range m.RBytes {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	privatePayloadOffset += 4 // count
	for _, item := range m.RBytes {
		privatePayloadOffset += 4 + len(item)
	}

	return buf, nil
}

func (m *RepeatedVar) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// Field 1 (RString): repeated variable-length
	if len(data) >= publicTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.RString = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.RString = append(m.RString, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 2 (RBytes): repeated variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.RBytes = make([][]byte, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						itemData := make([]byte, itemLen)
						copy(itemData, data[currentOffset+4:currentOffset+4+itemLen])
						m.RBytes = append(m.RBytes, itemData)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type RepeatedVarRaw []byte

func (m RepeatedVarRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *RepeatedVarRaw) UnmarshalSymphony(data []byte) error {
	*m = RepeatedVarRaw(data)
	return nil
}

func (m RepeatedVarRaw) GetRString() []string {
	// Field 1 (RString): repeated variable-length
	if len(m) < 13+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[13:]))
	if payloadOffset == 0 {
		return nil
	}
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]string, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		itemLen := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+itemLen {
			return nil
		}
		result[i] = string(m[currentOffset+4 : currentOffset+4+itemLen])
		currentOffset += 4 + itemLen
	}
	return result
}

func (m RepeatedVarRaw) GetRBytes() [][]byte {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (RBytes): repeated variable-length
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([][]byte, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		itemLen := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+itemLen {
			return nil
		}
		result[i] = make([]byte, itemLen)
		copy(result[i], m[currentOffset+4:currentOffset+4+itemLen])
		currentOffset += 4 + itemLen
	}
	return result
}

func (m *RepeatedVarRaw) SetRString(v []string) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 1 (RString): repeated variable-length
	if len(*m) < 13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[13:]))
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes length + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemLen := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemLen
			currentOffset += 4 + itemLen
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes length + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemLen := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemLen))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemLen
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	// Preserve reserved bytes (serviceID at bytes 5-9, methodID at bytes 9-13) from original buffer
	var originalServiceID, originalMethodID uint32
	if len(*m) >= 13 {
		originalServiceID = binary.LittleEndian.Uint32((*m)[5:9])
		originalMethodID = binary.LittleEndian.Uint32((*m)[9:13])
	}
	var temp RepeatedVar
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 4                                    // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RString = v
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	// Restore reserved bytes (serviceID and methodID) in the marshaled payload
	if len(fullData) >= 13 {
		binary.LittleEndian.PutUint32(fullData[5:9], originalServiceID)
		binary.LittleEndian.PutUint32(fullData[9:13], originalMethodID)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = RepeatedVarRaw(fullData[:offsetToPrivate])
	return nil
}

func (m *RepeatedVarRaw) SetRBytes(v [][]byte) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (RBytes): repeated variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes length + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemLen := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemLen
			currentOffset += 4 + itemLen
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes length + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemLen := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemLen))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemLen
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp RepeatedVar
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RBytes = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = RepeatedVarRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Leaf) MarshalSymphonyPublic() ([]byte, error) {
	size := 0
	size += 4 // table
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (LeafId): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(m.LeafId))

	return buf, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Leaf) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.LeafVal)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 2 (LeafVal): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.LeafVal)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.LeafVal)
	payloadOffset += 4 + len(m.LeafVal)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Leaf) UnmarshalSymphonyPublic(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (LeafId): fixed-length (4 bytes)
	if len(data) < tableStart+4 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.LeafId = int32(binary.LittleEndian.Uint32(data[tableStart+0:]))

	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Leaf) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 2 (LeafVal): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.LeafVal = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *Leaf) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	size += 4  // table entries
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 2 (LeafVal): variable-length payload
	size += 4 + len(m.LeafVal) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13
	publicSegmentSize += 4 // field LeafId

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 4
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// Field 1 (LeafId): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[publicTableStart+0:], uint32(m.LeafId))

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 2 (LeafVal): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.LeafVal)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.LeafVal)
	privatePayloadOffset += 4 + len(m.LeafVal)

	return buf, nil
}

func (m *Leaf) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// Field 1 (LeafId): fixed-length (4 bytes)
	if len(data) < publicTableStart+4 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.LeafId = int32(binary.LittleEndian.Uint32(data[publicTableStart+0:]))

	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 2 (LeafVal): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.LeafVal = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type LeafRaw []byte

func (m LeafRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *LeafRaw) UnmarshalSymphony(data []byte) error {
	*m = LeafRaw(data)
	return nil
}

func (m LeafRaw) GetLeafId() int32 {
	// Field 1 (LeafId): fixed-length (4 bytes)
	if len(m) < 13+4 {
		return 0
	}
	return int32(binary.LittleEndian.Uint32(m[13:]))
}

func (m LeafRaw) GetLeafVal() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (LeafVal): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *LeafRaw) SetLeafId(v int32) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 1 (LeafId): fixed-length (4 bytes)
	if len(*m) < 13+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[13:], uint32(v))
	return nil
}

func (m *LeafRaw) SetLeafVal(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (LeafVal): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Leaf
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.LeafVal = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = LeafRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Level2) MarshalSymphonyPublic() ([]byte, error) {
	size := 0
	size += 4 // table
	if m.Leaf != nil {
		nested, _ := m.Leaf.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Leaf): nested message
	if m.Leaf != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.Leaf.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], 0)
	}

	return buf, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Level2) MarshalSymphonyPrivate() ([]byte, error) {
	return []byte{}, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Level2) UnmarshalSymphonyPublic(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Leaf): nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Leaf = &Leaf{}
				if err := m.Leaf.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Level2) UnmarshalSymphonyPrivate(data []byte) error {
	return nil
}

func (m *Level2) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	size += 4  // table entries
	// Field 1 (Leaf): nested message payload
	if m.Leaf != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		nestedSize1 += 4  // table entries
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 4 // table entries
		// Field 2 (LeafVal): variable-length payload
		nestedSize1 += 4 + len(m.Leaf.LeafVal) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Private segment:
	size += 1 // version byte

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13
	publicSegmentSize += 4 // offset placeholder
	if m.Leaf != nil {
		nestedData1, _ := m.Leaf.MarshalSymphony()
		publicSegmentSize += 4 + len(nestedData1) // field 1 payload
	}

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 4
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// Field 1 (Leaf): nested message
	if m.Leaf != nil {
		binary.LittleEndian.PutUint32(buf[publicTableStart+0:], uint32(publicPayloadStart+publicPayloadOffset))
		nestedData, err := m.Leaf.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(nestedSize))
		copy(buf[publicPayloadStart+publicPayloadOffset+4:], nestedData)
		publicPayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[publicTableStart+0:], 0)
	}

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 0 bytes table
	privatePayloadStart := privateTableStart + 0
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	return buf, nil
}

func (m *Level2) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// Field 1 (Leaf): nested message
	if len(data) >= publicTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Leaf = &Leaf{}
				if err := m.Leaf.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	return nil
}

type Level2Raw []byte

func (m Level2Raw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *Level2Raw) UnmarshalSymphony(data []byte) error {
	*m = Level2Raw(data)
	return nil
}

func (m Level2Raw) GetLeaf() LeafRaw {
	// Field 1 (Leaf): nested message
	if len(m) < 13+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[13:]))
	if payloadOffset == 0 {
		return nil
	}
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return LeafRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m *Level2Raw) SetLeaf(v LeafRaw) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 1 (Leaf): nested message
	if len(*m) < 13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[13:]))
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	var temp Level2
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 0                                    // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.Leaf == nil {
		temp.Leaf = &Leaf{}
	}
	if err := temp.Leaf.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = Level2Raw(fullData[:offsetToPrivate])
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Level1) MarshalSymphonyPublic() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.L1Data)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 2 (L1Data): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.L1Data)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.L1Data)
	payloadOffset += 4 + len(m.L1Data)

	return buf, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Level1) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	if m.L2 != nil {
		nested, _ := m.L2.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (L2): nested message
	if m.L2 != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.L2.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], 0)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Level1) UnmarshalSymphonyPublic(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 2 (L1Data): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.L1Data = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Level1) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (L2): nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.L2 = &Level2{}
				if err := m.L2.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

func (m *Level1) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	size += 4  // table entries
	// Field 2 (L1Data): variable-length payload
	size += 4 + len(m.L1Data) // 4 bytes length prefix + data
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (L2): nested message payload
	if m.L2 != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		nestedSize1 += 4  // table entries
		// Field 1 (Leaf): nested message payload
		if m.L2.Leaf != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			nestedSize2 += 4  // table entries
			// Private segment:
			nestedSize2 += 1 // version byte
			nestedSize2 += 4 // table entries
			// Field 2 (LeafVal): variable-length payload
			nestedSize2 += 4 + len(m.L2.Leaf.LeafVal) // 4 bytes length prefix + data

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}
		// Private segment:
		nestedSize1 += 1 // version byte

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13
	publicSegmentSize += 4                 // offset placeholder
	publicSegmentSize += 4 + len(m.L1Data) // field 2 payload

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 4
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// Field 2 (L1Data): variable-length
	binary.LittleEndian.PutUint32(buf[publicTableStart+0:], uint32(publicPayloadStart+publicPayloadOffset))
	dataLen = len(m.L1Data)
	binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(dataLen))
	copy(buf[publicPayloadStart+publicPayloadOffset+4:], m.L1Data)
	publicPayloadOffset += 4 + len(m.L1Data)

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (L2): nested message
	if m.L2 != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.L2.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], 0)
	}

	return buf, nil
}

func (m *Level1) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// Field 2 (L1Data): variable-length
	if len(data) >= publicTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.L1Data = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (L2): nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.L2 = &Level2{}
				if err := m.L2.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

type Level1Raw []byte

func (m Level1Raw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *Level1Raw) UnmarshalSymphony(data []byte) error {
	*m = Level1Raw(data)
	return nil
}

func (m Level1Raw) GetL2() Level2Raw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (L2): nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return Level2Raw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m Level1Raw) GetL1Data() string {
	// Field 2 (L1Data): variable-length
	if len(m) < 13+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[13:]))
	if payloadOffset == 0 {
		return ""
	}
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *Level1Raw) SetL2(v Level2Raw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (L2): nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Level1
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.L2 == nil {
		temp.L2 = &Level2{}
	}
	if err := temp.L2.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = Level1Raw(newData)
	return nil
}

func (m *Level1Raw) SetL1Data(v string) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 2 (L1Data): variable-length
	if len(*m) < 13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[13:]))
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	// Preserve reserved bytes (serviceID at bytes 5-9, methodID at bytes 9-13) from original buffer
	var originalServiceID, originalMethodID uint32
	if len(*m) >= 13 {
		originalServiceID = binary.LittleEndian.Uint32((*m)[5:9])
		originalMethodID = binary.LittleEndian.Uint32((*m)[9:13])
	}
	var temp Level1
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 4                                    // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.L1Data = v
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	// Restore reserved bytes (serviceID and methodID) in the marshaled payload
	if len(fullData) >= 13 {
		binary.LittleEndian.PutUint32(fullData[5:9], originalServiceID)
		binary.LittleEndian.PutUint32(fullData[9:13], originalMethodID)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = Level1Raw(fullData[:offsetToPrivate])
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Root) MarshalSymphonyPublic() ([]byte, error) {
	size := 0
	size += 4 // table
	if m.L1 != nil {
		nested, _ := m.L1.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (L1): nested message
	if m.L1 != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.L1.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], 0)
	}

	return buf, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Root) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 2 (RootId): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(m.RootId))

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Root) UnmarshalSymphonyPublic(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (L1): nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.L1 = &Level1{}
				if err := m.L1.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Root) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 2 (RootId): fixed-length (4 bytes)
	if len(data) < tableStart+4 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.RootId = int32(binary.LittleEndian.Uint32(data[tableStart+0:]))

	return nil
}

func (m *Root) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	size += 4  // table entries
	// Field 1 (L1): nested message payload
	if m.L1 != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		nestedSize1 += 4  // table entries
		// Field 2 (L1Data): variable-length payload
		nestedSize1 += 4 + len(m.L1.L1Data) // 4 bytes length prefix + data
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 4 // table entries
		// Field 1 (L2): nested message payload
		if m.L1.L2 != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			nestedSize2 += 4  // table entries
			// Field 1 (Leaf): nested message payload
			if m.L1.L2.Leaf != nil {
				nestedSize3 := 0
				// Public segment:
				nestedSize3 += 1  // version byte
				nestedSize3 += 12 // reserved: offset_to_private, service_name, method_name
				nestedSize3 += 4  // table entries
				// Private segment:
				nestedSize3 += 1 // version byte
				nestedSize3 += 4 // table entries
				// Field 2 (LeafVal): variable-length payload
				nestedSize3 += 4 + len(m.L1.L2.Leaf.LeafVal) // 4 bytes length prefix + data

				nestedSize2 += 4 + nestedSize3 // 4 bytes size + message data
			}
			// Private segment:
			nestedSize2 += 1 // version byte

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13
	publicSegmentSize += 4 // offset placeholder
	if m.L1 != nil {
		nestedData1, _ := m.L1.MarshalSymphony()
		publicSegmentSize += 4 + len(nestedData1) // field 1 payload
	}

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 4
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// Field 1 (L1): nested message
	if m.L1 != nil {
		binary.LittleEndian.PutUint32(buf[publicTableStart+0:], uint32(publicPayloadStart+publicPayloadOffset))
		nestedData, err := m.L1.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(nestedSize))
		copy(buf[publicPayloadStart+publicPayloadOffset+4:], nestedData)
		publicPayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[publicTableStart+0:], 0)
	}

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 2 (RootId): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32(m.RootId))

	return buf, nil
}

func (m *Root) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// Field 1 (L1): nested message
	if len(data) >= publicTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.L1 = &Level1{}
				if err := m.L1.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 2 (RootId): fixed-length (4 bytes)
	if len(data) < privateTableStart+4 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.RootId = int32(binary.LittleEndian.Uint32(data[privateTableStart+0:]))

	return nil
}

type RootRaw []byte

func (m RootRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *RootRaw) UnmarshalSymphony(data []byte) error {
	*m = RootRaw(data)
	return nil
}

func (m RootRaw) GetL1() Level1Raw {
	// Field 1 (L1): nested message
	if len(m) < 13+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[13:]))
	if payloadOffset == 0 {
		return nil
	}
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return Level1Raw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m RootRaw) GetRootId() int32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (RootId): fixed-length (4 bytes)
	if len(m) < offsetToPrivate+1+4 {
		return 0
	}
	return int32(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
}

func (m *RootRaw) SetL1(v Level1Raw) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 1 (L1): nested message
	if len(*m) < 13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[13:]))
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	var temp Root
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 4                                    // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.L1 == nil {
		temp.L1 = &Level1{}
	}
	if err := temp.L1.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = RootRaw(fullData[:offsetToPrivate])
	return nil
}

func (m *RootRaw) SetRootId(v int32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (RootId): fixed-length (4 bytes)
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[offsetToPrivate+1:], uint32(v))
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *ComplexMixed) MarshalSymphonyPublic() ([]byte, error) {
	size := 0
	size += 13 // table
	size += 4 + len(m.VString)
	if m.NestedLeaf != nil {
		nested, _ := m.NestedLeaf.MarshalSymphony()
		size += 4 + len(nested)
	}
	size += 4 + len(m.VBytes)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 13
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 2 (VString): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.VString)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.VString)
	payloadOffset += 4 + len(m.VString)

	// Field 4 (NestedLeaf): nested message
	if m.NestedLeaf != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.NestedLeaf.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+4:], 0)
	}

	// Field 6 (FBool): fixed-length (1 bytes)
	if m.FBool {
		buf[tableStart+8] = 1
	} else {
		buf[tableStart+8] = 0
	}

	// Field 8 (VBytes): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+9:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.VBytes)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.VBytes)
	payloadOffset += 4 + len(m.VBytes)

	return buf, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *ComplexMixed) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 16 // table
	size += 4 + 8*len(m.RInt64)
	size += 4 // count for RString
	for _, item := range m.RString {
		size += 4 + len(item)
	}
	size += 4 // count for RepeatedNested
	for _, item := range m.RepeatedNested {
		nested, _ := item.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 16
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (FInt32): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(m.FInt32))

	// Field 3 (RInt64): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	count = len(m.RInt64)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	for i, v := range m.RInt64 {
		binary.LittleEndian.PutUint64(buf[payloadStart+payloadOffset+4+8*i:], uint64(v))
	}
	payloadOffset += 4 + 8*len(m.RInt64)

	// Field 5 (RString): repeated variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+8:], uint32(payloadStart+payloadOffset))
	count = len(m.RString)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	currentOffset = payloadStart + payloadOffset + 4
	for _, item := range m.RString {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	payloadOffset += 4 // count
	for _, item := range m.RString {
		payloadOffset += 4 + len(item)
	}

	// Field 7 (RepeatedNested): repeated nested message
	binary.LittleEndian.PutUint32(buf[tableStart+12:], uint32(payloadStart+payloadOffset))
	count = len(m.RepeatedNested)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	payloadOffset += 4
	currentOffset = payloadStart + payloadOffset
	for _, item := range m.RepeatedNested {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		payloadOffset += 4 + nestedSize
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *ComplexMixed) UnmarshalSymphonyPublic(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 2 (VString): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.VString = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 4 (NestedLeaf): nested message
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.NestedLeaf = &Leaf{}
				if err := m.NestedLeaf.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 6 (FBool): fixed-length (1 bytes)
	if len(data) < tableStart+9 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FBool = data[tableStart+8] != 0

	// Field 8 (VBytes): variable-length
	if len(data) >= tableStart+9+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+9:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.VBytes = make([]byte, dataLen)
				copy(m.VBytes, data[payloadOffset+4:payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *ComplexMixed) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (FInt32): fixed-length (4 bytes)
	if len(data) < tableStart+4 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FInt32 = int32(binary.LittleEndian.Uint32(data[tableStart+0:]))

	// Field 3 (RInt64): repeated fixed-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*8 {
				m.RInt64 = make([]int64, count)
				for i := 0; i < count; i++ {
					m.RInt64[i] = int64(binary.LittleEndian.Uint64(data[payloadOffset+4+8*i:]))
				}
			}
		}
	}

	// Field 5 (RString): repeated variable-length
	if len(data) >= tableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+8:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.RString = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.RString = append(m.RString, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	// Field 7 (RepeatedNested): repeated nested message
	if len(data) >= tableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+12:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.RepeatedNested = make([]*Root, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &Root{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.RepeatedNested = append(m.RepeatedNested, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *ComplexMixed) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	size += 13 // table entries
	// Field 2 (VString): variable-length payload
	size += 4 + len(m.VString) // 4 bytes length prefix + data
	// Field 4 (NestedLeaf): nested message payload
	if m.NestedLeaf != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		nestedSize1 += 4  // table entries
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 4 // table entries
		// Field 2 (LeafVal): variable-length payload
		nestedSize1 += 4 + len(m.NestedLeaf.LeafVal) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Field 8 (VBytes): variable-length payload
	size += 4 + len(m.VBytes) // 4 bytes length prefix + data
	// Private segment:
	size += 1  // version byte
	size += 16 // table entries
	// Field 3 (RInt64): repeated fixed-length payload
	size += 4 + 8*len(m.RInt64) // 4 bytes count + data
	// Field 5 (RString): repeated variable-length payload
	size += 4 // count
	for _, item := range m.RString {
		size += 4 + len(item) // 4 bytes length prefix + data
	}
	// Field 7 (RepeatedNested): repeated nested message payload
	size += 4 // count
	for _, item := range m.RepeatedNested {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		nestedSize1 += 4  // table entries
		// Field 1 (L1): nested message payload
		if item.L1 != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			nestedSize2 += 4  // table entries
			// Field 2 (L1Data): variable-length payload
			nestedSize2 += 4 + len(item.L1.L1Data) // 4 bytes length prefix + data
			// Private segment:
			nestedSize2 += 1 // version byte
			nestedSize2 += 4 // table entries
			// Field 1 (L2): nested message payload
			if item.L1.L2 != nil {
				nestedSize3 := 0
				// Public segment:
				nestedSize3 += 1  // version byte
				nestedSize3 += 12 // reserved: offset_to_private, service_name, method_name
				nestedSize3 += 4  // table entries
				// Field 1 (Leaf): nested message payload
				if item.L1.L2.Leaf != nil {
					nestedSize4 := 0
					// Public segment:
					nestedSize4 += 1  // version byte
					nestedSize4 += 12 // reserved: offset_to_private, service_name, method_name
					nestedSize4 += 4  // table entries
					// Private segment:
					nestedSize4 += 1 // version byte
					nestedSize4 += 4 // table entries
					// Field 2 (LeafVal): variable-length payload
					nestedSize4 += 4 + len(item.L1.L2.Leaf.LeafVal) // 4 bytes length prefix + data

					nestedSize3 += 4 + nestedSize4 // 4 bytes size + message data
				}
				// Private segment:
				nestedSize3 += 1 // version byte

				nestedSize2 += 4 + nestedSize3 // 4 bytes size + message data
			}

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 4 // table entries

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13
	publicSegmentSize += 4                  // offset placeholder
	publicSegmentSize += 4                  // offset placeholder
	publicSegmentSize += 1                  // field FBool
	publicSegmentSize += 4                  // offset placeholder
	publicSegmentSize += 4 + len(m.VString) // field 2 payload
	if m.NestedLeaf != nil {
		nestedData4, _ := m.NestedLeaf.MarshalSymphony()
		publicSegmentSize += 4 + len(nestedData4) // field 4 payload
	}
	publicSegmentSize += 4 + len(m.VBytes) // field 8 payload

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 13
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// Field 2 (VString): variable-length
	binary.LittleEndian.PutUint32(buf[publicTableStart+0:], uint32(publicPayloadStart+publicPayloadOffset))
	dataLen = len(m.VString)
	binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(dataLen))
	copy(buf[publicPayloadStart+publicPayloadOffset+4:], m.VString)
	publicPayloadOffset += 4 + len(m.VString)

	// Field 4 (NestedLeaf): nested message
	if m.NestedLeaf != nil {
		binary.LittleEndian.PutUint32(buf[publicTableStart+4:], uint32(publicPayloadStart+publicPayloadOffset))
		nestedData, err := m.NestedLeaf.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(nestedSize))
		copy(buf[publicPayloadStart+publicPayloadOffset+4:], nestedData)
		publicPayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[publicTableStart+4:], 0)
	}

	// Field 6 (FBool): fixed-length (1 bytes)
	if m.FBool {
		buf[publicTableStart+8] = 1
	} else {
		buf[publicTableStart+8] = 0
	}

	// Field 8 (VBytes): variable-length
	binary.LittleEndian.PutUint32(buf[publicTableStart+9:], uint32(publicPayloadStart+publicPayloadOffset))
	dataLen = len(m.VBytes)
	binary.LittleEndian.PutUint32(buf[publicPayloadStart+publicPayloadOffset:], uint32(dataLen))
	copy(buf[publicPayloadStart+publicPayloadOffset+4:], m.VBytes)
	publicPayloadOffset += 4 + len(m.VBytes)

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 16 bytes table
	privatePayloadStart := privateTableStart + 16
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (FInt32): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32(m.FInt32))

	// Field 3 (RInt64): repeated fixed-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.RInt64)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	for i, v := range m.RInt64 {
		binary.LittleEndian.PutUint64(buf[privatePayloadStart+privatePayloadOffset+4+8*i:], uint64(v))
	}
	privatePayloadOffset += 4 + 8*len(m.RInt64)

	// Field 5 (RString): repeated variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+8:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.RString)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	currentOffset = privatePayloadStart + privatePayloadOffset + 4
	for _, item := range m.RString {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	privatePayloadOffset += 4 // count
	for _, item := range m.RString {
		privatePayloadOffset += 4 + len(item)
	}

	// Field 7 (RepeatedNested): repeated nested message
	binary.LittleEndian.PutUint32(buf[privateTableStart+12:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.RepeatedNested)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	privatePayloadOffset += 4
	currentOffset = privatePayloadStart + privatePayloadOffset
	for _, item := range m.RepeatedNested {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		privatePayloadOffset += 4 + nestedSize
	}

	return buf, nil
}

func (m *ComplexMixed) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// Field 2 (VString): variable-length
	if len(data) >= publicTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.VString = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 4 (NestedLeaf): nested message
	if len(data) >= publicTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.NestedLeaf = &Leaf{}
				if err := m.NestedLeaf.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 6 (FBool): fixed-length (1 bytes)
	if len(data) < publicTableStart+9 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FBool = data[publicTableStart+8] != 0

	// Field 8 (VBytes): variable-length
	if len(data) >= publicTableStart+9+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[publicTableStart+9:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.VBytes = make([]byte, dataLen)
				copy(m.VBytes, data[payloadOffset+4:payloadOffset+4+dataLen])
			}
		}
	}

	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (FInt32): fixed-length (4 bytes)
	if len(data) < privateTableStart+4 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.FInt32 = int32(binary.LittleEndian.Uint32(data[privateTableStart+0:]))

	// Field 3 (RInt64): repeated fixed-length
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+count*8 {
				m.RInt64 = make([]int64, count)
				for i := 0; i < count; i++ {
					m.RInt64[i] = int64(binary.LittleEndian.Uint64(data[payloadOffset+4+8*i:]))
				}
			}
		}
	}

	// Field 5 (RString): repeated variable-length
	if len(data) >= privateTableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+8:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.RString = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.RString = append(m.RString, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	// Field 7 (RepeatedNested): repeated nested message
	if len(data) >= privateTableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+12:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.RepeatedNested = make([]*Root, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &Root{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.RepeatedNested = append(m.RepeatedNested, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type ComplexMixedRaw []byte

func (m ComplexMixedRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *ComplexMixedRaw) UnmarshalSymphony(data []byte) error {
	*m = ComplexMixedRaw(data)
	return nil
}

func (m ComplexMixedRaw) GetFInt32() int32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (FInt32): fixed-length (4 bytes)
	if len(m) < offsetToPrivate+1+4 {
		return 0
	}
	return int32(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
}

func (m ComplexMixedRaw) GetVString() string {
	// Field 2 (VString): variable-length
	if len(m) < 13+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[13:]))
	if payloadOffset == 0 {
		return ""
	}
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m ComplexMixedRaw) GetRInt64() []int64 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 3 (RInt64): repeated fixed-length
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+8*count {
		return nil
	}
	result := make([]int64, count)
	for i := 0; i < count; i++ {
		result[i] = int64(binary.LittleEndian.Uint64(m[payloadOffset+4+8*i:]))
	}
	return result
}

func (m ComplexMixedRaw) GetNestedLeaf() LeafRaw {
	// Field 4 (NestedLeaf): nested message
	if len(m) < 17+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[17:]))
	if payloadOffset == 0 {
		return nil
	}
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return LeafRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m ComplexMixedRaw) GetRString() []string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 5 (RString): repeated variable-length
	if len(m) < offsetToPrivate+9+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+9:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]string, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		itemLen := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+itemLen {
			return nil
		}
		result[i] = string(m[currentOffset+4 : currentOffset+4+itemLen])
		currentOffset += 4 + itemLen
	}
	return result
}

func (m ComplexMixedRaw) GetFBool() bool {
	// Field 6 (FBool): fixed-length (1 bytes)
	if len(m) < 21+1 {
		return false
	}
	return m[21] != 0
}

func (m ComplexMixedRaw) GetRepeatedNested() []RootRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 7 (RepeatedNested): repeated nested message
	if len(m) < offsetToPrivate+13+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+13:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]RootRaw, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		nestedSize := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+nestedSize {
			return nil
		}
		result[i] = RootRaw(m[currentOffset+4 : currentOffset+4+nestedSize])
		currentOffset += 4 + nestedSize
	}
	return result
}

func (m ComplexMixedRaw) GetVBytes() []byte {
	// Field 8 (VBytes): variable-length
	if len(m) < 22+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[22:]))
	if payloadOffset == 0 {
		return nil
	}
	if len(m) < payloadOffset+4 {
		return nil
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return nil
	}
	result := make([]byte, dataLen)
	copy(result, m[payloadOffset+4:payloadOffset+4+dataLen])
	return result
}

func (m *ComplexMixedRaw) SetFInt32(v int32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (FInt32): fixed-length (4 bytes)
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[offsetToPrivate+1:], uint32(v))
	return nil
}

func (m *ComplexMixedRaw) SetVString(v string) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 2 (VString): variable-length
	if len(*m) < 13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[13:]))
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	// Preserve reserved bytes (serviceID at bytes 5-9, methodID at bytes 9-13) from original buffer
	var originalServiceID, originalMethodID uint32
	if len(*m) >= 13 {
		originalServiceID = binary.LittleEndian.Uint32((*m)[5:9])
		originalMethodID = binary.LittleEndian.Uint32((*m)[9:13])
	}
	var temp ComplexMixed
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 16                                   // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.VString = v
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	// Restore reserved bytes (serviceID and methodID) in the marshaled payload
	if len(fullData) >= 13 {
		binary.LittleEndian.PutUint32(fullData[5:9], originalServiceID)
		binary.LittleEndian.PutUint32(fullData[9:13], originalMethodID)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = ComplexMixedRaw(fullData[:offsetToPrivate])
	return nil
}

func (m *ComplexMixedRaw) SetRInt64(v []int64) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 3 (RInt64): repeated fixed-length
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		oldDataSize = 4 + 8*oldCount // 4 bytes count + data
	}
	newCount := len(v)
	newDataSize := 4 + 8*newCount // 4 bytes count + data
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		for i, val := range v {
			binary.LittleEndian.PutUint64((*m)[oldPayloadOffset+4+8*i:], uint64(val))
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ComplexMixed
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RInt64 = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ComplexMixedRaw(newData)
	return nil
}

func (m *ComplexMixedRaw) SetNestedLeaf(v LeafRaw) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 4 (NestedLeaf): nested message
	if len(*m) < 17+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[17:]))
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	var temp ComplexMixed
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 16                                   // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.NestedLeaf == nil {
		temp.NestedLeaf = &Leaf{}
	}
	if err := temp.NestedLeaf.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = ComplexMixedRaw(fullData[:offsetToPrivate])
	return nil
}

func (m *ComplexMixedRaw) SetRString(v []string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 5 (RString): repeated variable-length
	if len(*m) < offsetToPrivate+9+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+9:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes length + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemLen := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemLen
			currentOffset += 4 + itemLen
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes length + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemLen := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemLen))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemLen
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ComplexMixed
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RString = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ComplexMixedRaw(newData)
	return nil
}

func (m *ComplexMixedRaw) SetFBool(v bool) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 6 (FBool): fixed-length (1 bytes)
	if len(*m) < 21+1 {
		return fmt.Errorf("buffer too short")
	}
	if v {
		(*m)[21] = 1
	} else {
		(*m)[21] = 0
	}
	return nil
}

func (m *ComplexMixedRaw) SetRepeatedNested(v []RootRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 7 (RepeatedNested): repeated nested message
	if len(*m) < offsetToPrivate+13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+13:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes size + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemSize := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemSize
			currentOffset += 4 + itemSize
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes size + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemSize := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemSize))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemSize
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ComplexMixed
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RepeatedNested = make([]*Root, len(v))
	for i, rawItem := range v {
		temp.RepeatedNested[i] = &Root{}
		if err := temp.RepeatedNested[i].UnmarshalSymphony([]byte(rawItem)); err != nil {
			return fmt.Errorf("failed to unmarshal nested message: %w", err)
		}
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ComplexMixedRaw(newData)
	return nil
}

func (m *ComplexMixedRaw) SetVBytes(v []byte) error {
	// ASSERT: Public field setter requires public-only buffer
	if len(*m) >= 5 {
		offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
		if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {
			panic("public setter called on complete buffer")
		}
	}
	// Field 8 (VBytes): variable-length
	if len(*m) < 22+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[22:]))
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal, truncate to public-only
	// Preserve reserved bytes (serviceID at bytes 5-9, methodID at bytes 9-13) from original buffer
	var originalServiceID, originalMethodID uint32
	if len(*m) >= 13 {
		originalServiceID = binary.LittleEndian.Uint32((*m)[5:9])
		originalMethodID = binary.LittleEndian.Uint32((*m)[9:13])
	}
	var temp ComplexMixed
	// Create a fake complete buffer by appending a minimal private segment
	// Calculate private table size
	privateTableSize := 16                                   // bytes needed for empty private table
	fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table
	copy(fakeComplete, *m)
	// Update offsetToPrivate to point to the appended private segment
	binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))
	fakeComplete[len(*m)] = 0x01 // private segment version
	if err := temp.UnmarshalSymphony(fakeComplete); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.VBytes = v
	fullData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	// Restore reserved bytes (serviceID and methodID) in the marshaled payload
	if len(fullData) >= 13 {
		binary.LittleEndian.PutUint32(fullData[5:9], originalServiceID)
		binary.LittleEndian.PutUint32(fullData[9:13], originalMethodID)
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))
	*m = ComplexMixedRaw(fullData[:offsetToPrivate])
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Empty) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Empty) MarshalSymphonyPrivate() ([]byte, error) {
	return []byte{}, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Empty) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Empty) UnmarshalSymphonyPrivate(data []byte) error {
	return nil
}

func (m *Empty) MarshalSymphony() ([]byte, error) {
	// Empty message - public segment with header only, empty private segment
	buf := make([]byte, 14)                     // 1 version + 12 reserved + 1 version for private
	buf[0] = 0x01                               // public version
	binary.LittleEndian.PutUint32(buf[1:5], 13) // offset_to_private
	// service_name and method_name stay 0
	buf[13] = 0x01 // private version
	return buf, nil
}

func (m *Empty) UnmarshalSymphony(data []byte) error {
	// Empty message - just validate version bytes
	if len(data) < 14 {
		return fmt.Errorf("invalid data: too short")
	}
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}
	return nil
}

type EmptyRaw []byte

func (m EmptyRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *EmptyRaw) UnmarshalSymphony(data []byte) error {
	*m = EmptyRaw(data)
	return nil
}
