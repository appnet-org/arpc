// protoc-gen-symphony is a protoc plugin to generate Symphony serialization
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			gen := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+".syn.go", file.GoImportPath)
			gen.P("// Code generated by protoc-gen-symphony. DO NOT EDIT.")
			gen.P("package ", file.GoPackageName)
			gen.P()
			gen.P("import (\n\t\"encoding/binary\"\n\t\"fmt\"\n)")

			for _, message := range file.Messages {
				generateMarshal(gen, message)
				generateUnmarshalStub(gen, message)
			}
		}
		return nil
	})
}

func generateMarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	// Get the canonical field order. For now, it returns the numbers in their original definition order.
	fieldOrder, strOrder := fieldOrdering(msg)

	// Create a map of fields by their number for easy lookup during code generation.
	fieldsMap := make(map[byte]*protogen.Field)
	for _, field := range msg.Fields {
		fieldsMap[byte(field.Desc.Number())] = field
	}

	g.P("func (m *", msg.GoIdent.GoName, ") MarshalSymphony() ([]byte, error) {")

	// Handle empty messages specially
	if len(msg.Fields) == 0 {
		g.P("    // Empty message - just return header")
		g.P("    return []byte{0x00}, nil")
		g.P("}")
		g.P()
		return
	}

	g.P("    // Pre-allocate buffer with estimated size")
	estimatedSize := estimateBufferSize(msg)
	g.P(fmt.Sprintf("    buf := make([]byte, 0, %d)", estimatedSize))
	g.P("    var temp [8]byte // Reusable temp buffer for encoding")
	g.P()

	// === HEADER SECTION ===
	g.P("    // === HEADER SECTION ===")
	g.P("    buf = append(buf, 0x00) // layout header")
	g.P("    buf = append(buf, []byte{", strOrder, "}...)")
	g.P()

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===
	hasSingularNested, hasRepeatedNested := hasNestedMessages(msg)

	if hasSingularNested || hasRepeatedNested {
		g.P("    // === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===")
		g.P()
		g.P("    var err error")
	}

	if hasSingularNested {
		g.P("    cachedSingularMessages := make(map[byte][]byte)")
		for _, field := range msg.Fields {
			if field.Desc.Kind() == protoreflect.MessageKind && !field.Desc.IsList() {
				fieldNum := byte(field.Desc.Number())
				g.P(fmt.Sprintf("	// Cache field %d (%s): singular message", fieldNum, field.GoName))
				g.P(fmt.Sprintf("    if m.%s != nil {", field.GoName))
				g.P(fmt.Sprintf("        cachedSingularMessages[%d], err = m.%s.MarshalSymphony()", fieldNum, field.GoName))
				g.P(fmt.Sprintf("        if err != nil { return nil, fmt.Errorf(\"failed to marshal singular message field %s: %%w\", err) }", field.GoName))
				g.P("    }")
				g.P()
			}
		}
	}
	if hasRepeatedNested {
		g.P("    cachedRepeatedMessages := make(map[byte][][]byte)")
		for _, field := range msg.Fields {
			if field.Desc.Kind() == protoreflect.MessageKind && field.Desc.IsList() {
				fieldNum := byte(field.Desc.Number())
				g.P(fmt.Sprintf("	// Cache field %d (%s): repeated message", fieldNum, field.GoName))
				g.P(fmt.Sprintf("    cachedRepeatedMessages[%d] = make([][]byte, len(m.%s))", fieldNum, field.GoName))
				g.P(fmt.Sprintf("    for i, item := range m.%s {", field.GoName))
				g.P(fmt.Sprintf("        if item != nil { cachedRepeatedMessages[%d][i], err = item.MarshalSymphony() }", fieldNum))
				g.P(fmt.Sprintf("        if err != nil { return nil, fmt.Errorf(\"failed to marshal repeated message field %s[%%d]: %%w\", i, err) }", field.GoName))
				g.P("    }")
				g.P()
			}
		}
	}

	// === OFFSET TABLE SECTION ===
	g.P("    // === OFFSET TABLE SECTION ===")
	g.P("    offset := 0")
	for _, fieldNum := range fieldOrder {
		g.P()
		field := fieldsMap[fieldNum]
		goName := field.GoName
		if isVariableLength(field) {
			if field.Desc.Kind() == protoreflect.MessageKind {
				g.P(fmt.Sprintf("    // Field %d (%s): nested message", fieldNum, goName))
				g.P(fmt.Sprintf("    buf = append(buf, byte(%d))", fieldNum))
				g.P("    binary.LittleEndian.PutUint16(temp[:2], uint16(offset))")
				g.P("    buf = append(buf, temp[:2]...)")
				if field.Desc.IsList() {
					g.P("    totalLen := 0")
					g.P(fmt.Sprintf("    for _, item := range cachedRepeatedMessages[%d] {", fieldNum))
					g.P("        totalLen += 4 + len(item) // 4 bytes for length + message data")
					g.P("    }")
					g.P("    binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))")
					g.P("    buf = append(buf, temp[:2]...)")
					g.P("    offset += totalLen")
				} else {
					g.P(fmt.Sprintf("    binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[%d])))", fieldNum))
					g.P("    buf = append(buf, temp[:2]...)")
					g.P(fmt.Sprintf("    offset += len(cachedSingularMessages[%d])", fieldNum))
				}
			} else if field.Desc.IsList() {
				// Handle repeated variable-length fields (strings, bytes)
				g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length", fieldNum, goName))
				g.P(fmt.Sprintf("    buf = append(buf, byte(%d))", fieldNum))
				g.P(fmt.Sprintf("    binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of %s", goName))
				g.P("    buf = append(buf, temp[:2]...)")
				// Calculate total length of repeated field
				g.P("    totalLen := 0")
				g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
				g.P("        totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data")
				g.P("    }")
				g.P("    binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))")
				g.P("    buf = append(buf, temp[:2]...)")
				g.P("    offset += totalLen")
			} else {
				// Handle single variable-length fields (strings, bytes)
				g.P(fmt.Sprintf("    // Field %d (%s): string or bytes", fieldNum, goName))
				g.P(fmt.Sprintf("    buf = append(buf, byte(%d))", fieldNum))
				g.P(fmt.Sprintf("    binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of %s", goName))
				g.P("    buf = append(buf, temp[:2]...)")
				g.P(fmt.Sprintf("    binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.%s)))", goName))
				g.P("    buf = append(buf, temp[:2]...)")
				g.P(fmt.Sprintf("    offset += len(m.%s)", goName))
			}
		} else if isRepeatedFixedSize(field) {
			// Handle repeated fixed-size fields (ints, bools, etc.)
			g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-size (%d bytes per element)", fieldNum, goName, getFieldSize(field)))
			g.P(fmt.Sprintf("    buf = append(buf, byte(%d))", fieldNum))
			g.P(fmt.Sprintf("    binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of %s", goName))
			g.P("    buf = append(buf, temp[:2]...)")
			// Note: we store the count of elements for repeated fixed-length fields, not the byte length.
			g.P(fmt.Sprintf("    binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.%s))) // count of %s", goName, goName))
			g.P("    buf = append(buf, temp[:2]...)")
			g.P(fmt.Sprintf("    offset += %d * len(m.%s)", getFieldSize(field), goName))
		} else {
			// Write single fixed-size field data
			g.P(fmt.Sprintf("    offset += %d // %s", getFieldSize(field), field.GoName))
		}
	}
	g.P()

	// === DATA REGION SECTION ===
	g.P("    // === DATA REGION SECTION ===")
	for _, fieldNum := range fieldOrder {
		g.P()
		field := fieldsMap[fieldNum]
		goName := field.GoName
		if isVariableLength(field) {
			if field.Desc.Kind() == protoreflect.MessageKind {
				g.P(fmt.Sprintf("    // Write nested message field (%s)", goName))
				if field.Desc.IsList() {
					g.P(fmt.Sprintf("    for _, item := range cachedRepeatedMessages[%d] {", fieldNum))
					g.P("        binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))")
					g.P("        buf = append(buf, temp[:4]...)")
					g.P("        buf = append(buf, item...)")
					g.P("    }")
				} else {
					g.P(fmt.Sprintf("    buf = append(buf, cachedSingularMessages[%d]...)", fieldNum))
				}
			} else if field.Desc.IsList() {
				// Write repeated variable-length field data
				// TODO: we should have a second layer of offset table for the repeated field for easier access
				g.P(fmt.Sprintf("    // Write repeated variable-length field (%s)", goName))
				g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
				g.P("        binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))")
				g.P("        buf = append(buf, temp[:4]...)")
				g.P("        buf = append(buf, []byte(item)...)")
				g.P("    }")
			} else {
				// Write single variable-length field data
				g.P(fmt.Sprintf("    // Write string or bytes field (%s)", goName))
				g.P(fmt.Sprintf("    buf = append(buf, []byte(m.%s)...)", goName))
			}
		} else if isRepeatedFixedSize(field) {
			// Write repeated fixed-size field data
			g.P(fmt.Sprintf("    // Write repeated fixed-size field (%s)", goName))
			g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
			generateFixedFieldWrite(g, "item", field)
			g.P("    }")
		} else {
			// Write single fixed-size field data
			g.P(fmt.Sprintf("    // Write fixed field (%s)", goName))
			generateFixedFieldWrite(g, fmt.Sprintf("m.%s", goName), field)
		}
	}
	g.P()

	g.P("    return buf, nil")
	g.P("}")
	g.P()
}

// generateDirectFieldRead generates efficient code for reading fixed-size fields directly from byte slice
func generateDirectFieldRead(g *protogen.GeneratedFile, fieldExpr string, field *protogen.Field, dataVar string, offsetVar string) {
	size := getFieldSize(field)
	kind := field.Desc.Kind()

	switch size {
	case 1:
		// Handle bool specially
		if kind == protoreflect.BoolKind {
			g.P(fmt.Sprintf("                    %s = %s[%s] != 0", fieldExpr, dataVar, offsetVar))
		} else {
			g.P(fmt.Sprintf("                    %s = %s(%s[%s])", fieldExpr, getGoType(g, field), dataVar, offsetVar))
		}
	case 4:
		switch kind {
		case protoreflect.Int32Kind:
			g.P(fmt.Sprintf("                    %s = int32(binary.LittleEndian.Uint32(%s[%s:%s+4]))", fieldExpr, dataVar, offsetVar, offsetVar))
		case protoreflect.Uint32Kind:
			g.P(fmt.Sprintf("                    %s = binary.LittleEndian.Uint32(%s[%s:%s+4])", fieldExpr, dataVar, offsetVar, offsetVar))
		case protoreflect.FloatKind:
			g.P(fmt.Sprintf("                    %s = math.Float32frombits(binary.LittleEndian.Uint32(%s[%s:%s+4]))", fieldExpr, dataVar, offsetVar, offsetVar))
		case protoreflect.EnumKind:
			g.P(fmt.Sprintf("                    %s = %s(binary.LittleEndian.Uint32(%s[%s:%s+4]))", fieldExpr, getGoType(g, field), dataVar, offsetVar, offsetVar))
		default:
			panic(fmt.Sprintf("Unhandled 4-byte field type: %v", kind))
		}
	case 8:
		switch kind {
		case protoreflect.Int64Kind:
			g.P(fmt.Sprintf("                    %s = int64(binary.LittleEndian.Uint64(%s[%s:%s+8]))", fieldExpr, dataVar, offsetVar, offsetVar))
		case protoreflect.Uint64Kind:
			g.P(fmt.Sprintf("                    %s = binary.LittleEndian.Uint64(%s[%s:%s+8])", fieldExpr, dataVar, offsetVar, offsetVar))
		case protoreflect.DoubleKind:
			g.P(fmt.Sprintf("                    %s = math.Float64frombits(binary.LittleEndian.Uint64(%s[%s:%s+8]))", fieldExpr, dataVar, offsetVar, offsetVar))
		default:
			panic(fmt.Sprintf("Unhandled 8-byte field type: %v", kind))
		}
	default:
		panic(fmt.Sprintf("Unhandled field size %d for type %v", size, kind))
	}
}

// generateFixedFieldWrite generates efficient code for writing fixed-size fields
func generateFixedFieldWrite(g *protogen.GeneratedFile, fieldExpr string, field *protogen.Field) {
	size := getFieldSize(field)
	kind := field.Desc.Kind()

	switch size {
	case 1:
		// Handle bool specially
		if kind == protoreflect.BoolKind {
			g.P(fmt.Sprintf("        if %s {", fieldExpr))
			g.P("            buf = append(buf, 1)")
			g.P("        } else {")
			g.P("            buf = append(buf, 0)")
			g.P("        }")
		} else {
			g.P(fmt.Sprintf("        buf = append(buf, byte(%s))", fieldExpr))
		}
	case 4:
		switch kind {
		case protoreflect.Int32Kind:
			g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(temp[:4], uint32(%s))", fieldExpr))
		case protoreflect.Uint32Kind:
			g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(temp[:4], %s)", fieldExpr))
		case protoreflect.FloatKind:
			g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(temp[:4], math.Float32bits(%s))", fieldExpr))
		case protoreflect.EnumKind:
			g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(temp[:4], uint32(%s))", fieldExpr))
		default:
			panic(fmt.Sprintf("Unhandled 4-byte field type: %v", kind))
		}
		g.P("        buf = append(buf, temp[:4]...)")
	case 8:
		switch kind {
		case protoreflect.Int64Kind:
			g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(temp[:8], uint64(%s))", fieldExpr))
		case protoreflect.Uint64Kind:
			g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(temp[:8], %s)", fieldExpr))
		case protoreflect.DoubleKind:
			g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(temp[:8], math.Float64bits(%s))", fieldExpr))
		default:
			panic(fmt.Sprintf("Unhandled 8-byte field type: %v", kind))
		}
		g.P("        buf = append(buf, temp[:8]...)")
	default:
		panic(fmt.Sprintf("Unhandled field size %d for type %v", size, kind))
	}
}

func generateUnmarshalStub(g *protogen.GeneratedFile, msg *protogen.Message) {
	g.P("func (m *", msg.GoIdent.GoName, ") UnmarshalSymphony(data []byte) error {")

	// Handle empty messages specially
	if len(msg.Fields) == 0 {
		g.P("    // Empty message - just validate header")
		g.P("    if len(data) < 1 || data[0] != 0x00 {")
		g.P("        return fmt.Errorf(\"invalid empty message data\")")
		g.P("    }")
		g.P("    return nil")
		g.P("}")
		g.P()
		return
	}

	// === HEADER PARSING SECTION ===
	g.P("    // === HEADER PARSING SECTION ===")
	g.P("    if len(data) < ", 1+len(msg.Fields), " { return fmt.Errorf(\"data too short for header\") }")
	g.P("    offset := 0")
	g.P("    _ = data[offset] // header byte (currently unused)")
	g.P("    offset++")
	g.P()
	g.P("    fieldOrder := data[offset:offset+", len(msg.Fields), "]")
	g.P("    offset += ", len(msg.Fields))
	g.P()

	// === OFFSET TABLE PARSING SECTION ===
	g.P("    // === OFFSET TABLE PARSING SECTION ===")
	numVarFieldsCount := numVarFields(msg)
	if numVarFieldsCount > 0 {
		g.P("    type offsetEntry struct { offset, length uint16 }")
		g.P("    offsets := map[byte]offsetEntry{}")
		g.P("    offsetTableSize := ", numVarFieldsCount*5) // 5 bytes per entry (1 byte field ID + 2 bytes offset + 2 bytes length)
		g.P("    if len(data) < offset + offsetTableSize { return fmt.Errorf(\"data too short for offset table\") }")
		g.P("    for i := 0; i < ", numVarFieldsCount, "; i++ {")
		g.P("        entryOffset := offset + i*5")
		g.P("        fieldID := data[entryOffset]")
		g.P("        off := binary.LittleEndian.Uint16(data[entryOffset+1:entryOffset+3])")
		g.P("        len := binary.LittleEndian.Uint16(data[entryOffset+3:entryOffset+5])")
		g.P("        offsets[fieldID] = offsetEntry{off, len}")
		g.P("    }")
		g.P("    offset += offsetTableSize")
	}
	g.P()

	// === DATA REGION EXTRACTION SECTION ===
	g.P("    // === DATA REGION EXTRACTION SECTION ===")
	g.P("    dataRegion := data[offset:]")
	g.P("    dataOffset := 0")
	g.P()

	// === FIELD UNMARSHALING SECTION ===
	g.P("    // === FIELD UNMARSHALING SECTION ===")
	g.P("    for _, fieldNum := range fieldOrder {")

	// --- Start of generated switch statement ---
	g.P("        switch fieldNum {")
	for _, field := range msg.Fields {
		goName := field.GoName
		fieldNum := field.Desc.Number()

		g.P(fmt.Sprintf("        case %d: // %s", fieldNum, goName))
		if isVariableLength(field) {
			// --- NESTED MESSAGE LOGIC ---
			if field.Desc.Kind() == protoreflect.MessageKind {
				g.P(fmt.Sprintf("            // Unmarshal nested message field (%s)", goName))
				g.P(fmt.Sprintf("            if entry, ok := offsets[%d]; ok {", fieldNum))
				if field.Desc.IsList() {
					g.P("                fieldData := dataRegion[entry.offset : entry.offset+entry.length]")
					g.P(fmt.Sprintf("                m.%s = make([]%s, 0)", goName, getGoType(g, field)))
					g.P("                fieldOffset := 0")
					g.P("                for fieldOffset < len(fieldData) {")
					g.P("                    if fieldOffset+4 > len(fieldData) { return fmt.Errorf(\"insufficient data for item length\") }")
					g.P("                    itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset:fieldOffset+4])")
					g.P("                    fieldOffset += 4")
					g.P("                    if itemLen == 0 {")
					g.P(fmt.Sprintf("                        m.%s = append(m.%s, nil)", goName, goName))
					g.P("                        continue")
					g.P("                    }")
					g.P("                    if fieldOffset+int(itemLen) > len(fieldData) { return fmt.Errorf(\"insufficient data for item bytes\") }")
					g.P("                    itemBytes := fieldData[fieldOffset:fieldOffset+int(itemLen)]")
					g.P("                    fieldOffset += int(itemLen)")
					g.P(fmt.Sprintf("                    newItem := &%s{}", g.QualifiedGoIdent(field.Message.GoIdent)))
					g.P("                    if err := newItem.UnmarshalSymphony(itemBytes); err != nil { return fmt.Errorf(\"failed to unmarshal nested message: %w\", err) }")
					g.P(fmt.Sprintf("                    m.%s = append(m.%s, newItem)", goName, goName))
					g.P("                }")
				} else {
					g.P("                if entry.length == 0 {")
					g.P(fmt.Sprintf("                    m.%s = nil", goName))
					g.P("                } else {")
					g.P("                    fieldData := dataRegion[entry.offset : entry.offset+entry.length]")
					g.P(fmt.Sprintf("                    if m.%s == nil { m.%s = &%s{} }", goName, goName, g.QualifiedGoIdent(field.Message.GoIdent)))
					g.P(fmt.Sprintf("                    if err := m.%s.UnmarshalSymphony(fieldData); err != nil { return fmt.Errorf(\"failed to unmarshal singular nested message: %%w\", err) }", goName))
					g.P("                }")
				}
				g.P("                dataOffset += int(entry.length)")
				g.P("            }")

			} else if field.Desc.IsList() {
				// --- OTHER VARIABLE-LENGTH LOGIC (string/bytes) ---
				g.P(fmt.Sprintf("            // Unmarshal repeated variable-length field (%s)", goName))
				g.P(fmt.Sprintf("            if entry, ok := offsets[%d]; ok {", fieldNum))

				// The element type will be 'string' or '[]byte'
				elementType := getGoType(g, field)

				g.P(fmt.Sprintf("                m.%s = make([]%s, 0)", goName, elementType))
				g.P("                fieldData := dataRegion[entry.offset : entry.offset+entry.length]")
				g.P("                fieldOffset := 0")
				g.P("                for fieldOffset < len(fieldData) {")
				g.P("                    if fieldOffset+4 > len(fieldData) { return fmt.Errorf(\"insufficient data for item length\") }")
				g.P("                    itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset:fieldOffset+4])")
				g.P("                    fieldOffset += 4")
				g.P("                    if itemLen == 0 {")
				if field.Desc.Kind() == protoreflect.StringKind {
					g.P(fmt.Sprintf("                        m.%s = append(m.%s, \"\")", goName, goName))
				} else { // This handles BytesKind
					g.P(fmt.Sprintf("                        m.%s = append(m.%s, []byte{})", goName, goName))
				}
				g.P("                        continue")
				g.P("                    }")
				g.P("                    if fieldOffset+int(itemLen) > len(fieldData) { return fmt.Errorf(\"insufficient data for item data\") }")
				g.P("                    itemData := fieldData[fieldOffset:fieldOffset+int(itemLen)]")
				g.P("                    fieldOffset += int(itemLen)")

				// Cast the final []byte to the correct type (string or []byte)
				g.P(fmt.Sprintf("                    m.%s = append(m.%s, %s(itemData))", goName, goName, elementType))

				g.P("                }")
				g.P("                dataOffset += int(entry.length)")
				g.P("            }")
			} else {
				// Handle single variable-length fields
				g.P(fmt.Sprintf("            // Unmarshal string or []byte field (%s)", goName))
				g.P(fmt.Sprintf("            if entry, ok := offsets[%d]; ok {", fieldNum))
				g.P(fmt.Sprintf("                m.%s = %s(dataRegion[entry.offset:entry.offset+entry.length])", goName, getGoType(g, field)))
				g.P("                dataOffset += int(entry.length)")
				g.P("            }")
			}
		} else if isRepeatedFixedSize(field) {
			// Handle repeated fixed-size fields
			g.P(fmt.Sprintf("            // Unmarshal repeated fixed-size field (%s)", goName))
			g.P(fmt.Sprintf("            if entry, ok := offsets[%d]; ok {", fieldNum))
			g.P(fmt.Sprintf("                count := int(entry.length) // count of %s", goName))
			g.P(fmt.Sprintf("                m.%s = make([]%s, count)", goName, getGoType(g, field)))
			g.P("                // Read repeated field data")
			g.P("                fieldStart := entry.offset")
			fieldSize := getFieldSize(field)
			g.P(fmt.Sprintf("                if int(fieldStart) + count*%d > len(dataRegion) { return fmt.Errorf(\"insufficient data for repeated field\") }", fieldSize))
			g.P("                for i := 0; i < count; i++ {")
			g.P(fmt.Sprintf("                    elemStart := int(fieldStart) + i*%d", fieldSize))
			generateDirectFieldRead(g, fmt.Sprintf("m.%s[i]", goName), field, "dataRegion", "elemStart")
			g.P("                }")
			g.P(fmt.Sprintf("                dataOffset += count * %d", fieldSize))
			g.P("            }")
		} else {
			// Handle single fixed-size fields
			g.P(fmt.Sprintf("            // Unmarshal fixed field (%s)", goName))
			fieldSize := getFieldSize(field)
			g.P(fmt.Sprintf("            if dataOffset+%d > len(dataRegion) { return fmt.Errorf(\"insufficient data for fixed field\") }", fieldSize))
			generateDirectFieldRead(g, fmt.Sprintf("m.%s", goName), field, "dataRegion", "dataOffset")
			g.P(fmt.Sprintf("            dataOffset += %d", fieldSize))
		}
	}
	g.P("        }") // End switch
	// --- End of generated switch statement ---
	g.P("    }") // End for loop
	g.P()

	g.P("    return nil")
	g.P("}")
	g.P()
}

// fieldOrdering returns a slice of Protobuf field numbers that defines the
// canonical layout for fields in the marshaled byte array.
//
// The order of numbers in the slice dictates the final memory layout. For
// example, a returned slice of [3, 1, 2] means the field with Protobuf number 3
// will be written first, followed by the field with number 1, and then 2.
// This allows for reordering, such as placing all fixed-size fields first.
//
// For now, it returns the numbers in their original definition order.
func fieldOrdering(msg *protogen.Message) ([]byte, string) {
	fieldOrder := make([]byte, 0, len(msg.Fields))
	strOrder := make([]string, len(fieldOrder))
	for _, field := range msg.Fields {
		fieldNum := field.Desc.Number()
		if fieldNum < 0 || fieldNum > 255 {
			panic(fmt.Sprintf("field %d (%s): number out of range (0-255)", fieldNum, field.GoName))
		}
		fieldOrder = append(fieldOrder, byte(fieldNum))
		strOrder = append(strOrder, fmt.Sprintf("%d", fieldNum))
	}
	return fieldOrder, strings.Join(strOrder, ", ")
}

func isVariableLength(field *protogen.Field) bool {
	kind := field.Desc.Kind()
	// A field is variable length if it's a string, bytes, or a nested message.
	return kind == protoreflect.StringKind || kind == protoreflect.BytesKind || kind == protoreflect.MessageKind
}

// Add a new helper function to check if a repeated field is fixed-size
func isRepeatedFixedSize(field *protogen.Field) bool {
	return field.Desc.IsList() && !isVariableLength(field)
}

// hasNestedMessages checks if a message contains any singular or repeated nested message fields.
func hasNestedMessages(msg *protogen.Message) (hasSingular bool, hasRepeated bool) {
	for _, field := range msg.Fields {
		if field.Desc.Kind() == protoreflect.MessageKind {
			if field.Desc.IsList() {
				hasRepeated = true
			} else {
				hasSingular = true
			}
		}
		// stop scanning if we've already found both types.
		if hasSingular && hasRepeated {
			return
		}
	}
	return
}

func getFieldSize(field *protogen.Field) int {
	kind := field.Desc.Kind()
	switch kind {
	case protoreflect.BoolKind:
		return 1
	case protoreflect.Int32Kind, protoreflect.Uint32Kind, protoreflect.FloatKind, protoreflect.EnumKind:
		return 4
	case protoreflect.Int64Kind, protoreflect.Uint64Kind, protoreflect.DoubleKind:
		return 8
	case protoreflect.StringKind, protoreflect.BytesKind:
		panic("getFieldSize should not be called on variable-length field: " + string(field.Desc.Name()))
	default:
		panic(fmt.Sprintf("unsupported field kind: %v", kind))
	}
}

// estimateBufferSize calculates a reasonable buffer size estimate for pre-allocation
func estimateBufferSize(msg *protogen.Message) int {
	headerSize := 1 + len(msg.Fields)        // layout header + field order
	offsetTableSize := numVarFields(msg) * 5 // 5 bytes per offset entry (field_id + offset + length)

	// Estimate data size based on field types
	dataSize := 0
	for _, field := range msg.Fields {
		if isVariableLength(field) {
			if field.Desc.Kind() == protoreflect.MessageKind {
				dataSize += 64 // Estimate for nested messages
			} else {
				dataSize += 32 // Estimate for strings/bytes
			}
		} else if isRepeatedFixedSize(field) {
			dataSize += getFieldSize(field) * 4 // Estimate 4 elements
		} else {
			dataSize += getFieldSize(field) // Fixed size field
		}
	}

	total := headerSize + offsetTableSize + dataSize
	// Add 25% padding to avoid reallocations
	return total + (total / 4)
}

func numVarFields(msg *protogen.Message) int {
	count := 0
	for _, f := range msg.Fields {
		if isVariableLength(f) || isRepeatedFixedSize(f) {
			count++
		}
	}
	return count
}

// Add helper function to get Go type for a field
func getGoType(g *protogen.GeneratedFile, field *protogen.Field) string {
	kind := field.Desc.Kind()
	switch kind {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		return "int32"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Uint64Kind:
		return "uint64"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
	default:
		return "interface{}"
	}
}
