package main

import (
	"fmt"
	"sort"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var (
	math = protogen.GoImportPath("math")
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}
			generateFile(plugin, file)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".syn.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-symphony. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P("import (\n\t\"encoding/binary\"\n\t\"fmt\"\n)")
	g.P()

	for _, message := range file.Messages {
		generateMessage(g, message)
	}
}

func generateMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	// 1. Standard Struct Implementation
	generateStructType(g, msg)

	// 2. Raw Type Implementation
	generateRawType(g, msg)
}

// ==========================================
// 1. Standard Struct Implementation
// ==========================================

func generateStructType(g *protogen.GeneratedFile, msg *protogen.Message) {
	generateStructMarshal(g, msg)
	generateStructUnmarshal(g, msg)
}

func generateStructMarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	g.P("func (m *", msg.GoIdent, ") MarshalSymphony() ([]byte, error) {")

	// Handle empty messages specially
	if len(msg.Fields) == 0 {
		g.P("    // Empty message - just return version byte")
		g.P("    return []byte{0x01}, nil")
		g.P("}")
		g.P()
		return
	}

	// Get field order
	fieldOrder := fieldOrdering(msg)

	// Calculate exact size and get table size
	tableSize := generateSizeCalculation(g, msg, "size", "m", 0)

	// Pre-allocate buffer with exact size
	g.P("    buf := make([]byte, size)")
	g.P()

	// Write version byte (magic number 0x01)
	g.P("    // Version byte (magic number)")
	g.P("    buf[0] = 0x01")
	g.P()

	// Calculate table start offset
	tableStart := 1
	g.P(fmt.Sprintf("    tableStart := %d", tableStart))
	g.P("    _ = tableStart // avoid unused warning")
	g.P()

	// Calculate payload start (after table)
	payloadStart := tableStart + tableSize
	g.P(fmt.Sprintf("    payloadStart := %d", payloadStart))
	g.P("    _ = payloadStart // avoid unused warning")
	g.P("    payloadOffset := 0 // avoid no new variables warning")
	g.P("    _ = payloadOffset // avoid unused warning")
	g.P("    dataLen := 0 // avoid no new variables warning")
	g.P("    _ = dataLen // avoid unused warning")
	g.P("    count := 0 // avoid no new variables warning")
	g.P("    _ = count // avoid unused warning")
	g.P("    currentOffset := 0 // avoid no new variables warning")
	g.P("    _ = currentOffset // avoid unused warning")
	g.P()

	// Write table entries in field order
	tableOffset := 0 // Relative to tableStart
	for _, fieldNum := range fieldOrder {
		field := findFieldByNumber(msg, fieldNum)
		if field == nil {
			continue
		}

		if isFixedLengthField(field) {
			fieldSize := getFieldSize(field)
			generateFixedFieldMarshal(g, field, tableOffset)
			tableOffset += fieldSize
		} else if isVariableLengthField(field) {
			// Variable-length fields: write offset in table, then write payload
			generateVariableFieldMarshal(g, field, tableOffset)
			tableOffset += 4 // 32-bit offset in table
			// Update payload offset: 4 bytes (length) + actual data length
			g.P(fmt.Sprintf("    payloadOffset += 4 + len(m.%s)", field.GoName))
		} else if isRepeatedFixedLengthField(field) {
			// Repeated fixed-length fields: write offset in table, then write payload
			generateRepeatedFixedFieldMarshal(g, field, tableOffset)
			tableOffset += 4 // 32-bit offset in table
			// Update payload offset: 4 bytes (count) + count * fieldSize
			fieldSize := getFieldSize(field)
			g.P(fmt.Sprintf("    payloadOffset += 4 + %d*len(m.%s)", fieldSize, field.GoName))
		} else if isRepeatedVariableLengthField(field) {
			// Repeated variable-length fields: write offset in table, then write payload
			generateRepeatedVariableFieldMarshal(g, field, tableOffset)
			tableOffset += 4 // 32-bit offset in table
			// Update payload offset: 4 bytes (count) + for each item: 4 bytes (length) + data
			g.P("    payloadOffset += 4 // count")
			g.P(fmt.Sprintf("    for _, item := range m.%s {", field.GoName))
			g.P("        payloadOffset += 4 + len(item) // 4 bytes length prefix + data")
			g.P("    }")
		} else if isNestedMessageField(field) {
			// Nested messages: write offset in table, then write payload
			generateNestedFieldMarshal(g, field, tableOffset)
			tableOffset += 4 // 32-bit offset in table
			// payloadOffset is updated inside generateNestedFieldMarshal
		} else if isRepeatedNestedMessageField(field) {
			// Repeated nested messages: write offset in table, then write payload
			generateRepeatedNestedFieldMarshal(g, field, tableOffset)
			tableOffset += 4 // 32-bit offset in table
			// payloadOffset is updated inside generateRepeatedNestedFieldMarshal
		} else {
			panic(fmt.Sprintf("Unknown field type: %s", field.GoName))
		}
	}

	g.P("    return buf, nil")
	g.P("}")
	g.P()
}

func generateStructUnmarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	g.P("func (m *", msg.GoIdent, ") UnmarshalSymphony(data []byte) error {")

	// Handle empty messages specially
	if len(msg.Fields) == 0 {
		g.P("    // Empty message - just validate version byte")
		g.P("    if len(data) < 1 {")
		g.P("        return fmt.Errorf(\"invalid data: too short\")")
		g.P("    }")
		g.P("    if data[0] != 0x01 {")
		g.P("        return fmt.Errorf(\"invalid data: wrong version\")")
		g.P("    }")
		g.P("    return nil")
		g.P("}")
		g.P()
		return
	}

	// Check minimum size
	g.P("    if len(data) < 1 {")
	g.P("        return fmt.Errorf(\"invalid data: too short\")")
	g.P("    }")
	g.P()

	// Read version byte
	g.P("    // Read version byte (magic number)")
	g.P("    if data[0] != 0x01 {")
	g.P("        return fmt.Errorf(\"invalid data: wrong version\")")
	g.P("    }")
	g.P()

	// Calculate table start
	g.P("    tableStart := 1")
	g.P("    _ = tableStart // avoid unused warning")
	g.P("    payloadOffset := 0 // avoid no new variables warning")
	g.P("    _ = payloadOffset // avoid unused warning")
	g.P("    dataLen := 0 // avoid no new variables warning")
	g.P("    _ = dataLen // avoid unused warning")
	g.P("    count := 0 // avoid no new variables warning")
	g.P("    _ = count // avoid unused warning")
	g.P("    currentOffset := 0 // avoid no new variables warning")
	g.P("    _ = currentOffset // avoid unused warning")
	g.P()

	// Read table entries based on field order
	fieldOrder := fieldOrdering(msg)
	tableOffset := 0 // Relative to tableStart
	for _, fieldNum := range fieldOrder {
		field := findFieldByNumber(msg, fieldNum)
		if field == nil {
			continue
		}

		if isFixedLengthField(field) {
			fieldSize := getFieldSize(field)
			generateFixedFieldUnmarshal(g, field, tableOffset)
			tableOffset += fieldSize
		} else if isVariableLengthField(field) {
			// Variable-length fields: read offset from table, then read payload
			generateVariableFieldUnmarshal(g, field, tableOffset)
			tableOffset += 4 // 32-bit offset in table
		} else if isRepeatedFixedLengthField(field) {
			// Repeated fixed-length fields: read offset from table, then read payload
			generateRepeatedFixedFieldUnmarshal(g, field, tableOffset)
			tableOffset += 4 // 32-bit offset in table
		} else if isRepeatedVariableLengthField(field) {
			// Repeated variable-length fields: read offset from table, then read payload
			generateRepeatedVariableFieldUnmarshal(g, field, tableOffset)
			tableOffset += 4 // 32-bit offset in table
		} else if isNestedMessageField(field) {
			// Nested messages: read offset from table, then read payload
			generateNestedFieldUnmarshal(g, field, tableOffset)
			tableOffset += 4 // 32-bit offset in table
		} else if isRepeatedNestedMessageField(field) {
			// Repeated nested messages: read offset from table, then read payload
			generateRepeatedNestedFieldUnmarshal(g, field, tableOffset)
			tableOffset += 4 // 32-bit offset in table
		} else {
			panic(fmt.Sprintf("Unknown field type: %s", field.GoName))
		}
	}

	g.P("    return nil")
	g.P("}")
	g.P()
}

// ==========================================
// 2. Raw Type Implementation
// ==========================================

func generateRawType(g *protogen.GeneratedFile, msg *protogen.Message) {
	rawName := msg.GoIdent.GoName + "Raw"

	// Type Definition
	g.P("type ", rawName, " []byte")
	g.P()

	// Marshal/Unmarshal for Raw Type
	generateRawMarshal(g, rawName)
	generateRawUnmarshal(g, rawName)

	// Accessors for Raw Type
	generateRawGetters(g, msg, rawName)
	generateRawSetters(g, msg, rawName)
}

func generateRawMarshal(g *protogen.GeneratedFile, rawName string) {
	g.P("func (m ", rawName, ") MarshalSymphony() ([]byte, error) {")
	g.P("    return []byte(m), nil")
	g.P("}")
	g.P()
}

func generateRawUnmarshal(g *protogen.GeneratedFile, rawName string) {
	g.P("func (m *", rawName, ") UnmarshalSymphony(data []byte) error {")
	g.P("    *m = ", rawName, "(data)")
	g.P("    return nil")
	g.P("}")
	g.P()
}

func generateRawGetters(g *protogen.GeneratedFile, msg *protogen.Message, rawName string) {
	fieldOrder := fieldOrdering(msg)
	fieldOffsets := calculateFieldOffsets(msg, fieldOrder)

	for _, field := range msg.Fields {
		goType := getGoType(g, field, true) // true = Raw type
		g.P("func (m ", rawName, ") Get", field.GoName, "() ", goType, " {")

		if isFixedLengthField(field) {
			offset := fieldOffsets[field]
			generateRawFixedFieldGetter(g, field, offset)
		} else if isVariableLengthField(field) {
			offset := fieldOffsets[field]
			generateRawVariableFieldGetter(g, field, offset)
		} else if isRepeatedFixedLengthField(field) {
			offset := fieldOffsets[field]
			generateRawRepeatedFixedFieldGetter(g, field, offset)
		} else if isRepeatedVariableLengthField(field) {
			offset := fieldOffsets[field]
			generateRawRepeatedVariableFieldGetter(g, field, offset)
		} else if isNestedMessageField(field) {
			offset := fieldOffsets[field]
			generateRawNestedFieldGetter(g, field, offset)
		} else if isRepeatedNestedMessageField(field) {
			offset := fieldOffsets[field]
			generateRawRepeatedNestedFieldGetter(g, field, offset)
		} else {
			panic(fmt.Sprintf("Unknown field type: %s", field.GoName))
		}

		g.P("}")
		g.P()
	}
}

func generateRawSetters(g *protogen.GeneratedFile, msg *protogen.Message, rawName string) {
	fieldOrder := fieldOrdering(msg)
	fieldOffsets := calculateFieldOffsets(msg, fieldOrder)

	for _, field := range msg.Fields {
		goType := getGoType(g, field, true) // true = Raw type
		g.P("func (m *", rawName, ") Set", field.GoName, "(v ", goType, ") error {")

		if isFixedLengthField(field) {
			offset := fieldOffsets[field]
			generateRawFixedFieldSetter(g, field, offset)
		} else if isVariableLengthField(field) {
			offset := fieldOffsets[field]
			generateRawVariableFieldSetter(g, field, offset, msg)
		} else if isRepeatedFixedLengthField(field) {
			offset := fieldOffsets[field]
			generateRawRepeatedFixedFieldSetter(g, field, offset, msg)
		} else if isRepeatedVariableLengthField(field) {
			offset := fieldOffsets[field]
			generateRawRepeatedVariableFieldSetter(g, field, offset, msg)
		} else if isNestedMessageField(field) {
			offset := fieldOffsets[field]
			generateRawNestedFieldSetter(g, field, offset, msg)
		} else if isRepeatedNestedMessageField(field) {
			offset := fieldOffsets[field]
			generateRawRepeatedNestedFieldSetter(g, field, offset, msg)
		} else {
			panic(fmt.Sprintf("Unknown field type: %s", field.GoName))
		}

		g.P("}")
		g.P()
	}
}

// ==========================================
// Helpers
// ==========================================

// getGoType returns the Go type for a field.
// isRaw determines if we should return the "Raw" version of nested messages (e.g. LeafRaw vs *Leaf)
func getGoType(g *protogen.GeneratedFile, field *protogen.Field, isRaw bool) string {
	typ := ""
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		typ = "bool"
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		typ = "int32"
	case protoreflect.Uint32Kind:
		typ = "uint32"
	case protoreflect.Int64Kind:
		typ = "int64"
	case protoreflect.Uint64Kind:
		typ = "uint64"
	case protoreflect.FloatKind:
		typ = "float32"
	case protoreflect.DoubleKind:
		typ = "float64"
	case protoreflect.StringKind:
		typ = "string"
	case protoreflect.BytesKind:
		typ = "[]byte"
	case protoreflect.MessageKind:
		if isRaw {
			// For Raw types, nested fields are also Raw types (e.g. LeafRaw)
			// Note: This assumes the Raw type is in the same package or imported similarly.
			// We append "Raw" to the Go Ident name.
			typ = g.QualifiedGoIdent(field.Message.GoIdent) + "Raw"
		} else {
			// For Standard structs, nested fields are pointers to structs (e.g. *Leaf)
			typ = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		}
	default:
		typ = "interface{}"
	}
	if field.Desc.IsList() {
		return "[]" + typ
	}
	return typ
}

func getZeroValue(field *protogen.Field) string {
	if field.Desc.IsList() {
		return "nil"
	}
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "false"
	case protoreflect.StringKind:
		return "\"\""
	case protoreflect.MessageKind, protoreflect.BytesKind:
		return "nil"
	default:
		return "0"
	}
}

func fieldOrdering(msg *protogen.Message) []byte {
	fieldOrder := make([]byte, 0, len(msg.Fields))

	// Create a copy to sort
	sortedFields := make([]*protogen.Field, len(msg.Fields))
	copy(sortedFields, msg.Fields)

	// Sort fields by number to ensure deterministic order
	sort.Slice(sortedFields, func(i, j int) bool {
		return sortedFields[i].Desc.Number() < sortedFields[j].Desc.Number()
	})

	for _, field := range sortedFields {
		fieldNum := field.Desc.Number()
		if fieldNum < 0 || fieldNum > 255 {
			panic(fmt.Sprintf("field %d (%s): number out of range (0-255)", fieldNum, field.GoName))
		}
		fieldOrder = append(fieldOrder, byte(fieldNum))
	}
	return fieldOrder
}

// Helper functions for field classification and size calculation

// isFixedLengthField returns true if the field has a fixed size
func isFixedLengthField(field *protogen.Field) bool {
	if field.Desc.IsList() {
		return false // Repeated fields are variable-length (even if elements are fixed)
	}
	switch field.Desc.Kind() {
	case protoreflect.BoolKind, protoreflect.Int32Kind, protoreflect.Int64Kind,
		protoreflect.Uint32Kind, protoreflect.Uint64Kind,
		protoreflect.FloatKind, protoreflect.DoubleKind, protoreflect.EnumKind:
		return true
	default:
		return false
	}
}

// getFieldSize returns the size in bytes of a fixed-length field
func getFieldSize(field *protogen.Field) int {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return 1
	case protoreflect.Int32Kind, protoreflect.Uint32Kind, protoreflect.FloatKind, protoreflect.EnumKind:
		return 4
	case protoreflect.Int64Kind, protoreflect.Uint64Kind, protoreflect.DoubleKind:
		return 8
	default:
		panic(fmt.Sprintf("unknown fixed-length field kind: %s", field.Desc.Kind()))
	}
}

// findFieldByNumber finds a field by its field number
func findFieldByNumber(msg *protogen.Message, fieldNum byte) *protogen.Field {
	for _, field := range msg.Fields {
		if byte(field.Desc.Number()) == fieldNum {
			return field
		}
	}
	return nil
}

// calculateFieldOffsets calculates the table offset for each field based on field order
func calculateFieldOffsets(msg *protogen.Message, fieldOrder []byte) map[*protogen.Field]int {
	offsets := make(map[*protogen.Field]int)
	tableStart := 1 // After version byte
	offset := tableStart

	for _, fieldNum := range fieldOrder {
		field := findFieldByNumber(msg, fieldNum)
		if field == nil {
			continue
		}
		offsets[field] = offset
		if isFixedLengthField(field) {
			offset += getFieldSize(field)
		} else {
			offset += 4 // 32-bit placeholder for variable-length fields
		}
	}

	return offsets
}

// generateRawFixedFieldGetter generates code to read a fixed-length field from Raw type
func generateRawFixedFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): fixed-length (%d bytes) at offset %d", fieldNum, goName, fieldSize, tableOffset))
	g.P(fmt.Sprintf("    if len(m) < %d {", tableOffset+fieldSize))
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("    return m[%d] != 0", tableOffset))
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("    return int32(binary.LittleEndian.Uint32(m[%d:]))", tableOffset))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("    return binary.LittleEndian.Uint32(m[%d:])", tableOffset))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("    return int64(binary.LittleEndian.Uint64(m[%d:]))", tableOffset))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("    return binary.LittleEndian.Uint64(m[%d:])", tableOffset))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32frombits"))
		g.P(fmt.Sprintf("    return %s(binary.LittleEndian.Uint32(m[%d:]))", mathQualified, tableOffset))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64frombits"))
		g.P(fmt.Sprintf("    return %s(binary.LittleEndian.Uint64(m[%d:]))", mathQualified, tableOffset))
	}
}

// generateRawFixedFieldSetter generates code to write a fixed-length field to Raw type
func generateRawFixedFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): fixed-length (%d bytes) at offset %d", fieldNum, goName, fieldSize, tableOffset))
	g.P(fmt.Sprintf("    if len(*m) < %d {", tableOffset+fieldSize))
	g.P("        return fmt.Errorf(\"buffer too short\")")
	g.P("    }")

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P("    if v {")
		g.P(fmt.Sprintf("        (*m)[%d] = 1", tableOffset))
		g.P("    } else {")
		g.P(fmt.Sprintf("        (*m)[%d] = 0", tableOffset))
		g.P("    }")
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32((*m)[%d:], uint32(v))", tableOffset))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32((*m)[%d:], v)", tableOffset))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64((*m)[%d:], uint64(v))", tableOffset))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64((*m)[%d:], v)", tableOffset))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32bits"))
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32((*m)[%d:], %s(v))", tableOffset, mathQualified))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64bits"))
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64((*m)[%d:], %s(v))", tableOffset, mathQualified))
	}
	g.P("    return nil")
}

// isVariableLengthField returns true if the field is a variable-length field (string or bytes, singular, not nested)
func isVariableLengthField(field *protogen.Field) bool {
	if field.Desc.IsList() {
		return false // Repeated fields handled separately
	}
	if field.Desc.Kind() == protoreflect.MessageKind {
		return false // Nested messages handled separately
	}
	return field.Desc.Kind() == protoreflect.StringKind || field.Desc.Kind() == protoreflect.BytesKind
}

// isRepeatedFixedLengthField returns true if the field is a repeated fixed-length field
func isRepeatedFixedLengthField(field *protogen.Field) bool {
	if !field.Desc.IsList() {
		return false
	}
	if field.Desc.Kind() == protoreflect.MessageKind {
		return false // Repeated nested messages handled separately
	}
	switch field.Desc.Kind() {
	case protoreflect.BoolKind, protoreflect.Int32Kind, protoreflect.Int64Kind,
		protoreflect.Uint32Kind, protoreflect.Uint64Kind,
		protoreflect.FloatKind, protoreflect.DoubleKind, protoreflect.EnumKind:
		return true
	default:
		return false
	}
}

// isRepeatedVariableLengthField returns true if the field is a repeated variable-length field (repeated string or bytes)
func isRepeatedVariableLengthField(field *protogen.Field) bool {
	if !field.Desc.IsList() {
		return false
	}
	return field.Desc.Kind() == protoreflect.StringKind || field.Desc.Kind() == protoreflect.BytesKind
}

// isNestedMessageField returns true if the field is a singular nested message
func isNestedMessageField(field *protogen.Field) bool {
	if field.Desc.IsList() {
		return false // Repeated nested messages handled separately
	}
	return field.Desc.Kind() == protoreflect.MessageKind
}

// isRepeatedNestedMessageField returns true if the field is a repeated nested message
func isRepeatedNestedMessageField(field *protogen.Field) bool {
	return field.Desc.IsList() && field.Desc.Kind() == protoreflect.MessageKind
}

// generateSizeCalculation generates code to calculate the exact buffer size
// Returns the table size for use in calculating payload start
// sizeVar: variable name to accumulate size (default "size")
// msgVar: variable name for message instance (default "m")
// depth: nesting depth for unique variable names (default 0)
func generateSizeCalculation(g *protogen.GeneratedFile, msg *protogen.Message, sizeVar, msgVar string, depth int) int {
	if sizeVar == "" {
		sizeVar = "size"
	}
	if msgVar == "" {
		msgVar = "m"
	}

	// Use unique variable name for nested size calculations
	nestedSizeVar := sizeVar
	if depth > 0 {
		nestedSizeVar = fmt.Sprintf("nestedSize%d", depth)
	}

	g.P(fmt.Sprintf("    %s := 0", nestedSizeVar))
	g.P(fmt.Sprintf("    %s += 1 // version byte (magic number 0x01)", nestedSizeVar))

	// Calculate table size: iterate over all fields (not fieldOrder)
	// Fixed fields store values, variable fields store 4-byte offset
	tableSize := 0
	for _, field := range msg.Fields {
		if isFixedLengthField(field) {
			tableSize += getFieldSize(field)
		} else {
			tableSize += 4 // 32-bit offset for variable-length fields
		}
	}
	g.P(fmt.Sprintf("    %s += %d // table entries", nestedSizeVar, tableSize))
	g.P()

	// Calculate payload size for variable-length fields
	// For each variable-length field: 4 bytes (length prefix) + actual data
	// For each repeated fixed-length field: 4 bytes (count) + count * fieldSize
	fieldOrder := fieldOrdering(msg)
	for _, fieldNum := range fieldOrder {
		field := findFieldByNumber(msg, fieldNum)
		if field == nil {
			continue
		}
		if isVariableLengthField(field) {
			goName := field.GoName
			g.P(fmt.Sprintf("    // Field %d (%s): variable-length payload", fieldNum, goName))
			g.P(fmt.Sprintf("    %s += 4 + len(%s.%s) // 4 bytes length prefix + data", nestedSizeVar, msgVar, goName))
		} else if isRepeatedFixedLengthField(field) {
			goName := field.GoName
			fieldSize := getFieldSize(field)
			g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length payload", fieldNum, goName))
			g.P(fmt.Sprintf("    %s += 4 + %d*len(%s.%s) // 4 bytes count + data", nestedSizeVar, fieldSize, msgVar, goName))
		} else if isRepeatedVariableLengthField(field) {
			goName := field.GoName
			g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length payload", fieldNum, goName))
			g.P(fmt.Sprintf("    %s += 4 // count", nestedSizeVar))
			g.P(fmt.Sprintf("    for _, item := range %s.%s {", msgVar, goName))
			g.P(fmt.Sprintf("        %s += 4 + len(item) // 4 bytes length prefix + data", nestedSizeVar))
			g.P("    }")
		} else if isNestedMessageField(field) {
			goName := field.GoName
			g.P(fmt.Sprintf("    // Field %d (%s): nested message payload", fieldNum, goName))
			g.P(fmt.Sprintf("    if %s.%s != nil {", msgVar, goName))
			// Recursively calculate size for nested message with incremented depth
			childNestedSizeVar := fmt.Sprintf("nestedSize%d", depth+1)
			generateSizeCalculation(g, field.Message, childNestedSizeVar, fmt.Sprintf("%s.%s", msgVar, goName), depth+1)
			// Add 4 bytes (size prefix) + the nested message size
			g.P(fmt.Sprintf("        %s += 4 + %s // 4 bytes size + message data", nestedSizeVar, childNestedSizeVar))
			g.P("    }")
		} else if isRepeatedNestedMessageField(field) {
			goName := field.GoName
			g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message payload", fieldNum, goName))
			g.P(fmt.Sprintf("    %s += 4 // count", nestedSizeVar))
			g.P(fmt.Sprintf("    for _, item := range %s.%s {", msgVar, goName))
			// Recursively calculate size for each nested message with incremented depth
			childNestedSizeVar := fmt.Sprintf("nestedSize%d", depth+1)
			generateSizeCalculation(g, field.Message, childNestedSizeVar, "item", depth+1)
			// Add 4 bytes (size prefix) + the nested message size for each item
			g.P(fmt.Sprintf("        %s += 4 + %s // 4 bytes size + message data", nestedSizeVar, childNestedSizeVar))
			g.P("    }")
		}
	}
	g.P()

	return tableSize
}

// generateFixedFieldMarshal generates code to marshal a fixed-length field
func generateFixedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): fixed-length (%d bytes)", fieldNum, goName, fieldSize))

	// Write the value directly into the table at the calculated offset
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("    if m.%s {", goName))
		g.P(fmt.Sprintf("        buf[tableStart+%d] = 1", tableOffset))
		g.P("    } else {")
		g.P(fmt.Sprintf("        buf[tableStart+%d] = 0", tableOffset))
		g.P("    }")
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[tableStart+%d:], uint32(m.%s))", tableOffset, goName))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[tableStart+%d:], m.%s)", tableOffset, goName))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64(buf[tableStart+%d:], uint64(m.%s))", tableOffset, goName))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64(buf[tableStart+%d:], m.%s)", tableOffset, goName))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32bits"))
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[tableStart+%d:], %s(m.%s))", tableOffset, mathQualified, goName))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64bits"))
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64(buf[tableStart+%d:], %s(m.%s))", tableOffset, mathQualified, goName))
	}
	g.P()
}

// generateFixedFieldUnmarshal generates code to unmarshal a fixed-length field
func generateFixedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): fixed-length (%d bytes)", fieldNum, goName, fieldSize))
	g.P(fmt.Sprintf("    if len(data) < tableStart+%d {", tableOffset+fieldSize))
	g.P("        return fmt.Errorf(\"invalid data: too short for field\")")
	g.P("    }")

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("    m.%s = data[tableStart+%d] != 0", goName, tableOffset))
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("    m.%s = int32(binary.LittleEndian.Uint32(data[tableStart+%d:]))", goName, tableOffset))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("    m.%s = binary.LittleEndian.Uint32(data[tableStart+%d:])", goName, tableOffset))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("    m.%s = int64(binary.LittleEndian.Uint64(data[tableStart+%d:]))", goName, tableOffset))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("    m.%s = binary.LittleEndian.Uint64(data[tableStart+%d:])", goName, tableOffset))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32frombits"))
		g.P(fmt.Sprintf("    m.%s = %s(binary.LittleEndian.Uint32(data[tableStart+%d:]))", goName, mathQualified, tableOffset))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64frombits"))
		g.P(fmt.Sprintf("    m.%s = %s(binary.LittleEndian.Uint64(data[tableStart+%d:]))", goName, mathQualified, tableOffset))
	}
	g.P()
}

// generateVariableFieldMarshal generates code to marshal a variable-length field (string or bytes)
func generateVariableFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): variable-length", fieldNum, goName))

	// Write offset in table entry (using payloadOffset variable)
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[tableStart+%d:], uint32(payloadStart+payloadOffset))", tableOffset))

	// Write length prefix and data in payload
	g.P(fmt.Sprintf("    dataLen = len(m.%s)", goName))
	g.P("    binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))")
	g.P(fmt.Sprintf("    copy(buf[payloadStart+payloadOffset+4:], m.%s)", goName))
	g.P()
}

// generateVariableFieldUnmarshal generates code to unmarshal a variable-length field (string or bytes)
func generateVariableFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): variable-length", fieldNum, goName))

	// Read offset from table entry
	g.P(fmt.Sprintf("    if len(data) < tableStart+%d+4 {", tableOffset))
	g.P("        return fmt.Errorf(\"invalid data: too short for offset\")")
	g.P("    }")
	g.P(fmt.Sprintf("    payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+%d:]))", tableOffset))

	// Read length from payload
	g.P("    if len(data) < payloadOffset+4 {")
	g.P("        return fmt.Errorf(\"invalid data: too short for length\")")
	g.P("    }")
	g.P("    dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")

	// Read actual data
	g.P("    if len(data) < payloadOffset+4+dataLen {")
	g.P("        return fmt.Errorf(\"invalid data: too short for data\")")
	g.P("    }")

	if field.Desc.Kind() == protoreflect.StringKind {
		g.P(fmt.Sprintf("    m.%s = string(data[payloadOffset+4 : payloadOffset+4+dataLen])", goName))
	} else { // BytesKind
		g.P(fmt.Sprintf("    m.%s = make([]byte, dataLen)", goName))
		g.P(fmt.Sprintf("    copy(m.%s, data[payloadOffset+4:payloadOffset+4+dataLen])", goName))
	}
	g.P()
}

// generateRepeatedFixedFieldMarshal generates code to marshal a repeated fixed-length field
func generateRepeatedFixedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length", fieldNum, goName))

	// Write offset in table entry (using payloadOffset variable)
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[tableStart+%d:], uint32(payloadStart+payloadOffset))", tableOffset))

	// Write count and data in payload
	g.P(fmt.Sprintf("    count = len(m.%s)", goName))
	g.P("    binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))")

	// Write each element
	g.P(fmt.Sprintf("    for i, v := range m.%s {", goName))
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P("        if v {")
		g.P(fmt.Sprintf("            buf[payloadStart+payloadOffset+4+%d*i] = 1", fieldSize))
		g.P("        } else {")
		g.P(fmt.Sprintf("            buf[payloadStart+payloadOffset+4+%d*i] = 0", fieldSize))
		g.P("        }")
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset+4+%d*i:], uint32(v))", fieldSize))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset+4+%d*i:], v)", fieldSize))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(buf[payloadStart+payloadOffset+4+%d*i:], uint64(v))", fieldSize))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(buf[payloadStart+payloadOffset+4+%d*i:], v)", fieldSize))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32bits"))
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset+4+%d*i:], %s(v))", fieldSize, mathQualified))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64bits"))
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(buf[payloadStart+payloadOffset+4+%d*i:], %s(v))", fieldSize, mathQualified))
	}
	g.P("    }")
	g.P()
}

// generateRepeatedFixedFieldUnmarshal generates code to unmarshal a repeated fixed-length field
func generateRepeatedFixedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length", fieldNum, goName))

	// Read offset from table entry
	g.P(fmt.Sprintf("    if len(data) < tableStart+%d+4 {", tableOffset))
	g.P("        return fmt.Errorf(\"invalid data: too short for offset\")")
	g.P("    }")
	g.P(fmt.Sprintf("    payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+%d:]))", tableOffset))

	// Read count from payload
	g.P("    if len(data) < payloadOffset+4 {")
	g.P("        return fmt.Errorf(\"invalid data: too short for count\")")
	g.P("    }")
	g.P("    count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")

	// Validate data length
	g.P(fmt.Sprintf("    if len(data) < payloadOffset+4+%d*count {", fieldSize))
	g.P("        return fmt.Errorf(\"invalid data: too short for repeated data\")")
	g.P("    }")

	// Allocate slice and read each element
	g.P(fmt.Sprintf("    m.%s = make([]%s, count)", goName, getGoTypeName(field)))
	g.P("    for i := 0; i < count; i++ {")
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("        m.%s[i] = data[payloadOffset+4+%d*i] != 0", goName, fieldSize))
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("        m.%s[i] = int32(binary.LittleEndian.Uint32(data[payloadOffset+4+%d*i:]))", goName, fieldSize))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("        m.%s[i] = binary.LittleEndian.Uint32(data[payloadOffset+4+%d*i:])", goName, fieldSize))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("        m.%s[i] = int64(binary.LittleEndian.Uint64(data[payloadOffset+4+%d*i:]))", goName, fieldSize))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("        m.%s[i] = binary.LittleEndian.Uint64(data[payloadOffset+4+%d*i:])", goName, fieldSize))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32frombits"))
		g.P(fmt.Sprintf("        m.%s[i] = %s(binary.LittleEndian.Uint32(data[payloadOffset+4+%d*i:]))", goName, mathQualified, fieldSize))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64frombits"))
		g.P(fmt.Sprintf("        m.%s[i] = %s(binary.LittleEndian.Uint64(data[payloadOffset+4+%d*i:]))", goName, mathQualified, fieldSize))
	}
	g.P("    }")
	g.P()
}

// generateRepeatedVariableFieldMarshal generates code to marshal a repeated variable-length field (repeated string or bytes)
func generateRepeatedVariableFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length", fieldNum, goName))

	// Write offset in table entry (using payloadOffset variable)
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[tableStart+%d:], uint32(payloadStart+payloadOffset))", tableOffset))

	// Write count in payload
	g.P(fmt.Sprintf("    count = len(m.%s)", goName))
	g.P("    binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))")

	// Write each element: 4 bytes length prefix + data
	g.P("    currentOffset = payloadStart + payloadOffset + 4")
	g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
	g.P("        itemLen := len(item)")
	g.P("        binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))")
	g.P("        copy(buf[currentOffset+4:], item)")
	g.P("        currentOffset += 4 + itemLen")
	g.P("    }")
	g.P()
}

// generateRepeatedVariableFieldUnmarshal generates code to unmarshal a repeated variable-length field (repeated string or bytes)
func generateRepeatedVariableFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length", fieldNum, goName))

	// Read offset from table entry
	g.P(fmt.Sprintf("    if len(data) < tableStart+%d+4 {", tableOffset))
	g.P("        return fmt.Errorf(\"invalid data: too short for offset\")")
	g.P("    }")
	g.P(fmt.Sprintf("    payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+%d:]))", tableOffset))

	// Read count from payload
	g.P("    if len(data) < payloadOffset+4 {")
	g.P("        return fmt.Errorf(\"invalid data: too short for count\")")
	g.P("    }")
	g.P("    count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")

	// Allocate slice
	if field.Desc.Kind() == protoreflect.StringKind {
		g.P(fmt.Sprintf("    m.%s = make([]string, count)", goName))
	} else { // BytesKind
		g.P(fmt.Sprintf("    m.%s = make([][]byte, count)", goName))
	}

	// Read each element
	g.P("    currentOffset = payloadOffset + 4")
	g.P("    for i := 0; i < count; i++ {")
	g.P("        if len(data) < currentOffset+4 {")
	g.P("            return fmt.Errorf(\"invalid data: too short for item length\")")
	g.P("        }")
	g.P("        itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))")
	g.P("        if len(data) < currentOffset+4+itemLen {")
	g.P("            return fmt.Errorf(\"invalid data: too short for item data\")")
	g.P("        }")
	if field.Desc.Kind() == protoreflect.StringKind {
		g.P(fmt.Sprintf("        m.%s[i] = string(data[currentOffset+4 : currentOffset+4+itemLen])", goName))
	} else { // BytesKind
		g.P(fmt.Sprintf("        m.%s[i] = make([]byte, itemLen)", goName))
		g.P(fmt.Sprintf("        copy(m.%s[i], data[currentOffset+4:currentOffset+4+itemLen])", goName))
	}
	g.P("        currentOffset += 4 + itemLen")
	g.P("    }")
	g.P()
}

// generateNestedFieldMarshal generates code to marshal a nested message field
func generateNestedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): nested message", fieldNum, goName))

	// Write offset in table entry (using payloadOffset variable)
	g.P(fmt.Sprintf("    if m.%s != nil {", goName))
	g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[tableStart+%d:], uint32(payloadStart+payloadOffset))", tableOffset))
	g.P(fmt.Sprintf("        nestedData, err := m.%s.MarshalSymphony()", goName))
	g.P("        if err != nil {")
	g.P("            return nil, fmt.Errorf(\"failed to marshal nested message: %w\", err)")
	g.P("        }")
	g.P("        nestedSize := len(nestedData)")
	g.P("        binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))")
	g.P("        copy(buf[payloadStart+payloadOffset+4:], nestedData)")
	g.P("        payloadOffset += 4 + nestedSize // 4 bytes size + message data")
	g.P("    } else {")
	g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[tableStart+%d:], 0)", tableOffset))
	g.P("    }")
	g.P()
}

// generateNestedFieldUnmarshal generates code to unmarshal a nested message field
func generateNestedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): nested message", fieldNum, goName))

	// Read offset from table entry
	g.P(fmt.Sprintf("    if len(data) < tableStart+%d+4 {", tableOffset))
	g.P("        return fmt.Errorf(\"invalid data: too short for offset\")")
	g.P("    }")
	g.P(fmt.Sprintf("    payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+%d:]))", tableOffset))

	// Check if message is present (offset 0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P(fmt.Sprintf("        m.%s = nil", goName))
	g.P("    } else {")
	g.P("        // Read size from payload")
	g.P("        if len(data) < payloadOffset+4 {")
	g.P("            return fmt.Errorf(\"invalid data: too short for nested message size\")")
	g.P("        }")
	g.P("        nestedSize := int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P("        if len(data) < payloadOffset+4+nestedSize {")
	g.P("            return fmt.Errorf(\"invalid data: too short for nested message data\")")
	g.P("        }")
	g.P(fmt.Sprintf("        if m.%s == nil {", goName))
	msgType := g.QualifiedGoIdent(field.Message.GoIdent)
	g.P(fmt.Sprintf("            m.%s = &%s{}", goName, msgType))
	g.P("        }")
	g.P(fmt.Sprintf("        if err := m.%s.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+nestedSize]); err != nil {", goName))
	g.P("            return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
	g.P("        }")
	g.P("    }")
	g.P()
}

// generateRepeatedNestedFieldMarshal generates code to marshal a repeated nested message field
func generateRepeatedNestedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message", fieldNum, goName))

	// Write offset in table entry (using payloadOffset variable)
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[tableStart+%d:], uint32(payloadStart+payloadOffset))", tableOffset))

	// Write count in payload
	g.P(fmt.Sprintf("    count = len(m.%s)", goName))
	g.P("    binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))")

	// Write each nested message: 4 bytes size + marshaled content
	g.P("    payloadOffset += 4 // count")
	g.P("    currentOffset = payloadStart + payloadOffset")
	g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
	g.P("        nestedData, err := item.MarshalSymphony()")
	g.P("        if err != nil {")
	g.P("            return nil, fmt.Errorf(\"failed to marshal nested message: %w\", err)")
	g.P("        }")
	g.P("        nestedSize := len(nestedData)")
	g.P("        binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))")
	g.P("        copy(buf[currentOffset+4:], nestedData)")
	g.P("        currentOffset += 4 + nestedSize")
	g.P("        payloadOffset += 4 + nestedSize // 4 bytes size + message data")
	g.P("    }")
	g.P()
}

// generateRepeatedNestedFieldUnmarshal generates code to unmarshal a repeated nested message field
func generateRepeatedNestedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	msgType := g.QualifiedGoIdent(field.Message.GoIdent)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message", fieldNum, goName))

	// Read offset from table entry
	g.P(fmt.Sprintf("    if len(data) < tableStart+%d+4 {", tableOffset))
	g.P("        return fmt.Errorf(\"invalid data: too short for offset\")")
	g.P("    }")
	g.P(fmt.Sprintf("    payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+%d:]))", tableOffset))

	// Read count from payload
	g.P("    if len(data) < payloadOffset+4 {")
	g.P("        return fmt.Errorf(\"invalid data: too short for count\")")
	g.P("    }")
	g.P("    count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")

	// Allocate slice
	g.P(fmt.Sprintf("    m.%s = make([]*%s, count)", goName, msgType))

	// Read each nested message
	g.P("    currentOffset = payloadOffset + 4")
	g.P("    for i := 0; i < count; i++ {")
	g.P("        if len(data) < currentOffset+4 {")
	g.P("            return fmt.Errorf(\"invalid data: too short for nested message size\")")
	g.P("        }")
	g.P("        nestedSize := int(binary.LittleEndian.Uint32(data[currentOffset:]))")
	g.P("        if len(data) < currentOffset+4+nestedSize {")
	g.P("            return fmt.Errorf(\"invalid data: too short for nested message data\")")
	g.P("        }")
	g.P(fmt.Sprintf("        m.%s[i] = &%s{}", goName, msgType))
	g.P(fmt.Sprintf("        if err := m.%s[i].UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+nestedSize]); err != nil {", goName))
	g.P("            return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
	g.P("        }")
	g.P("        currentOffset += 4 + nestedSize")
	g.P("    }")
	g.P()
}

// getGoTypeName returns the Go type name for a field
func getGoTypeName(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		return "int32"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Uint64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	default:
		panic(fmt.Sprintf("unknown fixed-length field kind: %s", field.Desc.Kind()))
	}
}

// generateRawVariableFieldGetter generates code to read a variable-length field from Raw type
func generateRawVariableFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): variable-length at table offset %d", fieldNum, goName, tableOffset))

	// Check buffer size
	g.P(fmt.Sprintf("    if len(m) < %d+4 {", tableOffset))
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read offset from table entry
	g.P(fmt.Sprintf("    payloadOffset := int(binary.LittleEndian.Uint32(m[%d:]))", tableOffset))

	// Check if offset is valid (0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read length from payload
	g.P("    if len(m) < payloadOffset+4 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")
	g.P("    dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))")

	// Read actual data
	g.P("    if len(m) < payloadOffset+4+dataLen {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	if field.Desc.Kind() == protoreflect.StringKind {
		g.P("    return string(m[payloadOffset+4 : payloadOffset+4+dataLen])")
	} else { // BytesKind
		g.P("    result := make([]byte, dataLen)")
		g.P("    copy(result, m[payloadOffset+4:payloadOffset+4+dataLen])")
		g.P("    return result")
	}
}

// generateRawVariableFieldSetter generates code to write a variable-length field to Raw type
func generateRawVariableFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, msg *protogen.Message) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): variable-length at table offset %d", fieldNum, goName, tableOffset))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(*m) < %d+4 {", tableOffset))
	g.P("        return fmt.Errorf(\"buffer too short for table entry\")")
	g.P("    }")

	// Read current offset and length
	g.P(fmt.Sprintf("    oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[%d:]))", tableOffset))
	g.P("    var oldDataLen int")
	g.P("    if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {")
	g.P("        oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))")
	g.P("    }")

	// Calculate new data length
	g.P("    newDataLen := len(v)")

	// Check if we can update in-place
	g.P("    if oldPayloadOffset > 0 && newDataLen <= oldDataLen {")
	g.P("        // Update in-place (waste space)")
	g.P("        binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))")
	g.P("        copy((*m)[oldPayloadOffset+4:], v)")
	g.P("        return nil")
	g.P("    }")

	// Need to remarshal - unmarshal, update, marshal
	g.P("    // Need to remarshal: unmarshal, update, marshal")
	msgType := msg.GoIdent.GoName
	g.P(fmt.Sprintf("    var temp %s", msgType))
	g.P("    if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {")
	g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
	g.P("    }")

	// Update the field
	g.P(fmt.Sprintf("    temp.%s = v", goName))

	// Marshal again
	g.P("    newData, err := temp.MarshalSymphony()")
	g.P("    if err != nil {")
	g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
	g.P("    }")
	g.P("    *m = ", msg.GoIdent.GoName, "Raw(newData)")
	g.P("    return nil")
}

// generateRawRepeatedFixedFieldGetter generates code to read a repeated fixed-length field from Raw type
func generateRawRepeatedFixedFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length at table offset %d", fieldNum, goName, tableOffset))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(m) < %d+4 {", tableOffset))
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read offset from table entry
	g.P(fmt.Sprintf("    payloadOffset := int(binary.LittleEndian.Uint32(m[%d:]))", tableOffset))

	// Check if offset is valid (0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read count from payload
	g.P("    if len(m) < payloadOffset+4 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")
	g.P("    count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))")

	// Validate data length
	g.P(fmt.Sprintf("    if len(m) < payloadOffset+4+%d*count {", fieldSize))
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Allocate slice and read each element
	g.P(fmt.Sprintf("    result := make([]%s, count)", getGoTypeName(field)))
	g.P("    for i := 0; i < count; i++ {")
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("        result[i] = m[payloadOffset+4+%d*i] != 0", fieldSize))
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("        result[i] = int32(binary.LittleEndian.Uint32(m[payloadOffset+4+%d*i:]))", fieldSize))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("        result[i] = binary.LittleEndian.Uint32(m[payloadOffset+4+%d*i:])", fieldSize))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("        result[i] = int64(binary.LittleEndian.Uint64(m[payloadOffset+4+%d*i:]))", fieldSize))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("        result[i] = binary.LittleEndian.Uint64(m[payloadOffset+4+%d*i:])", fieldSize))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32frombits"))
		g.P(fmt.Sprintf("        result[i] = %s(binary.LittleEndian.Uint32(m[payloadOffset+4+%d*i:]))", mathQualified, fieldSize))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64frombits"))
		g.P(fmt.Sprintf("        result[i] = %s(binary.LittleEndian.Uint64(m[payloadOffset+4+%d*i:]))", mathQualified, fieldSize))
	}
	g.P("    }")
	g.P("    return result")
}

// generateRawRepeatedFixedFieldSetter generates code to write a repeated fixed-length field to Raw type
func generateRawRepeatedFixedFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, msg *protogen.Message) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length at table offset %d", fieldNum, goName, tableOffset))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(*m) < %d+4 {", tableOffset))
	g.P("        return fmt.Errorf(\"buffer too short for table entry\")")
	g.P("    }")

	// Read current offset and count
	g.P(fmt.Sprintf("    oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[%d:]))", tableOffset))
	g.P("    var oldCount int")
	g.P("    var oldDataSize int")
	g.P("    if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {")
	g.P("        oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))")
	g.P(fmt.Sprintf("        oldDataSize = 4 + %d*oldCount // 4 bytes count + data", fieldSize))
	g.P("    }")

	// Calculate new count and data size
	g.P("    newCount := len(v)")
	g.P(fmt.Sprintf("    newDataSize := 4 + %d*newCount // 4 bytes count + data", fieldSize))

	// Check if we can update in-place
	g.P("    if oldPayloadOffset > 0 && newDataSize <= oldDataSize {")
	g.P("        // Update in-place (waste space)")
	g.P("        binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))")
	g.P("        for i, val := range v {")
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P("            if val {")
		g.P(fmt.Sprintf("                (*m)[oldPayloadOffset+4+%d*i] = 1", fieldSize))
		g.P("            } else {")
		g.P(fmt.Sprintf("                (*m)[oldPayloadOffset+4+%d*i] = 0", fieldSize))
		g.P("            }")
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint32((*m)[oldPayloadOffset+4+%d*i:], uint32(val))", fieldSize))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint32((*m)[oldPayloadOffset+4+%d*i:], val)", fieldSize))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint64((*m)[oldPayloadOffset+4+%d*i:], uint64(val))", fieldSize))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint64((*m)[oldPayloadOffset+4+%d*i:], val)", fieldSize))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32bits"))
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint32((*m)[oldPayloadOffset+4+%d*i:], %s(val))", fieldSize, mathQualified))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64bits"))
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint64((*m)[oldPayloadOffset+4+%d*i:], %s(val))", fieldSize, mathQualified))
	}
	g.P("        }")
	g.P("        return nil")
	g.P("    }")

	// Need to remarshal - unmarshal, update, marshal
	g.P("    // Need to remarshal: unmarshal, update, marshal")
	msgType := msg.GoIdent.GoName
	g.P(fmt.Sprintf("    var temp %s", msgType))
	g.P("    if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {")
	g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
	g.P("    }")

	// Update the field
	g.P(fmt.Sprintf("    temp.%s = v", goName))

	// Marshal again
	g.P("    newData, err := temp.MarshalSymphony()")
	g.P("    if err != nil {")
	g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
	g.P("    }")
	g.P("    *m = ", msg.GoIdent.GoName, "Raw(newData)")
	g.P("    return nil")
}

// generateRawRepeatedVariableFieldGetter generates code to read a repeated variable-length field from Raw type
func generateRawRepeatedVariableFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length at table offset %d", fieldNum, goName, tableOffset))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(m) < %d+4 {", tableOffset))
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read offset from table entry
	g.P(fmt.Sprintf("    payloadOffset := int(binary.LittleEndian.Uint32(m[%d:]))", tableOffset))

	// Check if offset is valid (0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read count from payload
	g.P("    if len(m) < payloadOffset+4 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")
	g.P("    count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))")

	// Allocate slice
	if field.Desc.Kind() == protoreflect.StringKind {
		g.P("    result := make([]string, count)")
	} else { // BytesKind
		g.P("    result := make([][]byte, count)")
	}

	// Read each element
	g.P("    currentOffset := payloadOffset + 4")
	g.P("    for i := 0; i < count; i++ {")
	g.P("        if len(m) < currentOffset+4 {")
	g.P("            return ", getZeroValue(field))
	g.P("        }")
	g.P("        itemLen := int(binary.LittleEndian.Uint32(m[currentOffset:]))")
	g.P("        if len(m) < currentOffset+4+itemLen {")
	g.P("            return ", getZeroValue(field))
	g.P("        }")
	if field.Desc.Kind() == protoreflect.StringKind {
		g.P("        result[i] = string(m[currentOffset+4 : currentOffset+4+itemLen])")
	} else { // BytesKind
		g.P("        result[i] = make([]byte, itemLen)")
		g.P("        copy(result[i], m[currentOffset+4:currentOffset+4+itemLen])")
	}
	g.P("        currentOffset += 4 + itemLen")
	g.P("    }")
	g.P("    return result")
}

// generateRawRepeatedVariableFieldSetter generates code to write a repeated variable-length field to Raw type
func generateRawRepeatedVariableFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, msg *protogen.Message) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length at table offset %d", fieldNum, goName, tableOffset))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(*m) < %d+4 {", tableOffset))
	g.P("        return fmt.Errorf(\"buffer too short for table entry\")")
	g.P("    }")

	// Read current offset and count
	g.P(fmt.Sprintf("    oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[%d:]))", tableOffset))
	g.P("    var oldCount int")
	g.P("    var oldDataSize int")
	g.P("    if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {")
	g.P("        oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))")
	g.P("        // Calculate old data size: 4 bytes count + for each item: 4 bytes length + data")
	g.P("        oldDataSize = 4")
	g.P("        currentOffset := oldPayloadOffset + 4")
	g.P("        for i := 0; i < oldCount; i++ {")
	g.P("            if len(*m) < currentOffset+4 {")
	g.P("                break")
	g.P("            }")
	g.P("            itemLen := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))")
	g.P("            oldDataSize += 4 + itemLen")
	g.P("            currentOffset += 4 + itemLen")
	g.P("        }")
	g.P("    }")

	// Calculate new count and data size
	g.P("    newCount := len(v)")
	g.P("    newDataSize := 4 // count")
	g.P("    for _, item := range v {")
	g.P("        newDataSize += 4 + len(item) // 4 bytes length + data")
	g.P("    }")

	// Check if we can update in-place
	g.P("    if oldPayloadOffset > 0 && newDataSize <= oldDataSize {")
	g.P("        // Update in-place (waste space)")
	g.P("        binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))")
	g.P("        currentOffset := oldPayloadOffset + 4")
	g.P("        for _, item := range v {")
	g.P("            itemLen := len(item)")
	g.P("            binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemLen))")
	g.P("            copy((*m)[currentOffset+4:], item)")
	g.P("            currentOffset += 4 + itemLen")
	g.P("        }")
	g.P("        return nil")
	g.P("    }")

	// Need to remarshal - unmarshal, update, marshal
	g.P("    // Need to remarshal: unmarshal, update, marshal")
	msgType := msg.GoIdent.GoName
	g.P(fmt.Sprintf("    var temp %s", msgType))
	g.P("    if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {")
	g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
	g.P("    }")

	// Update the field
	g.P(fmt.Sprintf("    temp.%s = v", goName))

	// Marshal again
	g.P("    newData, err := temp.MarshalSymphony()")
	g.P("    if err != nil {")
	g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
	g.P("    }")
	g.P("    *m = ", msg.GoIdent.GoName, "Raw(newData)")
	g.P("    return nil")
}

// generateRawNestedFieldGetter generates code to read a nested message field from Raw type
func generateRawNestedFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	rawType := g.QualifiedGoIdent(field.Message.GoIdent) + "Raw"

	g.P(fmt.Sprintf("    // Field %d (%s): nested message at table offset %d", fieldNum, goName, tableOffset))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(m) < %d+4 {", tableOffset))
	g.P("        return nil")
	g.P("    }")

	// Read offset from table entry
	g.P(fmt.Sprintf("    payloadOffset := int(binary.LittleEndian.Uint32(m[%d:]))", tableOffset))

	// Check if offset is valid (0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P("        return nil")
	g.P("    }")

	// Read size from payload
	g.P("    if len(m) < payloadOffset+4 {")
	g.P("        return nil")
	g.P("    }")
	g.P("    nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))")

	// Validate data length
	g.P("    if len(m) < payloadOffset+4+nestedSize {")
	g.P("        return nil")
	g.P("    }")

	// Return zero-copy slice of the nested message data as Raw type
	g.P(fmt.Sprintf("    return %s(m[payloadOffset+4 : payloadOffset+4+nestedSize])", rawType))
}

// generateRawNestedFieldSetter generates code to write a nested message field to Raw type
func generateRawNestedFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, msg *protogen.Message) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	msgType := g.QualifiedGoIdent(field.Message.GoIdent)

	g.P(fmt.Sprintf("    // Field %d (%s): nested message at table offset %d", fieldNum, goName, tableOffset))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(*m) < %d+4 {", tableOffset))
	g.P("        return fmt.Errorf(\"buffer too short for table entry\")")
	g.P("    }")

	// Read current offset and size
	g.P(fmt.Sprintf("    oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[%d:]))", tableOffset))
	g.P("    var oldNestedSize int")
	g.P("    if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {")
	g.P("        oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))")
	g.P("    }")

	// Calculate new nested message size (v is already Raw type, i.e., []byte)
	g.P("    newNestedSize := len(v)")

	// Check if we can update in-place
	g.P("    if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {")
	g.P("        // Update in-place (waste space)")
	g.P("        binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))")
	g.P("        copy((*m)[oldPayloadOffset+4:], v)")
	g.P("        return nil")
	g.P("    }")

	// Need to remarshal - unmarshal, update, marshal
	g.P("    // Need to remarshal: unmarshal, update, marshal")
	parentMsgType := msg.GoIdent.GoName
	g.P(fmt.Sprintf("    var temp %s", parentMsgType))
	g.P("    if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {")
	g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
	g.P("    }")

	// Update the field - need to convert Raw to regular message type
	g.P(fmt.Sprintf("    if temp.%s == nil {", goName))
	g.P(fmt.Sprintf("        temp.%s = &%s{}", goName, msgType))
	g.P("    }")
	g.P(fmt.Sprintf("    if err := temp.%s.UnmarshalSymphony([]byte(v)); err != nil {", goName))
	g.P("        return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
	g.P("    }")

	// Marshal again
	g.P("    newData, err := temp.MarshalSymphony()")
	g.P("    if err != nil {")
	g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
	g.P("    }")
	g.P("    *m = ", parentMsgType, "Raw(newData)")
	g.P("    return nil")
}

// generateRawRepeatedNestedFieldGetter generates code to read a repeated nested message field from Raw type
func generateRawRepeatedNestedFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName
	rawType := g.QualifiedGoIdent(field.Message.GoIdent) + "Raw"

	g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message at table offset %d", fieldNum, goName, tableOffset))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(m) < %d+4 {", tableOffset))
	g.P("        return nil")
	g.P("    }")

	// Read offset from table entry
	g.P(fmt.Sprintf("    payloadOffset := int(binary.LittleEndian.Uint32(m[%d:]))", tableOffset))

	// Check if offset is valid (0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P("        return nil")
	g.P("    }")

	// Read count from payload
	g.P("    if len(m) < payloadOffset+4 {")
	g.P("        return nil")
	g.P("    }")
	g.P("    count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))")

	// Allocate slice of Raw types
	g.P(fmt.Sprintf("    result := make([]%s, count)", rawType))

	// Read each nested message as Raw type (zero-copy)
	g.P("    currentOffset := payloadOffset + 4")
	g.P("    for i := 0; i < count; i++ {")
	g.P("        if len(m) < currentOffset+4 {")
	g.P("            return nil")
	g.P("        }")
	g.P("        nestedSize := int(binary.LittleEndian.Uint32(m[currentOffset:]))")
	g.P("        if len(m) < currentOffset+4+nestedSize {")
	g.P("            return nil")
	g.P("        }")
	g.P(fmt.Sprintf("        result[i] = %s(m[currentOffset+4 : currentOffset+4+nestedSize])", rawType))
	g.P("        currentOffset += 4 + nestedSize")
	g.P("    }")
	g.P("    return result")
}

// generateRawRepeatedNestedFieldSetter generates code to write a repeated nested message field to Raw type
func generateRawRepeatedNestedFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, msg *protogen.Message) {
	fieldNum := byte(field.Desc.Number())
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message at table offset %d", fieldNum, goName, tableOffset))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(*m) < %d+4 {", tableOffset))
	g.P("        return fmt.Errorf(\"buffer too short for table entry\")")
	g.P("    }")

	// Read current offset and calculate old total size
	g.P(fmt.Sprintf("    oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[%d:]))", tableOffset))
	g.P("    var oldCount int")
	g.P("    var oldDataSize int")
	g.P("    if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {")
	g.P("        oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))")
	g.P("        // Calculate old data size: 4 bytes count + for each item: 4 bytes size + data")
	g.P("        oldDataSize = 4")
	g.P("        currentOffset := oldPayloadOffset + 4")
	g.P("        for i := 0; i < oldCount; i++ {")
	g.P("            if len(*m) < currentOffset+4 {")
	g.P("                break")
	g.P("            }")
	g.P("            itemSize := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))")
	g.P("            oldDataSize += 4 + itemSize")
	g.P("            currentOffset += 4 + itemSize")
	g.P("        }")
	g.P("    }")

	// Calculate new count and total size
	g.P("    newCount := len(v)")
	g.P("    newDataSize := 4 // count")
	g.P("    for _, item := range v {")
	g.P("        newDataSize += 4 + len(item) // 4 bytes size + data")
	g.P("    }")

	// Check if we can update in-place
	g.P("    if oldPayloadOffset > 0 && newDataSize <= oldDataSize {")
	g.P("        // Update in-place (waste space)")
	g.P("        binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))")
	g.P("        currentOffset := oldPayloadOffset + 4")
	g.P("        for _, item := range v {")
	g.P("            itemSize := len(item)")
	g.P("            binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemSize))")
	g.P("            copy((*m)[currentOffset+4:], item)")
	g.P("            currentOffset += 4 + itemSize")
	g.P("        }")
	g.P("        return nil")
	g.P("    }")

	// Need to remarshal - unmarshal, update, marshal
	g.P("    // Need to remarshal: unmarshal, update, marshal")
	msgType := msg.GoIdent.GoName
	g.P(fmt.Sprintf("    var temp %s", msgType))
	g.P("    if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {")
	g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
	g.P("    }")

	// Update the field - convert Raw types to regular message types
	nestedMsgType := g.QualifiedGoIdent(field.Message.GoIdent)
	g.P(fmt.Sprintf("    temp.%s = make([]*%s, len(v))", goName, nestedMsgType))
	g.P("    for i, rawItem := range v {")
	g.P(fmt.Sprintf("        temp.%s[i] = &%s{}", goName, nestedMsgType))
	g.P(fmt.Sprintf("        if err := temp.%s[i].UnmarshalSymphony([]byte(rawItem)); err != nil {", goName))
	g.P("            return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
	g.P("        }")
	g.P("    }")

	// Marshal again
	g.P("    newData, err := temp.MarshalSymphony()")
	g.P("    if err != nil {")
	g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
	g.P("    }")
	g.P("    *m = ", msgType, "Raw(newData)")
	g.P("    return nil")
}
