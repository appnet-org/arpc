package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var (
	math = protogen.GoImportPath("math")
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}
			generateFile(plugin, file)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".syn.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-symphony. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P("import (\n\t\"encoding/binary\"\n\t\"fmt\"\n)")
	g.P()

	for _, message := range file.Messages {
		generateMessage(g, message)
	}
}

func generateMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	// 1. Standard Struct Implementation
	generateStructType(g, msg)

	// 2. Raw Type Implementation
	generateRawType(g, msg)
}

// ==========================================
// 1. Standard Struct Implementation
// ==========================================

func generateStructType(g *protogen.GeneratedFile, msg *protogen.Message) {
	// Generate helper marshal/unmarshal functions for public and private segments
	generatePublicMarshal(g, msg)
	generatePrivateMarshal(g, msg)
	generatePublicUnmarshal(g, msg)
	generatePrivateUnmarshal(g, msg)

	// Generate the main marshal/unmarshal that combines both segments
	generateStructMarshal(g, msg)
	generateStructUnmarshal(g, msg)
}

// generateSegmentMarshalFunction generates a helper function to marshal a specific segment (public or private)
func generateSegmentMarshalFunction(g *protogen.GeneratedFile, msg *protogen.Message, fields []*protogen.Field, segmentName string) {
	funcName := fmt.Sprintf("MarshalSymphony%s", segmentName)
	g.P(fmt.Sprintf("// %s marshals only the %s fields (without header)", funcName, strings.ToLower(segmentName)))
	g.P("func (m *", msg.GoIdent, ") ", funcName, "() ([]byte, error) {")

	if len(fields) == 0 {
		g.P("    return []byte{}, nil")
		g.P("}")
		g.P()
		return
	}

	// Calculate size
	g.P("    size := 0")
	tableSize := 0
	for _, field := range fields {
		if isFixedLengthField(field) {
			tableSize += getFieldSize(field)
		} else {
			tableSize += 4
		}
	}
	g.P(fmt.Sprintf("    size += %d // table", tableSize))

	// Calculate payload size
	for _, field := range fields {
		goName := field.GoName
		if isVariableLengthField(field) {
			g.P(fmt.Sprintf("    size += 4 + len(m.%s)", goName))
		} else if isRepeatedFixedLengthField(field) {
			fieldSize := getFieldSize(field)
			g.P(fmt.Sprintf("    size += 4 + %d*len(m.%s)", fieldSize, goName))
		} else if isRepeatedVariableLengthField(field) {
			g.P(fmt.Sprintf("    size += 4 // count for %s", goName))
			g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
			g.P("        size += 4 + len(item)")
			g.P("    }")
		} else if isNestedMessageField(field) {
			g.P(fmt.Sprintf("    if m.%s != nil {", goName))
			g.P(fmt.Sprintf("        nested, _ := m.%s.MarshalSymphony()", goName))
			g.P("        size += 4 + len(nested)")
			g.P("    }")
		} else if isRepeatedNestedMessageField(field) {
			g.P(fmt.Sprintf("    size += 4 // count for %s", goName))
			g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
			g.P("        nested, _ := item.MarshalSymphony()")
			g.P("        size += 4 + len(nested)")
			g.P("    }")
		}
	}

	g.P("    buf := make([]byte, size)")
	g.P("    dataLen := 0")
	g.P("    _ = dataLen")
	g.P("    count := 0")
	g.P("    _ = count")
	g.P("    currentOffset := 0")
	g.P("    _ = currentOffset")
	g.P("    tableStart := 0")
	g.P("    payloadStart := tableStart + ", fmt.Sprintf("%d", tableSize))
	g.P("    payloadOffset := 0")
	if len(fields) > 0 {
		g.P("    _ = payloadStart")
		g.P("    _ = payloadOffset")
	}
	g.P()

	generateSegmentMarshal(g, fields, "tableStart", "payloadStart", "payloadOffset")

	g.P("    return buf, nil")
	g.P("}")
	g.P()
}

// generatePublicMarshal generates a helper function to marshal only public fields
func generatePublicMarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	publicFields, _ := classifyFields(msg)
	generateSegmentMarshalFunction(g, msg, publicFields, "Public")
}

// generatePrivateMarshal generates a helper function to marshal only private fields
func generatePrivateMarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	_, privateFields := classifyFields(msg)
	generateSegmentMarshalFunction(g, msg, privateFields, "Private")
}

// generateSegmentUnmarshalFunction generates a helper function to unmarshal a specific segment (public or private)
func generateSegmentUnmarshalFunction(g *protogen.GeneratedFile, msg *protogen.Message, fields []*protogen.Field, segmentName string) {
	funcName := fmt.Sprintf("UnmarshalSymphony%s", segmentName)
	g.P(fmt.Sprintf("// %s unmarshals only the %s fields (without header)", funcName, strings.ToLower(segmentName)))
	g.P("func (m *", msg.GoIdent, ") ", funcName, "(data []byte) error {")

	if len(fields) == 0 {
		g.P("    return nil")
		g.P("}")
		g.P()
		return
	}

	g.P("    payloadOffset := 0")
	g.P("    _ = payloadOffset")
	g.P("    dataLen := 0")
	g.P("    _ = dataLen")
	g.P("    count := 0")
	g.P("    _ = count")
	g.P("    currentOffset := 0")
	g.P("    _ = currentOffset")
	g.P("    tableStart := 0")
	g.P("    _ = tableStart")
	g.P()

	generateSegmentUnmarshal(g, fields, "tableStart", "data")

	g.P("    return nil")
	g.P("}")
	g.P()
}

// generatePublicUnmarshal generates a helper function to unmarshal only public fields
func generatePublicUnmarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	publicFields, _ := classifyFields(msg)
	generateSegmentUnmarshalFunction(g, msg, publicFields, "Public")
}

// generatePrivateUnmarshal generates a helper function to unmarshal only private fields
func generatePrivateUnmarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	_, privateFields := classifyFields(msg)
	generateSegmentUnmarshalFunction(g, msg, privateFields, "Private")
}

func generateStructMarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	publicFields, privateFields := classifyFields(msg)

	g.P("func (m *", msg.GoIdent, ") MarshalSymphony() ([]byte, error) {")

	// Handle empty messages specially
	if len(msg.Fields) == 0 {
		g.P("    // Empty message - public segment with header only, empty private segment")
		g.P("    buf := make([]byte, 14) // 1 version + 12 reserved + 1 version for private")
		g.P("    buf[0] = 0x01 // public version")
		g.P("    binary.LittleEndian.PutUint32(buf[1:5], 13) // offset_to_private")
		g.P("    // service_name and method_name stay 0")
		g.P("    buf[13] = 0x01 // private version")
		g.P("    return buf, nil")
		g.P("}")
		g.P()
		return
	}

	// Calculate exact size
	publicTableSize := generateSizeCalculation(g, msg, "size", "m", 0)

	// Pre-allocate buffer with exact size
	g.P("    buf := make([]byte, size)")
	g.P()

	// Variables for tracking positions
	g.P("    dataLen := 0 // avoid no new variables warning")
	g.P("    _ = dataLen")
	g.P("    count := 0")
	g.P("    _ = count")
	g.P("    currentOffset := 0")
	g.P("    _ = currentOffset")
	g.P()

	// Write public segment
	g.P("    // === PUBLIC SEGMENT ===")
	g.P("    buf[0] = 0x01 // version byte")
	g.P()

	// Calculate public segment size (dynamically from 'size' variable)
	// We need to figure out where private segment starts
	// Public segment = 1(version) + 12(reserved) + publicTable + publicPayload
	g.P("    // Calculate offset to private segment")
	g.P("    publicSegmentSize := 13") // 1 + 12 for version and reserved

	// Calculate public table size
	for _, field := range publicFields {
		if isFixedLengthField(field) {
			g.P(fmt.Sprintf("    publicSegmentSize += %d // field %s", getFieldSize(field), field.GoName))
		} else {
			g.P("    publicSegmentSize += 4 // offset placeholder")
		}
	}

	// Add public payload sizes
	for _, field := range publicFields {
		goName := field.GoName
		fieldNum := field.Desc.Number()

		if isVariableLengthField(field) {
			g.P(fmt.Sprintf("    publicSegmentSize += 4 + len(m.%s) // field %d payload", goName, fieldNum))
		} else if isRepeatedFixedLengthField(field) {
			fieldSize := getFieldSize(field)
			g.P(fmt.Sprintf("    publicSegmentSize += 4 + %d*len(m.%s) // field %d payload", fieldSize, goName, fieldNum))
		} else if isRepeatedVariableLengthField(field) {
			g.P(fmt.Sprintf("    publicSegmentSize += 4 // field %d count", fieldNum))
			g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
			g.P("        publicSegmentSize += 4 + len(item)")
			g.P("    }")
		} else if isNestedMessageField(field) {
			g.P(fmt.Sprintf("    if m.%s != nil {", goName))
			g.P(fmt.Sprintf("        nestedData%d, _ := m.%s.MarshalSymphony()", fieldNum, goName))
			g.P(fmt.Sprintf("        publicSegmentSize += 4 + len(nestedData%d) // field %d payload", fieldNum, fieldNum))
			g.P("    }")
		} else if isRepeatedNestedMessageField(field) {
			g.P(fmt.Sprintf("    publicSegmentSize += 4 // field %d count", fieldNum))
			g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
			g.P("        nestedData, _ := item.MarshalSymphony()")
			g.P("        publicSegmentSize += 4 + len(nestedData)")
			g.P("    }")
		}
	}
	g.P()

	// Write reserved header
	g.P("    // Write reserved header")
	g.P("    binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private")
	g.P("    binary.LittleEndian.PutUint32(buf[5:9], 0) // service_name")
	g.P("    binary.LittleEndian.PutUint32(buf[9:13], 0) // method_name")
	g.P()

	// Write public fields
	g.P("    // Write public fields")
	g.P("    publicTableStart := 13")
	g.P("    publicPayloadStart := publicTableStart + ", fmt.Sprintf("%d", publicTableSize))
	g.P("    publicPayloadOffset := 0")
	g.P("    _ = publicPayloadStart")
	g.P("    _ = publicPayloadOffset")
	g.P()

	generateSegmentMarshal(g, publicFields, "publicTableStart", "publicPayloadStart", "publicPayloadOffset")

	// Write private segment
	g.P("    // === PRIVATE SEGMENT ===")
	g.P("    privateStart := publicSegmentSize")
	g.P("    buf[privateStart] = 0x01 // version byte")
	g.P()

	// Calculate private table size
	privateTableSize := 0
	for _, field := range privateFields {
		if isFixedLengthField(field) {
			privateTableSize += getFieldSize(field)
		} else {
			privateTableSize += 4
		}
	}

	g.P("    // Write private fields")
	g.P(fmt.Sprintf("    privateTableStart := privateStart + 1 // %d bytes table", privateTableSize))
	g.P("    privatePayloadStart := privateTableStart + ", fmt.Sprintf("%d", privateTableSize))
	g.P("    privatePayloadOffset := 0")
	g.P("    _ = privatePayloadStart")
	g.P("    _ = privatePayloadOffset")
	g.P()

	generateSegmentMarshal(g, privateFields, "privateTableStart", "privatePayloadStart", "privatePayloadOffset")

	g.P("    return buf, nil")
	g.P("}")
	g.P()
}

// generateSegmentMarshal generates code to marshal fields in a segment
func generateSegmentMarshal(g *protogen.GeneratedFile, fields []*protogen.Field, tableStartVar, payloadStartVar, payloadOffsetVar string) {
	if len(fields) == 0 {
		return
	}

	tableOffset := 0
	for _, field := range fields {
		if isFixedLengthField(field) {
			fieldSize := getFieldSize(field)
			generateFixedFieldMarshal(g, field, tableStartVar, tableOffset)
			tableOffset += fieldSize
		} else if isVariableLengthField(field) {
			generateVariableFieldMarshal(g, field, tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar)
			tableOffset += 4
		} else if isRepeatedFixedLengthField(field) {
			generateRepeatedFixedFieldMarshal(g, field, tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar)
			tableOffset += 4
		} else if isRepeatedVariableLengthField(field) {
			generateRepeatedVariableFieldMarshal(g, field, tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar)
			tableOffset += 4
		} else if isNestedMessageField(field) {
			generateNestedFieldMarshal(g, field, tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar)
			tableOffset += 4
		} else if isRepeatedNestedMessageField(field) {
			generateRepeatedNestedFieldMarshal(g, field, tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar)
			tableOffset += 4
		}
	}
}

// Helper function to generate remarshal logic for setters
func generateRemarshalLogic(g *protogen.GeneratedFile, msg *protogen.Message, goName string, isPublic bool) {
	msgType := msg.GoIdent.GoName

	if isPublic {
		// For public fields: unmarshal complete (will only get public fields), update, marshal complete, truncate
		g.P("    // Need to remarshal: unmarshal, update, marshal, truncate to public-only")
		g.P(fmt.Sprintf("    var temp %s", msgType))
		g.P("    // Create a fake complete buffer by appending a minimal private segment")
		g.P("    // Calculate private table size")

		// Calculate how many bytes the private table needs
		_, privateFields := classifyFields(msg)
		privateTableSize := 0
		for _, field := range privateFields {
			if isFixedLengthField(field) {
				privateTableSize += getFieldSize(field)
			} else {
				privateTableSize += 4 // offset for variable/repeated/nested fields
			}
		}

		g.P(fmt.Sprintf("    privateTableSize := %d // bytes needed for empty private table", privateTableSize))
		g.P("    fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table")
		g.P("    copy(fakeComplete, *m)")
		g.P("    // Update offsetToPrivate to point to the appended private segment")
		g.P("    binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))")
		g.P("    fakeComplete[len(*m)] = 0x01 // private segment version")
		g.P("    if err := temp.UnmarshalSymphony(fakeComplete); err != nil {")
		g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
		g.P("    }")
		g.P(fmt.Sprintf("    temp.%s = v", goName))
		g.P("    fullData, err := temp.MarshalSymphony()")
		g.P("    if err != nil {")
		g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
		g.P("    }")
		g.P("    offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))")
		g.P("    *m = ", msgType, "Raw(fullData[:offsetToPrivate])")
		g.P("    return nil")
	} else {
		// For private fields, unmarshal complete buffer, update, and marshal complete buffer
		g.P("    // Need to remarshal: unmarshal, update, marshal")
		g.P(fmt.Sprintf("    var temp %s", msgType))
		g.P("    if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {")
		g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
		g.P("    }")
		g.P(fmt.Sprintf("    temp.%s = v", goName))
		g.P("    newData, err := temp.MarshalSymphony()")
		g.P("    if err != nil {")
		g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
		g.P("    }")
		g.P("    *m = ", msgType, "Raw(newData)")
		g.P("    return nil")
	}
}

func generateFixedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): fixed-length (%d bytes)", fieldNum, goName, fieldSize))

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("    if m.%s {", goName))
		g.P(fmt.Sprintf("        buf[%s+%d] = 1", tableStartVar, tableOffset))
		g.P("    } else {")
		g.P(fmt.Sprintf("        buf[%s+%d] = 0", tableStartVar, tableOffset))
		g.P("    }")
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(m.%s))", tableStartVar, tableOffset, goName))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], m.%s)", tableStartVar, tableOffset, goName))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64(buf[%s+%d:], uint64(m.%s))", tableStartVar, tableOffset, goName))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64(buf[%s+%d:], m.%s)", tableStartVar, tableOffset, goName))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32bits"))
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], %s(m.%s))", tableStartVar, tableOffset, mathQualified, goName))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64bits"))
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64(buf[%s+%d:], %s(m.%s))", tableStartVar, tableOffset, mathQualified, goName))
	}
	g.P()
}

func generateVariableFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, payloadStartVar, payloadOffsetVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): variable-length", fieldNum, goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(%s+%s))", tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    dataLen = len(m.%s)", goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%s:], uint32(dataLen))", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    copy(buf[%s+%s+4:], m.%s)", payloadStartVar, payloadOffsetVar, goName))
	g.P(fmt.Sprintf("    %s += 4 + len(m.%s)", payloadOffsetVar, goName))
	g.P()
}

func generateRepeatedFixedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, payloadStartVar, payloadOffsetVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length", fieldNum, goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(%s+%s))", tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    count = len(m.%s)", goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%s:], uint32(count))", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    for i, v := range m.%s {", goName))

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P("        if v {")
		g.P(fmt.Sprintf("            buf[%s+%s+4+%d*i] = 1", payloadStartVar, payloadOffsetVar, fieldSize))
		g.P("        } else {")
		g.P(fmt.Sprintf("            buf[%s+%s+4+%d*i] = 0", payloadStartVar, payloadOffsetVar, fieldSize))
		g.P("        }")
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%s+4+%d*i:], uint32(v))", payloadStartVar, payloadOffsetVar, fieldSize))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%s+4+%d*i:], v)", payloadStartVar, payloadOffsetVar, fieldSize))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(buf[%s+%s+4+%d*i:], uint64(v))", payloadStartVar, payloadOffsetVar, fieldSize))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(buf[%s+%s+4+%d*i:], v)", payloadStartVar, payloadOffsetVar, fieldSize))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32bits"))
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%s+4+%d*i:], %s(v))", payloadStartVar, payloadOffsetVar, fieldSize, mathQualified))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64bits"))
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(buf[%s+%s+4+%d*i:], %s(v))", payloadStartVar, payloadOffsetVar, fieldSize, mathQualified))
	}
	g.P("    }")
	g.P(fmt.Sprintf("    %s += 4 + %d*len(m.%s)", payloadOffsetVar, fieldSize, goName))
	g.P()
}

func generateRepeatedVariableFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, payloadStartVar, payloadOffsetVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length", fieldNum, goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(%s+%s))", tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    count = len(m.%s)", goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%s:], uint32(count))", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    currentOffset = %s + %s + 4", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
	g.P("        itemLen := len(item)")
	g.P("        binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))")
	g.P("        copy(buf[currentOffset+4:], item)")
	g.P("        currentOffset += 4 + itemLen")
	g.P("    }")
	g.P(fmt.Sprintf("    %s += 4 // count", payloadOffsetVar))
	g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
	g.P(fmt.Sprintf("        %s += 4 + len(item)", payloadOffsetVar))
	g.P("    }")
	g.P()
}

func generateNestedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, payloadStartVar, payloadOffsetVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): nested message", fieldNum, goName))
	g.P(fmt.Sprintf("    if m.%s != nil {", goName))
	g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(%s+%s))", tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("        nestedData, err := m.%s.MarshalSymphony()", goName))
	g.P("        if err != nil {")
	g.P("            return nil, fmt.Errorf(\"failed to marshal nested message: %w\", err)")
	g.P("        }")
	g.P("        nestedSize := len(nestedData)")
	g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%s:], uint32(nestedSize))", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("        copy(buf[%s+%s+4:], nestedData)", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("        %s += 4 + nestedSize", payloadOffsetVar))
	g.P("    } else {")
	g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%d:], 0)", tableStartVar, tableOffset))
	g.P("    }")
	g.P()
}

func generateRepeatedNestedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, payloadStartVar, payloadOffsetVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message", fieldNum, goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(%s+%s))", tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    count = len(m.%s)", goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%s:], uint32(count))", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    %s += 4", payloadOffsetVar))
	g.P(fmt.Sprintf("    currentOffset = %s + %s", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
	g.P("        nestedData, err := item.MarshalSymphony()")
	g.P("        if err != nil {")
	g.P("            return nil, fmt.Errorf(\"failed to marshal nested message: %w\", err)")
	g.P("        }")
	g.P("        nestedSize := len(nestedData)")
	g.P("        binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))")
	g.P("        copy(buf[currentOffset+4:], nestedData)")
	g.P("        currentOffset += 4 + nestedSize")
	g.P(fmt.Sprintf("        %s += 4 + nestedSize", payloadOffsetVar))
	g.P("    }")
	g.P()
}

func generateStructUnmarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	publicFields, privateFields := classifyFields(msg)

	g.P("func (m *", msg.GoIdent, ") UnmarshalSymphony(data []byte) error {")

	// Handle empty messages specially
	if len(msg.Fields) == 0 {
		g.P("    // Empty message - just validate version bytes")
		g.P("    if len(data) < 14 {")
		g.P("        return fmt.Errorf(\"invalid data: too short\")")
		g.P("    }")
		g.P("    if data[0] != 0x01 {")
		g.P("        return fmt.Errorf(\"invalid data: wrong public version\")")
		g.P("    }")
		g.P("    offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))")
		g.P("    if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {")
		g.P("        return fmt.Errorf(\"missing private segment\")")
		g.P("    }")
		g.P("    return nil")
		g.P("}")
		g.P()
		return
	}

	// Check minimum size and validate public segment
	g.P("    if len(data) < 13 {")
	g.P("        return fmt.Errorf(\"invalid data: too short\")")
	g.P("    }")
	g.P()
	g.P("    // Validate public segment version")
	g.P("    if data[0] != 0x01 {")
	g.P("        return fmt.Errorf(\"invalid data: wrong public version\")")
	g.P("    }")
	g.P()
	g.P("    // Read reserved header")
	g.P("    offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))")
	g.P("    // service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet")
	g.P("    // method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet")
	g.P()
	g.P("    // Assert private segment exists")
	g.P("    if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {")
	g.P("        return fmt.Errorf(\"missing private segment\")")
	g.P("    }")
	g.P()

	// Variables
	g.P("    payloadOffset := 0")
	g.P("    _ = payloadOffset")
	g.P("    dataLen := 0")
	g.P("    _ = dataLen")
	g.P("    count := 0")
	g.P("    _ = count")
	g.P("    currentOffset := 0")
	g.P("    _ = currentOffset")
	g.P()

	// Unmarshal public fields
	g.P("    // === PUBLIC FIELDS ===")
	g.P("    publicTableStart := 13")
	g.P("    _ = publicTableStart")
	generateSegmentUnmarshal(g, publicFields, "publicTableStart", "data")

	// Unmarshal private fields
	g.P("    // === PRIVATE FIELDS ===")
	g.P("    privateTableStart := offsetToPrivate + 1")
	g.P("    _ = privateTableStart")
	generateSegmentUnmarshal(g, privateFields, "privateTableStart", "data")

	g.P("    return nil")
	g.P("}")
	g.P()
}

// generateSegmentUnmarshal generates code to unmarshal fields from a segment
func generateSegmentUnmarshal(g *protogen.GeneratedFile, fields []*protogen.Field, tableStartVar, dataVar string) {
	if len(fields) == 0 {
		return
	}

	tableOffset := 0
	for _, field := range fields {
		if isFixedLengthField(field) {
			fieldSize := getFieldSize(field)
			generateFixedFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar)
			tableOffset += fieldSize
		} else if isVariableLengthField(field) {
			generateVariableFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar)
			tableOffset += 4
		} else if isRepeatedFixedLengthField(field) {
			generateRepeatedFixedFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar)
			tableOffset += 4
		} else if isRepeatedVariableLengthField(field) {
			generateRepeatedVariableFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar)
			tableOffset += 4
		} else if isNestedMessageField(field) {
			generateNestedFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar)
			tableOffset += 4
		} else if isRepeatedNestedMessageField(field) {
			generateRepeatedNestedFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar)
			tableOffset += 4
		}
	}
}

func generateFixedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): fixed-length (%d bytes)", fieldNum, goName, fieldSize))
	g.P(fmt.Sprintf("    if len(%s) < %s+%d {", dataVar, tableStartVar, tableOffset+fieldSize))
	g.P("        return fmt.Errorf(\"invalid data: too short for field\")")
	g.P("    }")

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("    m.%s = %s[%s+%d] != 0", goName, dataVar, tableStartVar, tableOffset))
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("    m.%s = int32(binary.LittleEndian.Uint32(%s[%s+%d:]))", goName, dataVar, tableStartVar, tableOffset))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("    m.%s = binary.LittleEndian.Uint32(%s[%s+%d:])", goName, dataVar, tableStartVar, tableOffset))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("    m.%s = int64(binary.LittleEndian.Uint64(%s[%s+%d:]))", goName, dataVar, tableStartVar, tableOffset))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("    m.%s = binary.LittleEndian.Uint64(%s[%s+%d:])", goName, dataVar, tableStartVar, tableOffset))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32frombits"))
		g.P(fmt.Sprintf("    m.%s = %s(binary.LittleEndian.Uint32(%s[%s+%d:]))", goName, mathQualified, dataVar, tableStartVar, tableOffset))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64frombits"))
		g.P(fmt.Sprintf("    m.%s = %s(binary.LittleEndian.Uint64(%s[%s+%d:]))", goName, mathQualified, dataVar, tableStartVar, tableOffset))
	}
	g.P()
}

func generateVariableFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): variable-length", fieldNum, goName))
	g.P(fmt.Sprintf("    if len(%s) >= %s+%d+4 {", dataVar, tableStartVar, tableOffset))
	g.P(fmt.Sprintf("        payloadOffset = int(binary.LittleEndian.Uint32(%s[%s+%d:]))", dataVar, tableStartVar, tableOffset))
	g.P("        if payloadOffset > 0 && len(data) >= payloadOffset+4 {")
	g.P("            dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P("            if len(data) >= payloadOffset+4+dataLen {")
	if field.Desc.Kind() == protoreflect.StringKind {
		g.P(fmt.Sprintf("                m.%s = string(data[payloadOffset+4 : payloadOffset+4+dataLen])", goName))
	} else {
		g.P(fmt.Sprintf("                m.%s = make([]byte, dataLen)", goName))
		g.P(fmt.Sprintf("                copy(m.%s, data[payloadOffset+4:payloadOffset+4+dataLen])", goName))
	}
	g.P("            }")
	g.P("        }")
	g.P("    }")
	g.P()
}

func generateRepeatedFixedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length", fieldNum, goName))
	g.P(fmt.Sprintf("    if len(%s) >= %s+%d+4 {", dataVar, tableStartVar, tableOffset))
	g.P(fmt.Sprintf("        payloadOffset = int(binary.LittleEndian.Uint32(%s[%s+%d:]))", dataVar, tableStartVar, tableOffset))
	g.P("        if payloadOffset > 0 && len(data) >= payloadOffset+4 {")
	g.P("            count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P(fmt.Sprintf("            if len(data) >= payloadOffset+4+count*%d {", fieldSize))
	g.P(fmt.Sprintf("                m.%s = make([]%s, count)", goName, getGoTypeBase(g, field)))
	g.P("                for i := 0; i < count; i++ {")

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("                    m.%s[i] = data[payloadOffset+4+%d*i] != 0", goName, fieldSize))
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("                    m.%s[i] = int32(binary.LittleEndian.Uint32(data[payloadOffset+4+%d*i:]))", goName, fieldSize))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("                    m.%s[i] = binary.LittleEndian.Uint32(data[payloadOffset+4+%d*i:])", goName, fieldSize))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("                    m.%s[i] = int64(binary.LittleEndian.Uint64(data[payloadOffset+4+%d*i:]))", goName, fieldSize))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("                    m.%s[i] = binary.LittleEndian.Uint64(data[payloadOffset+4+%d*i:])", goName, fieldSize))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32frombits"))
		g.P(fmt.Sprintf("                    m.%s[i] = %s(binary.LittleEndian.Uint32(data[payloadOffset+4+%d*i:]))", goName, mathQualified, fieldSize))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64frombits"))
		g.P(fmt.Sprintf("                    m.%s[i] = %s(binary.LittleEndian.Uint64(data[payloadOffset+4+%d*i:]))", goName, mathQualified, fieldSize))
	}

	g.P("                }")
	g.P("            }")
	g.P("        }")
	g.P("    }")
	g.P()
}

func generateRepeatedVariableFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length", fieldNum, goName))
	g.P(fmt.Sprintf("    if len(%s) >= %s+%d+4 {", dataVar, tableStartVar, tableOffset))
	g.P(fmt.Sprintf("        payloadOffset = int(binary.LittleEndian.Uint32(%s[%s+%d:]))", dataVar, tableStartVar, tableOffset))
	g.P("        if payloadOffset > 0 && len(data) >= payloadOffset+4 {")
	g.P("            count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P(fmt.Sprintf("            m.%s = make([]%s, 0, count)", goName, getGoTypeBase(g, field)))
	g.P("            currentOffset = payloadOffset + 4")
	g.P("            for i := 0; i < count; i++ {")
	g.P("                if len(data) >= currentOffset+4 {")
	g.P("                    itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))")
	g.P("                    if len(data) >= currentOffset+4+itemLen {")
	if field.Desc.Kind() == protoreflect.StringKind {
		g.P(fmt.Sprintf("                        m.%s = append(m.%s, string(data[currentOffset+4:currentOffset+4+itemLen]))", goName, goName))
	} else {
		g.P("                        itemData := make([]byte, itemLen)")
		g.P("                        copy(itemData, data[currentOffset+4:currentOffset+4+itemLen])")
		g.P(fmt.Sprintf("                        m.%s = append(m.%s, itemData)", goName, goName))
	}
	g.P("                        currentOffset += 4 + itemLen")
	g.P("                    }")
	g.P("                }")
	g.P("            }")
	g.P("        }")
	g.P("    }")
	g.P()
}

func generateNestedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	msgType := g.QualifiedGoIdent(field.Message.GoIdent)

	g.P(fmt.Sprintf("    // Field %d (%s): nested message", fieldNum, goName))
	g.P(fmt.Sprintf("    if len(%s) >= %s+%d+4 {", dataVar, tableStartVar, tableOffset))
	g.P(fmt.Sprintf("        payloadOffset = int(binary.LittleEndian.Uint32(%s[%s+%d:]))", dataVar, tableStartVar, tableOffset))
	g.P("        if payloadOffset > 0 && len(data) >= payloadOffset+4 {")
	g.P("            dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P("            if len(data) >= payloadOffset+4+dataLen {")
	g.P(fmt.Sprintf("                m.%s = &%s{}", goName, msgType))
	g.P(fmt.Sprintf("                if err := m.%s.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {", goName))
	g.P("                    return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
	g.P("                }")
	g.P("            }")
	g.P("        }")
	g.P("    }")
	g.P()
}

func generateRepeatedNestedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	msgType := g.QualifiedGoIdent(field.Message.GoIdent)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message", fieldNum, goName))
	g.P(fmt.Sprintf("    if len(%s) >= %s+%d+4 {", dataVar, tableStartVar, tableOffset))
	g.P(fmt.Sprintf("        payloadOffset = int(binary.LittleEndian.Uint32(%s[%s+%d:]))", dataVar, tableStartVar, tableOffset))
	g.P("        if payloadOffset > 0 && len(data) >= payloadOffset+4 {")
	g.P("            count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P(fmt.Sprintf("            m.%s = make([]*%s, 0, count)", goName, msgType))
	g.P("            currentOffset = payloadOffset + 4")
	g.P("            for i := 0; i < count; i++ {")
	g.P("                if len(data) >= currentOffset+4 {")
	g.P("                    itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))")
	g.P("                    if len(data) >= currentOffset+4+itemLen {")
	g.P(fmt.Sprintf("                        item := &%s{}", msgType))
	g.P("                        if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {")
	g.P("                            return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
	g.P("                        }")
	g.P(fmt.Sprintf("                        m.%s = append(m.%s, item)", goName, goName))
	g.P("                        currentOffset += 4 + itemLen")
	g.P("                    }")
	g.P("                }")
	g.P("            }")
	g.P("        }")
	g.P("    }")
	g.P()
}

// ==========================================
// 2. Raw Type Implementation
// ==========================================

func generateRawType(g *protogen.GeneratedFile, msg *protogen.Message) {
	rawName := msg.GoIdent.GoName + "Raw"

	// Type Definition
	g.P("type ", rawName, " []byte")
	g.P()

	// Marshal/Unmarshal for Raw Type
	generateRawMarshal(g, rawName)
	generateRawUnmarshal(g, rawName)

	// Accessors for Raw Type
	generateRawGetters(g, msg, rawName)
	generateRawSetters(g, msg, rawName)
}

func generateRawMarshal(g *protogen.GeneratedFile, rawName string) {
	g.P("func (m ", rawName, ") MarshalSymphony() ([]byte, error) {")
	g.P("    return []byte(m), nil")
	g.P("}")
	g.P()
}

func generateRawUnmarshal(g *protogen.GeneratedFile, rawName string) {
	g.P("func (m *", rawName, ") UnmarshalSymphony(data []byte) error {")
	g.P("    *m = ", rawName, "(data)")
	g.P("    return nil")
	g.P("}")
	g.P()
}

func generateRawGetters(g *protogen.GeneratedFile, msg *protogen.Message, rawName string) {
	publicFields, privateFields := classifyFields(msg)
	// Public fields start at offset 13 (1 version + 12 reserved)
	publicOffsets := calculateFieldOffsets(publicFields, 13)
	// Private fields start at offset 1 (relative to private segment start)
	privateOffsets := calculateFieldOffsets(privateFields, 1)

	for _, field := range msg.Fields {
		isPublic := isPublicField(field)
		var offset int
		if isPublic {
			offset = publicOffsets[field]
		} else {
			offset = privateOffsets[field]
		}

		goType := getGoType(g, field, true) // true = Raw type
		g.P("func (m ", rawName, ") Get", field.GoName, "() ", goType, " {")

		// Private fields must assert complete buffer
		if !isPublic {
			g.P("    // ASSERT: Private field requires complete buffer")
			g.P("    if len(m) < 5 {")
			g.P("        panic(\"private getter called on invalid buffer\")")
			g.P("    }")
			g.P("    offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))")
			g.P("    if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {")
			g.P("        panic(\"private getter called on public-only buffer\")")
			g.P("    }")
		}

		if isFixedLengthField(field) {
			generateRawFixedFieldGetter(g, field, offset, isPublic)
		} else if isVariableLengthField(field) {
			generateRawVariableFieldGetter(g, field, offset, isPublic)
		} else if isRepeatedFixedLengthField(field) {
			generateRawRepeatedFixedFieldGetter(g, field, offset, isPublic)
		} else if isRepeatedVariableLengthField(field) {
			generateRawRepeatedVariableFieldGetter(g, field, offset, isPublic)
		} else if isNestedMessageField(field) {
			generateRawNestedFieldGetter(g, field, offset, isPublic)
		} else if isRepeatedNestedMessageField(field) {
			generateRawRepeatedNestedFieldGetter(g, field, offset, isPublic)
		} else {
			panic(fmt.Sprintf("Unknown field type: %s", field.GoName))
		}

		g.P("}")
		g.P()
	}
}

func generateRawSetters(g *protogen.GeneratedFile, msg *protogen.Message, rawName string) {
	publicFields, privateFields := classifyFields(msg)
	// Public fields start at offset 13 (1 version + 12 reserved)
	publicOffsets := calculateFieldOffsets(publicFields, 13)
	// Private fields start at offset 1 (relative to private segment start)
	privateOffsets := calculateFieldOffsets(privateFields, 1)

	for _, field := range msg.Fields {
		isPublic := isPublicField(field)
		var offset int
		if isPublic {
			offset = publicOffsets[field]
		} else {
			offset = privateOffsets[field]
		}

		goType := getGoType(g, field, true) // true = Raw type
		g.P("func (m *", rawName, ") Set", field.GoName, "(v ", goType, ") error {")

		// Public fields must assert public-only buffer
		if isPublic {
			g.P("    // ASSERT: Public field setter requires public-only buffer")
			g.P("    if len(*m) >= 5 {")
			g.P("        offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))")
			g.P("        if offsetToPrivate < len(*m) && (*m)[offsetToPrivate] == 0x01 {")
			g.P("            panic(\"public setter called on complete buffer\")")
			g.P("        }")
			g.P("    }")
		} else {
			// Private fields must assert complete buffer
			g.P("    // ASSERT: Private field setter requires complete buffer")
			g.P("    if len(*m) < 5 {")
			g.P("        panic(\"private setter called on invalid buffer\")")
			g.P("    }")
			g.P("    offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))")
			g.P("    if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {")
			g.P("        panic(\"private setter called on public-only buffer\")")
			g.P("    }")
		}

		if isFixedLengthField(field) {
			generateRawFixedFieldSetter(g, field, offset, isPublic)
		} else if isVariableLengthField(field) {
			generateRawVariableFieldSetter(g, field, offset, msg, isPublic)
		} else if isRepeatedFixedLengthField(field) {
			generateRawRepeatedFixedFieldSetter(g, field, offset, msg, isPublic)
		} else if isRepeatedVariableLengthField(field) {
			generateRawRepeatedVariableFieldSetter(g, field, offset, msg, isPublic)
		} else if isNestedMessageField(field) {
			generateRawNestedFieldSetter(g, field, offset, msg, isPublic)
		} else if isRepeatedNestedMessageField(field) {
			generateRawRepeatedNestedFieldSetter(g, field, offset, msg, isPublic)
		} else {
			panic(fmt.Sprintf("Unknown field type: %s", field.GoName))
		}

		g.P("}")
		g.P()
	}
}

// ==========================================
// Helpers
// ==========================================

// getGoType returns the Go type for a field.
// isRaw determines if we should return the "Raw" version of nested messages (e.g. LeafRaw vs *Leaf)
func getGoType(g *protogen.GeneratedFile, field *protogen.Field, isRaw bool) string {
	typ := getGoTypeBase(g, field, isRaw)
	if field.Desc.IsList() {
		return "[]" + typ
	}
	return typ
}

// getGoTypeBase returns the base Go type without the [] prefix for repeated fields
func getGoTypeBase(g *protogen.GeneratedFile, field *protogen.Field, isRaw ...bool) string {
	useRaw := false
	if len(isRaw) > 0 {
		useRaw = isRaw[0]
	}

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		return "int32"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Uint64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		if useRaw {
			// For Raw types, nested fields are also Raw types (e.g. LeafRaw)
			return g.QualifiedGoIdent(field.Message.GoIdent) + "Raw"
		}
		// For Standard structs, nested fields are pointers to structs (e.g. *Leaf)
		return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
	default:
		return "interface{}"
	}
}

func getZeroValue(field *protogen.Field) string {
	if field.Desc.IsList() {
		return "nil"
	}
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "false"
	case protoreflect.StringKind:
		return "\"\""
	case protoreflect.MessageKind, protoreflect.BytesKind:
		return "nil"
	default:
		return "0"
	}
}

// Helper functions for field classification and size calculation

// isPublicField checks if field has is_public = true option
func isPublicField(field *protogen.Field) bool {
	if field.Desc.Options() == nil {
		return false
	}

	// Check the string representation as a workaround
	// Extensions appear in the format: "50001:1" where 50001 is the extension field number
	// and 1 means true (boolean true)
	optsStr := fmt.Sprintf("%v", field.Desc.Options())

	// Check if the options string contains "50001:1" (is_public = true)
	if optsStr != "" && optsStr != "<nil>" {
		// The extension 50001 with value 1 (true) appears as "50001:1"
		return containsSubstring(optsStr, "50001:1")
	}

	return false
}

func containsSubstring(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// classifyFields splits fields into public and private lists, preserving declaration order
func classifyFields(msg *protogen.Message) (public, private []*protogen.Field) {
	for _, field := range msg.Fields {
		if isPublicField(field) {
			public = append(public, field)
		} else {
			private = append(private, field)
		}
	}
	return
}

// isFixedLengthField returns true if the field has a fixed size
func isFixedLengthField(field *protogen.Field) bool {
	if field.Desc.IsList() {
		return false // Repeated fields are variable-length (even if elements are fixed)
	}
	switch field.Desc.Kind() {
	case protoreflect.BoolKind, protoreflect.Int32Kind, protoreflect.Int64Kind,
		protoreflect.Uint32Kind, protoreflect.Uint64Kind,
		protoreflect.FloatKind, protoreflect.DoubleKind, protoreflect.EnumKind:
		return true
	default:
		return false
	}
}

// getFieldSize returns the size in bytes of a fixed-length field
func getFieldSize(field *protogen.Field) int {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return 1
	case protoreflect.Int32Kind, protoreflect.Uint32Kind, protoreflect.FloatKind, protoreflect.EnumKind:
		return 4
	case protoreflect.Int64Kind, protoreflect.Uint64Kind, protoreflect.DoubleKind:
		return 8
	default:
		panic(fmt.Sprintf("unknown fixed-length field kind: %s", field.Desc.Kind()))
	}
}

// calculateFieldOffsets calculates the table offset for each field based on field list
// tableStart is the offset where the table begins (after version and any header)
func calculateFieldOffsets(fields []*protogen.Field, tableStart int) map[*protogen.Field]int {
	offsets := make(map[*protogen.Field]int)
	offset := tableStart

	for _, field := range fields {
		offsets[field] = offset
		if isFixedLengthField(field) {
			offset += getFieldSize(field)
		} else {
			offset += 4 // 32-bit placeholder for variable-length fields
		}
	}

	return offsets
}

// generateRawFixedFieldGetter generates code to read a fixed-length field from Raw type
func generateRawFixedFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): fixed-length (%d bytes)", fieldNum, goName, fieldSize))
	g.P(fmt.Sprintf("    if len(m) < %s+%d {", offsetExpr, fieldSize))
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("    return m[%s] != 0", offsetExpr))
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("    return int32(binary.LittleEndian.Uint32(m[%s:]))", offsetExpr))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("    return binary.LittleEndian.Uint32(m[%s:])", offsetExpr))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("    return int64(binary.LittleEndian.Uint64(m[%s:]))", offsetExpr))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("    return binary.LittleEndian.Uint64(m[%s:])", offsetExpr))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32frombits"))
		g.P(fmt.Sprintf("    return %s(binary.LittleEndian.Uint32(m[%s:]))", mathQualified, offsetExpr))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64frombits"))
		g.P(fmt.Sprintf("    return %s(binary.LittleEndian.Uint64(m[%s:]))", mathQualified, offsetExpr))
	}
}

// generateRawFixedFieldSetter generates code to write a fixed-length field to Raw type
func generateRawFixedFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): fixed-length (%d bytes)", fieldNum, goName, fieldSize))
	g.P(fmt.Sprintf("    if len(*m) < %s+%d {", offsetExpr, fieldSize))
	g.P("        return fmt.Errorf(\"buffer too short\")")
	g.P("    }")

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P("    if v {")
		g.P(fmt.Sprintf("        (*m)[%s] = 1", offsetExpr))
		g.P("    } else {")
		g.P(fmt.Sprintf("        (*m)[%s] = 0", offsetExpr))
		g.P("    }")
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32((*m)[%s:], uint32(v))", offsetExpr))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32((*m)[%s:], v)", offsetExpr))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64((*m)[%s:], uint64(v))", offsetExpr))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64((*m)[%s:], v)", offsetExpr))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32bits"))
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32((*m)[%s:], %s(v))", offsetExpr, mathQualified))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64bits"))
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64((*m)[%s:], %s(v))", offsetExpr, mathQualified))
	}
	g.P("    return nil")
}

// isVariableLengthField returns true if the field is a variable-length field (string or bytes, singular, not nested)
func isVariableLengthField(field *protogen.Field) bool {
	if field.Desc.IsList() {
		return false // Repeated fields handled separately
	}
	if field.Desc.Kind() == protoreflect.MessageKind {
		return false // Nested messages handled separately
	}
	return field.Desc.Kind() == protoreflect.StringKind || field.Desc.Kind() == protoreflect.BytesKind
}

// isRepeatedFixedLengthField returns true if the field is a repeated fixed-length field
func isRepeatedFixedLengthField(field *protogen.Field) bool {
	if !field.Desc.IsList() {
		return false
	}
	if field.Desc.Kind() == protoreflect.MessageKind {
		return false // Repeated nested messages handled separately
	}
	switch field.Desc.Kind() {
	case protoreflect.BoolKind, protoreflect.Int32Kind, protoreflect.Int64Kind,
		protoreflect.Uint32Kind, protoreflect.Uint64Kind,
		protoreflect.FloatKind, protoreflect.DoubleKind, protoreflect.EnumKind:
		return true
	default:
		return false
	}
}

// isRepeatedVariableLengthField returns true if the field is a repeated variable-length field (repeated string or bytes)
func isRepeatedVariableLengthField(field *protogen.Field) bool {
	if !field.Desc.IsList() {
		return false
	}
	return field.Desc.Kind() == protoreflect.StringKind || field.Desc.Kind() == protoreflect.BytesKind
}

// isNestedMessageField returns true if the field is a singular nested message
func isNestedMessageField(field *protogen.Field) bool {
	if field.Desc.IsList() {
		return false // Repeated nested messages handled separately
	}
	return field.Desc.Kind() == protoreflect.MessageKind
}

// isRepeatedNestedMessageField returns true if the field is a repeated nested message
func isRepeatedNestedMessageField(field *protogen.Field) bool {
	return field.Desc.IsList() && field.Desc.Kind() == protoreflect.MessageKind
}

// generateSegmentSizeCalculation generates code to calculate size for a segment (public or private)
// Returns the table size for the segment
func generateSegmentSizeCalculation(g *protogen.GeneratedFile, fields []*protogen.Field, sizeVar, msgVar string, depth int, includeVersion bool) int {
	// Use unique variable name for nested size calculations
	nestedSizeVar := sizeVar
	if depth > 0 {
		nestedSizeVar = fmt.Sprintf("nestedSize%d", depth)
	}

	// Add version byte if this is a top-level segment
	if includeVersion {
		g.P(fmt.Sprintf("    %s += 1 // version byte", nestedSizeVar))
	}

	// Calculate table size
	tableSize := 0
	for _, field := range fields {
		if isFixedLengthField(field) {
			tableSize += getFieldSize(field)
		} else {
			tableSize += 4 // 32-bit offset for variable-length fields
		}
	}

	if tableSize > 0 {
		g.P(fmt.Sprintf("    %s += %d // table entries", nestedSizeVar, tableSize))
	}

	// Calculate payload size for variable-length fields
	for _, field := range fields {
		fieldNum := field.Desc.Number()
		goName := field.GoName

		if isVariableLengthField(field) {
			g.P(fmt.Sprintf("    // Field %d (%s): variable-length payload", fieldNum, goName))
			g.P(fmt.Sprintf("    %s += 4 + len(%s.%s) // 4 bytes length prefix + data", nestedSizeVar, msgVar, goName))
		} else if isRepeatedFixedLengthField(field) {
			fieldSize := getFieldSize(field)
			g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length payload", fieldNum, goName))
			g.P(fmt.Sprintf("    %s += 4 + %d*len(%s.%s) // 4 bytes count + data", nestedSizeVar, fieldSize, msgVar, goName))
		} else if isRepeatedVariableLengthField(field) {
			g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length payload", fieldNum, goName))
			g.P(fmt.Sprintf("    %s += 4 // count", nestedSizeVar))
			g.P(fmt.Sprintf("    for _, item := range %s.%s {", msgVar, goName))
			g.P(fmt.Sprintf("        %s += 4 + len(item) // 4 bytes length prefix + data", nestedSizeVar))
			g.P("    }")
		} else if isNestedMessageField(field) {
			g.P(fmt.Sprintf("    // Field %d (%s): nested message payload", fieldNum, goName))
			g.P(fmt.Sprintf("    if %s.%s != nil {", msgVar, goName))
			// Nested messages are marshaled recursively with their own public/private split
			childNestedSizeVar := fmt.Sprintf("nestedSize%d", depth+1)
			generateSizeCalculation(g, field.Message, childNestedSizeVar, fmt.Sprintf("%s.%s", msgVar, goName), depth+1)
			g.P(fmt.Sprintf("        %s += 4 + %s // 4 bytes size + message data", nestedSizeVar, childNestedSizeVar))
			g.P("    }")
		} else if isRepeatedNestedMessageField(field) {
			g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message payload", fieldNum, goName))
			g.P(fmt.Sprintf("    %s += 4 // count", nestedSizeVar))
			g.P(fmt.Sprintf("    for _, item := range %s.%s {", msgVar, goName))
			childNestedSizeVar := fmt.Sprintf("nestedSize%d", depth+1)
			generateSizeCalculation(g, field.Message, childNestedSizeVar, "item", depth+1)
			g.P(fmt.Sprintf("        %s += 4 + %s // 4 bytes size + message data", nestedSizeVar, childNestedSizeVar))
			g.P("    }")
		}
	}

	return tableSize
}

// generateSizeCalculation generates code to calculate the exact buffer size
// For top-level: calculates public + private segments
// For nested: calculates recursively (nested messages also have public/private)
// Returns the public table size
func generateSizeCalculation(g *protogen.GeneratedFile, msg *protogen.Message, sizeVar, msgVar string, depth int) int {
	if sizeVar == "" {
		sizeVar = "size"
	}
	if msgVar == "" {
		msgVar = "m"
	}

	// Use unique variable name for nested size calculations
	nestedSizeVar := sizeVar
	if depth > 0 {
		nestedSizeVar = fmt.Sprintf("nestedSize%d", depth)
	}

	// Classify fields into public and private
	publicFields, privateFields := classifyFields(msg)

	g.P(fmt.Sprintf("    %s := 0", nestedSizeVar))
	g.P("    // Public segment:")
	g.P(fmt.Sprintf("    %s += 1 // version byte", nestedSizeVar))
	g.P(fmt.Sprintf("    %s += 12 // reserved: offset_to_private, service_name, method_name", nestedSizeVar))

	// Calculate public segment
	publicTableSize := generateSegmentSizeCalculation(g, publicFields, nestedSizeVar, msgVar, depth, false)

	// Calculate private segment
	g.P("    // Private segment:")
	_ = generateSegmentSizeCalculation(g, privateFields, nestedSizeVar, msgVar, depth, true)

	g.P()

	return publicTableSize
}

// getGoTypeName returns the Go type name for a field
func getGoTypeName(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		return "int32"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Uint64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	default:
		panic(fmt.Sprintf("unknown fixed-length field kind: %s", field.Desc.Kind()))
	}
}

// generateRawVariableFieldGetter generates code to read a variable-length field from Raw type
func generateRawVariableFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): variable-length", fieldNum, goName))

	// Check buffer size
	g.P(fmt.Sprintf("    if len(m) < %s+4 {", offsetExpr))
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read offset from table entry
	g.P(fmt.Sprintf("    payloadOffset := int(binary.LittleEndian.Uint32(m[%s:]))", offsetExpr))

	// Check if offset is valid (0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read length from payload
	g.P("    if len(m) < payloadOffset+4 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")
	g.P("    dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))")

	// Read actual data
	g.P("    if len(m) < payloadOffset+4+dataLen {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	if field.Desc.Kind() == protoreflect.StringKind {
		g.P("    return string(m[payloadOffset+4 : payloadOffset+4+dataLen])")
	} else { // BytesKind
		g.P("    result := make([]byte, dataLen)")
		g.P("    copy(result, m[payloadOffset+4:payloadOffset+4+dataLen])")
		g.P("    return result")
	}
}

// generateRawVariableFieldSetter generates code to write a variable-length field to Raw type
func generateRawVariableFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, msg *protogen.Message, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): variable-length", fieldNum, goName))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(*m) < %s+4 {", offsetExpr))
	g.P("        return fmt.Errorf(\"buffer too short for table entry\")")
	g.P("    }")

	// Read current offset and length
	g.P(fmt.Sprintf("    oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[%s:]))", offsetExpr))
	g.P("    var oldDataLen int")
	g.P("    if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {")
	g.P("        oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))")
	g.P("    }")

	// Calculate new data length
	g.P("    newDataLen := len(v)")

	// Check if we can update in-place
	g.P("    if oldPayloadOffset > 0 && newDataLen <= oldDataLen {")
	g.P("        // Update in-place (waste space)")
	g.P("        binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))")
	g.P("        copy((*m)[oldPayloadOffset+4:], v)")
	g.P("        return nil")
	g.P("    }")

	// Need to remarshal
	generateRemarshalLogic(g, msg, goName, isPublic)

}

// generateRawRepeatedFixedFieldGetter generates code to read a repeated fixed-length field from Raw type
func generateRawRepeatedFixedFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length", fieldNum, goName))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(m) < %s+4 {", offsetExpr))
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read offset from table entry
	g.P(fmt.Sprintf("    payloadOffset := int(binary.LittleEndian.Uint32(m[%s:]))", offsetExpr))

	// Check if offset is valid (0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read count from payload
	g.P("    if len(m) < payloadOffset+4 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")
	g.P("    count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))")

	// Validate data length
	g.P(fmt.Sprintf("    if len(m) < payloadOffset+4+%d*count {", fieldSize))
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Allocate slice and read each element
	g.P(fmt.Sprintf("    result := make([]%s, count)", getGoTypeName(field)))
	g.P("    for i := 0; i < count; i++ {")
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("        result[i] = m[payloadOffset+4+%d*i] != 0", fieldSize))
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("        result[i] = int32(binary.LittleEndian.Uint32(m[payloadOffset+4+%d*i:]))", fieldSize))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("        result[i] = binary.LittleEndian.Uint32(m[payloadOffset+4+%d*i:])", fieldSize))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("        result[i] = int64(binary.LittleEndian.Uint64(m[payloadOffset+4+%d*i:]))", fieldSize))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("        result[i] = binary.LittleEndian.Uint64(m[payloadOffset+4+%d*i:])", fieldSize))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32frombits"))
		g.P(fmt.Sprintf("        result[i] = %s(binary.LittleEndian.Uint32(m[payloadOffset+4+%d*i:]))", mathQualified, fieldSize))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64frombits"))
		g.P(fmt.Sprintf("        result[i] = %s(binary.LittleEndian.Uint64(m[payloadOffset+4+%d*i:]))", mathQualified, fieldSize))
	}
	g.P("    }")
	g.P("    return result")
}

// generateRawRepeatedFixedFieldSetter generates code to write a repeated fixed-length field to Raw type
func generateRawRepeatedFixedFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, msg *protogen.Message, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length", fieldNum, goName))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(*m) < %s+4 {", offsetExpr))
	g.P("        return fmt.Errorf(\"buffer too short for table entry\")")
	g.P("    }")

	// Read current offset and count
	g.P(fmt.Sprintf("    oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[%s:]))", offsetExpr))
	g.P("    var oldCount int")
	g.P("    var oldDataSize int")
	g.P("    if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {")
	g.P("        oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))")
	g.P(fmt.Sprintf("        oldDataSize = 4 + %d*oldCount // 4 bytes count + data", fieldSize))
	g.P("    }")

	// Calculate new count and data size
	g.P("    newCount := len(v)")
	g.P(fmt.Sprintf("    newDataSize := 4 + %d*newCount // 4 bytes count + data", fieldSize))

	// Check if we can update in-place
	g.P("    if oldPayloadOffset > 0 && newDataSize <= oldDataSize {")
	g.P("        // Update in-place (waste space)")
	g.P("        binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))")
	g.P("        for i, val := range v {")
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P("            if val {")
		g.P(fmt.Sprintf("                (*m)[oldPayloadOffset+4+%d*i] = 1", fieldSize))
		g.P("            } else {")
		g.P(fmt.Sprintf("                (*m)[oldPayloadOffset+4+%d*i] = 0", fieldSize))
		g.P("            }")
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint32((*m)[oldPayloadOffset+4+%d*i:], uint32(val))", fieldSize))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint32((*m)[oldPayloadOffset+4+%d*i:], val)", fieldSize))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint64((*m)[oldPayloadOffset+4+%d*i:], uint64(val))", fieldSize))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint64((*m)[oldPayloadOffset+4+%d*i:], val)", fieldSize))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32bits"))
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint32((*m)[oldPayloadOffset+4+%d*i:], %s(val))", fieldSize, mathQualified))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64bits"))
		g.P(fmt.Sprintf("            binary.LittleEndian.PutUint64((*m)[oldPayloadOffset+4+%d*i:], %s(val))", fieldSize, mathQualified))
	}
	g.P("        }")
	g.P("        return nil")
	g.P("    }")

	// Need to remarshal
	generateRemarshalLogic(g, msg, goName, isPublic)
}

// generateRawRepeatedVariableFieldGetter generates code to read a repeated variable-length field from Raw type
func generateRawRepeatedVariableFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length", fieldNum, goName))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(m) < %s+4 {", offsetExpr))
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read offset from table entry
	g.P(fmt.Sprintf("    payloadOffset := int(binary.LittleEndian.Uint32(m[%s:]))", offsetExpr))

	// Check if offset is valid (0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")

	// Read count from payload
	g.P("    if len(m) < payloadOffset+4 {")
	g.P("        return ", getZeroValue(field))
	g.P("    }")
	g.P("    count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))")

	// Allocate slice
	if field.Desc.Kind() == protoreflect.StringKind {
		g.P("    result := make([]string, count)")
	} else { // BytesKind
		g.P("    result := make([][]byte, count)")
	}

	// Read each element
	g.P("    currentOffset := payloadOffset + 4")
	g.P("    for i := 0; i < count; i++ {")
	g.P("        if len(m) < currentOffset+4 {")
	g.P("            return ", getZeroValue(field))
	g.P("        }")
	g.P("        itemLen := int(binary.LittleEndian.Uint32(m[currentOffset:]))")
	g.P("        if len(m) < currentOffset+4+itemLen {")
	g.P("            return ", getZeroValue(field))
	g.P("        }")
	if field.Desc.Kind() == protoreflect.StringKind {
		g.P("        result[i] = string(m[currentOffset+4 : currentOffset+4+itemLen])")
	} else { // BytesKind
		g.P("        result[i] = make([]byte, itemLen)")
		g.P("        copy(result[i], m[currentOffset+4:currentOffset+4+itemLen])")
	}
	g.P("        currentOffset += 4 + itemLen")
	g.P("    }")
	g.P("    return result")
}

// generateRawRepeatedVariableFieldSetter generates code to write a repeated variable-length field to Raw type
func generateRawRepeatedVariableFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, msg *protogen.Message, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length", fieldNum, goName))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(*m) < %s+4 {", offsetExpr))
	g.P("        return fmt.Errorf(\"buffer too short for table entry\")")
	g.P("    }")

	// Read current offset and count
	g.P(fmt.Sprintf("    oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[%s:]))", offsetExpr))
	g.P("    var oldCount int")
	g.P("    var oldDataSize int")
	g.P("    if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {")
	g.P("        oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))")
	g.P("        // Calculate old data size: 4 bytes count + for each item: 4 bytes length + data")
	g.P("        oldDataSize = 4")
	g.P("        currentOffset := oldPayloadOffset + 4")
	g.P("        for i := 0; i < oldCount; i++ {")
	g.P("            if len(*m) < currentOffset+4 {")
	g.P("                break")
	g.P("            }")
	g.P("            itemLen := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))")
	g.P("            oldDataSize += 4 + itemLen")
	g.P("            currentOffset += 4 + itemLen")
	g.P("        }")
	g.P("    }")

	// Calculate new count and data size
	g.P("    newCount := len(v)")
	g.P("    newDataSize := 4 // count")
	g.P("    for _, item := range v {")
	g.P("        newDataSize += 4 + len(item) // 4 bytes length + data")
	g.P("    }")

	// Check if we can update in-place
	g.P("    if oldPayloadOffset > 0 && newDataSize <= oldDataSize {")
	g.P("        // Update in-place (waste space)")
	g.P("        binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))")
	g.P("        currentOffset := oldPayloadOffset + 4")
	g.P("        for _, item := range v {")
	g.P("            itemLen := len(item)")
	g.P("            binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemLen))")
	g.P("            copy((*m)[currentOffset+4:], item)")
	g.P("            currentOffset += 4 + itemLen")
	g.P("        }")
	g.P("        return nil")
	g.P("    }")

	// Need to remarshal
	generateRemarshalLogic(g, msg, goName, isPublic)
}

// generateRawNestedFieldGetter generates code to read a nested message field from Raw type
func generateRawNestedFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	rawType := g.QualifiedGoIdent(field.Message.GoIdent) + "Raw"

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): nested message", fieldNum, goName))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(m) < %s+4 {", offsetExpr))
	g.P("        return nil")
	g.P("    }")

	// Read offset from table entry
	g.P(fmt.Sprintf("    payloadOffset := int(binary.LittleEndian.Uint32(m[%s:]))", offsetExpr))

	// Check if offset is valid (0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P("        return nil")
	g.P("    }")

	// Read size from payload
	g.P("    if len(m) < payloadOffset+4 {")
	g.P("        return nil")
	g.P("    }")
	g.P("    nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))")

	// Validate data length
	g.P("    if len(m) < payloadOffset+4+nestedSize {")
	g.P("        return nil")
	g.P("    }")

	// Return zero-copy slice of the nested message data as Raw type
	g.P(fmt.Sprintf("    return %s(m[payloadOffset+4 : payloadOffset+4+nestedSize])", rawType))
}

// generateRawNestedFieldSetter generates code to write a nested message field to Raw type
func generateRawNestedFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, msg *protogen.Message, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	msgType := g.QualifiedGoIdent(field.Message.GoIdent)

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): nested message", fieldNum, goName))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(*m) < %s+4 {", offsetExpr))
	g.P("        return fmt.Errorf(\"buffer too short for table entry\")")
	g.P("    }")

	// Read current offset and size
	g.P(fmt.Sprintf("    oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[%s:]))", offsetExpr))
	g.P("    var oldNestedSize int")
	g.P("    if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {")
	g.P("        oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))")
	g.P("    }")

	// Calculate new nested message size (v is already Raw type, i.e., []byte)
	g.P("    newNestedSize := len(v)")

	// Check if we can update in-place
	g.P("    if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {")
	g.P("        // Update in-place (waste space)")
	g.P("        binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))")
	g.P("        copy((*m)[oldPayloadOffset+4:], v)")
	g.P("        return nil")
	g.P("    }")

	// Need to remarshal
	parentMsgType := msg.GoIdent.GoName
	if isPublic {
		// For public fields: unmarshal complete (fake), update, marshal complete, truncate
		g.P("    // Need to remarshal: unmarshal, update, marshal, truncate to public-only")
		g.P(fmt.Sprintf("    var temp %s", parentMsgType))
		g.P("    // Create a fake complete buffer by appending a minimal private segment")
		g.P("    // Calculate private table size")

		// Calculate how many bytes the private table needs
		_, privateFields := classifyFields(msg)
		privateTableSize := 0
		for _, field := range privateFields {
			if isFixedLengthField(field) {
				privateTableSize += getFieldSize(field)
			} else {
				privateTableSize += 4 // offset for variable/repeated/nested fields
			}
		}

		g.P(fmt.Sprintf("    privateTableSize := %d // bytes needed for empty private table", privateTableSize))
		g.P("    fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table")
		g.P("    copy(fakeComplete, *m)")
		g.P("    // Update offsetToPrivate to point to the appended private segment")
		g.P("    binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))")
		g.P("    fakeComplete[len(*m)] = 0x01 // private segment version")
		g.P("    if err := temp.UnmarshalSymphony(fakeComplete); err != nil {")
		g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
		g.P("    }")
		// Update the field - need to convert Raw to regular message type
		g.P(fmt.Sprintf("    if temp.%s == nil {", goName))
		g.P(fmt.Sprintf("        temp.%s = &%s{}", goName, msgType))
		g.P("    }")
		g.P(fmt.Sprintf("    if err := temp.%s.UnmarshalSymphony([]byte(v)); err != nil {", goName))
		g.P("        return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
		g.P("    }")
		// Marshal complete buffer
		g.P("    fullData, err := temp.MarshalSymphony()")
		g.P("    if err != nil {")
		g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
		g.P("    }")
		// Truncate to public-only
		g.P("    offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))")
		g.P("    *m = ", parentMsgType, "Raw(fullData[:offsetToPrivate])")
		g.P("    return nil")
	} else {
		// For private fields: unmarshal complete buffer, update, marshal complete buffer
		g.P("    // Need to remarshal: unmarshal, update, marshal")
		g.P(fmt.Sprintf("    var temp %s", parentMsgType))
		g.P("    if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {")
		g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
		g.P("    }")
		// Update the field - need to convert Raw to regular message type
		g.P(fmt.Sprintf("    if temp.%s == nil {", goName))
		g.P(fmt.Sprintf("        temp.%s = &%s{}", goName, msgType))
		g.P("    }")
		g.P(fmt.Sprintf("    if err := temp.%s.UnmarshalSymphony([]byte(v)); err != nil {", goName))
		g.P("        return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
		g.P("    }")
		// Marshal again
		g.P("    newData, err := temp.MarshalSymphony()")
		g.P("    if err != nil {")
		g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
		g.P("    }")
		g.P("    *m = ", parentMsgType, "Raw(newData)")
		g.P("    return nil")
	}
}

// generateRawRepeatedNestedFieldGetter generates code to read a repeated nested message field from Raw type
func generateRawRepeatedNestedFieldGetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	rawType := g.QualifiedGoIdent(field.Message.GoIdent) + "Raw"

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message", fieldNum, goName))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(m) < %s+4 {", offsetExpr))
	g.P("        return nil")
	g.P("    }")

	// Read offset from table entry
	g.P(fmt.Sprintf("    payloadOffset := int(binary.LittleEndian.Uint32(m[%s:]))", offsetExpr))

	// Check if offset is valid (0 means not set)
	g.P("    if payloadOffset == 0 {")
	g.P("        return nil")
	g.P("    }")

	// Read count from payload
	g.P("    if len(m) < payloadOffset+4 {")
	g.P("        return nil")
	g.P("    }")
	g.P("    count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))")

	// Allocate slice of Raw types
	g.P(fmt.Sprintf("    result := make([]%s, count)", rawType))

	// Read each nested message as Raw type (zero-copy)
	g.P("    currentOffset := payloadOffset + 4")
	g.P("    for i := 0; i < count; i++ {")
	g.P("        if len(m) < currentOffset+4 {")
	g.P("            return nil")
	g.P("        }")
	g.P("        nestedSize := int(binary.LittleEndian.Uint32(m[currentOffset:]))")
	g.P("        if len(m) < currentOffset+4+nestedSize {")
	g.P("            return nil")
	g.P("        }")
	g.P(fmt.Sprintf("        result[i] = %s(m[currentOffset+4 : currentOffset+4+nestedSize])", rawType))
	g.P("        currentOffset += 4 + nestedSize")
	g.P("    }")
	g.P("    return result")
}

// generateRawRepeatedNestedFieldSetter generates code to write a repeated nested message field to Raw type
func generateRawRepeatedNestedFieldSetter(g *protogen.GeneratedFile, field *protogen.Field, tableOffset int, msg *protogen.Message, isPublic bool) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	// For private fields, adjust offset to be relative to private segment
	offsetExpr := fmt.Sprintf("%d", tableOffset)
	if !isPublic {
		offsetExpr = fmt.Sprintf("offsetToPrivate+%d", tableOffset)
	}

	g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message", fieldNum, goName))

	// Check buffer size for table entry
	g.P(fmt.Sprintf("    if len(*m) < %s+4 {", offsetExpr))
	g.P("        return fmt.Errorf(\"buffer too short for table entry\")")
	g.P("    }")

	// Read current offset and calculate old total size
	g.P(fmt.Sprintf("    oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[%s:]))", offsetExpr))
	g.P("    var oldCount int")
	g.P("    var oldDataSize int")
	g.P("    if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {")
	g.P("        oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))")
	g.P("        // Calculate old data size: 4 bytes count + for each item: 4 bytes size + data")
	g.P("        oldDataSize = 4")
	g.P("        currentOffset := oldPayloadOffset + 4")
	g.P("        for i := 0; i < oldCount; i++ {")
	g.P("            if len(*m) < currentOffset+4 {")
	g.P("                break")
	g.P("            }")
	g.P("            itemSize := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))")
	g.P("            oldDataSize += 4 + itemSize")
	g.P("            currentOffset += 4 + itemSize")
	g.P("        }")
	g.P("    }")

	// Calculate new count and total size
	g.P("    newCount := len(v)")
	g.P("    newDataSize := 4 // count")
	g.P("    for _, item := range v {")
	g.P("        newDataSize += 4 + len(item) // 4 bytes size + data")
	g.P("    }")

	// Check if we can update in-place
	g.P("    if oldPayloadOffset > 0 && newDataSize <= oldDataSize {")
	g.P("        // Update in-place (waste space)")
	g.P("        binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))")
	g.P("        currentOffset := oldPayloadOffset + 4")
	g.P("        for _, item := range v {")
	g.P("            itemSize := len(item)")
	g.P("            binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemSize))")
	g.P("            copy((*m)[currentOffset+4:], item)")
	g.P("            currentOffset += 4 + itemSize")
	g.P("        }")
	g.P("        return nil")
	g.P("    }")

	// Need to remarshal
	parentMsgType := msg.GoIdent.GoName
	nestedMsgType := g.QualifiedGoIdent(field.Message.GoIdent)

	if isPublic {
		// For public fields: unmarshal complete (fake), update, marshal complete, truncate
		g.P("    // Need to remarshal: unmarshal, update, marshal, truncate to public-only")
		g.P(fmt.Sprintf("    var temp %s", parentMsgType))
		g.P("    // Create a fake complete buffer by appending a minimal private segment")
		g.P("    // Calculate private table size")

		// Calculate how many bytes the private table needs
		_, privateFields := classifyFields(msg)
		privateTableSize := 0
		for _, field := range privateFields {
			if isFixedLengthField(field) {
				privateTableSize += getFieldSize(field)
			} else {
				privateTableSize += 4 // offset for variable/repeated/nested fields
			}
		}

		g.P(fmt.Sprintf("    privateTableSize := %d // bytes needed for empty private table", privateTableSize))
		g.P("    fakeComplete := make([]byte, len(*m)+1+privateTableSize) // version byte + private table")
		g.P("    copy(fakeComplete, *m)")
		g.P("    // Update offsetToPrivate to point to the appended private segment")
		g.P("    binary.LittleEndian.PutUint32(fakeComplete[1:5], uint32(len(*m)))")
		g.P("    fakeComplete[len(*m)] = 0x01 // private segment version")
		g.P("    if err := temp.UnmarshalSymphony(fakeComplete); err != nil {")
		g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
		g.P("    }")
		// Update the field - convert Raw types to regular message types
		g.P(fmt.Sprintf("    temp.%s = make([]*%s, len(v))", goName, nestedMsgType))
		g.P("    for i, rawItem := range v {")
		g.P(fmt.Sprintf("        temp.%s[i] = &%s{}", goName, nestedMsgType))
		g.P(fmt.Sprintf("        if err := temp.%s[i].UnmarshalSymphony([]byte(rawItem)); err != nil {", goName))
		g.P("            return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
		g.P("        }")
		g.P("    }")
		// Marshal complete buffer
		g.P("    fullData, err := temp.MarshalSymphony()")
		g.P("    if err != nil {")
		g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
		g.P("    }")
		// Truncate to public-only
		g.P("    offsetToPrivate := int(binary.LittleEndian.Uint32(fullData[1:5]))")
		g.P("    *m = ", parentMsgType, "Raw(fullData[:offsetToPrivate])")
		g.P("    return nil")
	} else {
		// For private fields: unmarshal complete buffer, update, marshal complete buffer
		g.P("    // Need to remarshal: unmarshal, update, marshal")
		g.P(fmt.Sprintf("    var temp %s", parentMsgType))
		g.P("    if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {")
		g.P("        return fmt.Errorf(\"failed to unmarshal: %w\", err)")
		g.P("    }")
		// Update the field - convert Raw types to regular message types
		g.P(fmt.Sprintf("    temp.%s = make([]*%s, len(v))", goName, nestedMsgType))
		g.P("    for i, rawItem := range v {")
		g.P(fmt.Sprintf("        temp.%s[i] = &%s{}", goName, nestedMsgType))
		g.P(fmt.Sprintf("        if err := temp.%s[i].UnmarshalSymphony([]byte(rawItem)); err != nil {", goName))
		g.P("            return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
		g.P("        }")
		g.P("    }")
		// Marshal again
		g.P("    newData, err := temp.MarshalSymphony()")
		g.P("    if err != nil {")
		g.P("        return fmt.Errorf(\"failed to marshal: %w\", err)")
		g.P("    }")
		g.P("    *m = ", parentMsgType, "Raw(newData)")
		g.P("    return nil")
	}
}
