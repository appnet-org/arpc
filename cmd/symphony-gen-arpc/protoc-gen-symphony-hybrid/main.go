package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var (
	math  = protogen.GoImportPath("math")
	proto = protogen.GoImportPath("google.golang.org/protobuf/proto")
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}
			generateFile(plugin, file)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".hybrid.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-symphony-hybrid. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)
	g.P("import (")
	g.P("\t\"encoding/binary\"")
	g.P("\t\"fmt\"")
	g.P()
	g.P("\t\"google.golang.org/protobuf/proto\"")
	g.P(")")
	g.P()

	for _, message := range file.Messages {
		generateMessage(g, message)
	}
}

func generateMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	// Generate hybrid marshal/unmarshal functions
	generateHybridMarshal(g, msg)
	generateHybridUnmarshal(g, msg)
}

func generateHybridMarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	publicFields, privateFields := classifyFields(msg)

	g.P("func (m *", msg.GoIdent, ") MarshalSymphonyHybrid() ([]byte, error) {")

	// Handle empty messages specially
	if len(msg.Fields) == 0 {
		g.P("    // Empty message - public segment with header only, empty private segment")
		g.P("    buf := make([]byte, 13) // 1 version + 12 reserved")
		g.P("    buf[0] = 0x01 // public version")
		g.P("    binary.LittleEndian.PutUint32(buf[1:5], 13) // offset_to_private (no private segment)")
		g.P("    // service_name and method_name stay 0")
		g.P("    return buf, nil")
		g.P("}")
		g.P()
		return
	}

	// Calculate public segment size using Symphony format
	publicTableSize := 0
	for _, field := range publicFields {
		if isFixedLengthField(field) {
			publicTableSize += getFieldSize(field)
		} else {
			publicTableSize += 4
		}
	}

	g.P("    // Calculate public segment size")
	g.P("    publicSegmentSize := 13") // 1 + 12 for version and reserved

	// Add public table size
	g.P(fmt.Sprintf("    publicSegmentSize += %d // public table", publicTableSize))

	// Add public payload sizes
	for _, field := range publicFields {
		goName := field.GoName
		fieldNum := field.Desc.Number()

		if isVariableLengthField(field) {
			g.P(fmt.Sprintf("    publicSegmentSize += 4 + len(m.%s) // field %d payload", goName, fieldNum))
		} else if isRepeatedFixedLengthField(field) {
			fieldSize := getFieldSize(field)
			g.P(fmt.Sprintf("    publicSegmentSize += 4 + %d*len(m.%s) // field %d payload", fieldSize, goName, fieldNum))
		} else if isRepeatedVariableLengthField(field) {
			g.P(fmt.Sprintf("    publicSegmentSize += 4 // field %d count", fieldNum))
			g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
			g.P("        publicSegmentSize += 4 + len(item)")
			g.P("    }")
		} else if isNestedMessageField(field) {
			g.P(fmt.Sprintf("    if m.%s != nil {", goName))
			g.P(fmt.Sprintf("        nestedData%d, _ := m.%s.MarshalSymphonyHybrid()", fieldNum, goName))
			g.P(fmt.Sprintf("        publicSegmentSize += 4 + len(nestedData%d) // field %d payload", fieldNum, fieldNum))
			g.P("    }")
		} else if isRepeatedNestedMessageField(field) {
			g.P(fmt.Sprintf("    publicSegmentSize += 4 // field %d count", fieldNum))
			g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
			g.P("        nestedData, _ := item.MarshalSymphonyHybrid()")
			g.P("        publicSegmentSize += 4 + len(nestedData)")
			g.P("    }")
		}
	}
	g.P()

	// Marshal private fields using protobuf
	g.P("    // Marshal private fields using protobuf")
	if len(privateFields) > 0 {
		// Create a temporary message with only private fields
		g.P("    privateMsg := &", msg.GoIdent, "{")
		for _, field := range privateFields {
			goName := field.GoName
			g.P(fmt.Sprintf("        %s: m.%s,", goName, goName))
		}
		g.P("    }")
		g.P("    privateData, err := proto.Marshal(privateMsg)")
		g.P("    if err != nil {")
		g.P("        return nil, fmt.Errorf(\"failed to marshal private segment: %w\", err)")
		g.P("    }")
		g.P()
		g.P("    // Calculate total size")
		g.P("    totalSize := publicSegmentSize + len(privateData)")
		g.P("    buf := make([]byte, totalSize)")
		g.P()
		g.P("    // Write header")
		g.P("    buf[0] = 0x01 // version byte")
		g.P("    binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private")
		g.P("    binary.LittleEndian.PutUint32(buf[5:9], 0) // service_id")
		g.P("    binary.LittleEndian.PutUint32(buf[9:13], 0) // method_id")
		g.P()
		g.P("    // Write public segment (Symphony format)")
		g.P("    publicTableStart := 13")
		g.P(fmt.Sprintf("    publicPayloadStart := publicTableStart + %d", publicTableSize))
		g.P("    publicPayloadOffset := 0")
		g.P("    dataLen := 0")
		g.P("    _ = publicPayloadStart")
		g.P("    _ = publicPayloadOffset")
		g.P("    _ = dataLen")
		g.P()
		generateSegmentMarshal(g, publicFields, "publicTableStart", "publicPayloadStart", "publicPayloadOffset")
		g.P()
		g.P("    // Write private segment (Protobuf format)")
		g.P("    copy(buf[publicSegmentSize:], privateData)")
		g.P()
		g.P("    return buf, nil")
	} else {
		// No private fields
		g.P("    // No private fields")
		g.P("    buf := make([]byte, publicSegmentSize)")
		g.P()
		g.P("    // Write header")
		g.P("    buf[0] = 0x01 // version byte")
		g.P("    binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private (no private segment)")
		g.P("    binary.LittleEndian.PutUint32(buf[5:9], 0) // service_id")
		g.P("    binary.LittleEndian.PutUint32(buf[9:13], 0) // method_id")
		g.P()
		g.P("    // Write public segment (Symphony format)")
		g.P("    publicTableStart := 13")
		g.P(fmt.Sprintf("    publicPayloadStart := publicTableStart + %d", publicTableSize))
		g.P("    publicPayloadOffset := 0")
		g.P("    dataLen := 0")
		g.P("    _ = publicPayloadStart")
		g.P("    _ = publicPayloadOffset")
		g.P("    _ = dataLen")
		g.P()
		generateSegmentMarshal(g, publicFields, "publicTableStart", "publicPayloadStart", "publicPayloadOffset")
		g.P()
		g.P("    return buf, nil")
	}

	g.P("}")
	g.P()
}

func generateHybridUnmarshal(g *protogen.GeneratedFile, msg *protogen.Message) {
	publicFields, privateFields := classifyFields(msg)

	g.P("func (m *", msg.GoIdent, ") UnmarshalSymphonyHybrid(data []byte) error {")

	// Handle empty messages specially
	if len(msg.Fields) == 0 {
		g.P("    // Empty message - just validate header")
		g.P("    if len(data) < 13 {")
		g.P("        return fmt.Errorf(\"invalid data: too short\")")
		g.P("    }")
		g.P("    if data[0] != 0x01 {")
		g.P("        return fmt.Errorf(\"invalid data: wrong public version\")")
		g.P("    }")
		g.P("    return nil")
		g.P("}")
		g.P()
		return
	}

	// Check minimum size and validate public segment
	g.P("    if len(data) < 13 {")
	g.P("        return fmt.Errorf(\"invalid data: too short\")")
	g.P("    }")
	g.P()
	g.P("    // Validate public segment version")
	g.P("    if data[0] != 0x01 {")
	g.P("        return fmt.Errorf(\"invalid data: wrong public version\")")
	g.P("    }")
	g.P()
	g.P("    // Read header")
	g.P("    offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))")
	g.P("    // service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet")
	g.P("    // method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet")
	g.P()

	// Variables
	g.P("    payloadOffset := 0")
	g.P("    _ = payloadOffset")
	g.P("    dataLen := 0")
	g.P("    _ = dataLen")
	g.P("    count := 0")
	g.P("    _ = count")
	g.P("    currentOffset := 0")
	g.P("    _ = currentOffset")
	g.P()

	// Unmarshal public fields (Symphony format)
	g.P("    // === PUBLIC FIELDS (Symphony format) ===")
	g.P("    publicTableStart := 13")
	g.P("    _ = publicTableStart")
	generateSegmentUnmarshal(g, publicFields, "publicTableStart", "data", "")

	// Unmarshal private fields (Protobuf format)
	if len(privateFields) > 0 {
		g.P("    // === PRIVATE FIELDS (Protobuf format) ===")
		g.P("    if offsetToPrivate < len(data) {")
		g.P("        privateData := data[offsetToPrivate:]")
		g.P("        privateMsg := &", msg.GoIdent, "{}")
		g.P("        if err := proto.Unmarshal(privateData, privateMsg); err != nil {")
		g.P("            return fmt.Errorf(\"failed to unmarshal private segment: %w\", err)")
		g.P("        }")
		// Copy private fields from the unmarshaled message
		for _, field := range privateFields {
			goName := field.GoName
			g.P(fmt.Sprintf("        m.%s = privateMsg.%s", goName, goName))
		}
		g.P("    }")
	}

	g.P("    return nil")
	g.P("}")
	g.P()
}

// generateSegmentMarshal generates code to marshal fields in a segment (Symphony format)
func generateSegmentMarshal(g *protogen.GeneratedFile, fields []*protogen.Field, tableStartVar, payloadStartVar, payloadOffsetVar string) {
	if len(fields) == 0 {
		return
	}

	tableOffset := 0
	for _, field := range fields {
		if isFixedLengthField(field) {
			fieldSize := getFieldSize(field)
			generateFixedFieldMarshal(g, field, tableStartVar, tableOffset)
			tableOffset += fieldSize
		} else if isVariableLengthField(field) {
			generateVariableFieldMarshal(g, field, tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar)
			tableOffset += 4
		} else if isRepeatedFixedLengthField(field) {
			generateRepeatedFixedFieldMarshal(g, field, tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar)
			tableOffset += 4
		} else if isRepeatedVariableLengthField(field) {
			generateRepeatedVariableFieldMarshal(g, field, tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar)
			tableOffset += 4
		} else if isNestedMessageField(field) {
			generateNestedFieldMarshal(g, field, tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar)
			tableOffset += 4
		} else if isRepeatedNestedMessageField(field) {
			generateRepeatedNestedFieldMarshal(g, field, tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar)
			tableOffset += 4
		}
	}
}

func generateFixedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): fixed-length (%d bytes)", fieldNum, goName, fieldSize))

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("    if m.%s {", goName))
		g.P(fmt.Sprintf("        buf[%s+%d] = 1", tableStartVar, tableOffset))
		g.P("    } else {")
		g.P(fmt.Sprintf("        buf[%s+%d] = 0", tableStartVar, tableOffset))
		g.P("    }")
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(m.%s))", tableStartVar, tableOffset, goName))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], m.%s)", tableStartVar, tableOffset, goName))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64(buf[%s+%d:], uint64(m.%s))", tableStartVar, tableOffset, goName))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64(buf[%s+%d:], m.%s)", tableStartVar, tableOffset, goName))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32bits"))
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], %s(m.%s))", tableStartVar, tableOffset, mathQualified, goName))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64bits"))
		g.P(fmt.Sprintf("    binary.LittleEndian.PutUint64(buf[%s+%d:], %s(m.%s))", tableStartVar, tableOffset, mathQualified, goName))
	}
	g.P()
}

func generateVariableFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, payloadStartVar, payloadOffsetVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): variable-length", fieldNum, goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(%s+%s))", tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    dataLen = len(m.%s)", goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%s:], uint32(dataLen))", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    copy(buf[%s+%s+4:], m.%s)", payloadStartVar, payloadOffsetVar, goName))
	g.P(fmt.Sprintf("    %s += 4 + len(m.%s)", payloadOffsetVar, goName))
	g.P()
}

func generateRepeatedFixedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, payloadStartVar, payloadOffsetVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length", fieldNum, goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(%s+%s))", tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    count = len(m.%s)", goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%s:], uint32(count))", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    for i, v := range m.%s {", goName))

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P("        if v {")
		g.P(fmt.Sprintf("            buf[%s+%s+4+%d*i] = 1", payloadStartVar, payloadOffsetVar, fieldSize))
		g.P("        } else {")
		g.P(fmt.Sprintf("            buf[%s+%s+4+%d*i] = 0", payloadStartVar, payloadOffsetVar, fieldSize))
		g.P("        }")
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%s+4+%d*i:], uint32(v))", payloadStartVar, payloadOffsetVar, fieldSize))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%s+4+%d*i:], v)", payloadStartVar, payloadOffsetVar, fieldSize))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(buf[%s+%s+4+%d*i:], uint64(v))", payloadStartVar, payloadOffsetVar, fieldSize))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(buf[%s+%s+4+%d*i:], v)", payloadStartVar, payloadOffsetVar, fieldSize))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32bits"))
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%s+4+%d*i:], %s(v))", payloadStartVar, payloadOffsetVar, fieldSize, mathQualified))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64bits"))
		g.P(fmt.Sprintf("        binary.LittleEndian.PutUint64(buf[%s+%s+4+%d*i:], %s(v))", payloadStartVar, payloadOffsetVar, fieldSize, mathQualified))
	}
	g.P("    }")
	g.P(fmt.Sprintf("    %s += 4 + %d*len(m.%s)", payloadOffsetVar, fieldSize, goName))
	g.P()
}

func generateRepeatedVariableFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, payloadStartVar, payloadOffsetVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length", fieldNum, goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(%s+%s))", tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    count = len(m.%s)", goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%s:], uint32(count))", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    currentOffset = %s + %s + 4", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
	g.P("        itemLen := len(item)")
	g.P("        binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))")
	g.P("        copy(buf[currentOffset+4:], item)")
	g.P("        currentOffset += 4 + itemLen")
	g.P("    }")
	g.P(fmt.Sprintf("    %s += 4 // count", payloadOffsetVar))
	g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
	g.P(fmt.Sprintf("        %s += 4 + len(item)", payloadOffsetVar))
	g.P("    }")
	g.P()
}

func generateNestedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, payloadStartVar, payloadOffsetVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): nested message", fieldNum, goName))
	g.P(fmt.Sprintf("    if m.%s != nil {", goName))
	g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(%s+%s))", tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("        nestedData, err := m.%s.MarshalSymphonyHybrid()", goName))
	g.P("        if err != nil {")
	g.P("            return nil, fmt.Errorf(\"failed to marshal nested message: %w\", err)")
	g.P("        }")
	g.P("        nestedSize := len(nestedData)")
	g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%s:], uint32(nestedSize))", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("        copy(buf[%s+%s+4:], nestedData)", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("        %s += 4 + nestedSize", payloadOffsetVar))
	g.P("    } else {")
	g.P(fmt.Sprintf("        binary.LittleEndian.PutUint32(buf[%s+%d:], 0)", tableStartVar, tableOffset))
	g.P("    }")
	g.P()
}

func generateRepeatedNestedFieldMarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, payloadStartVar, payloadOffsetVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message", fieldNum, goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%d:], uint32(%s+%s))", tableStartVar, tableOffset, payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    count = len(m.%s)", goName))
	g.P(fmt.Sprintf("    binary.LittleEndian.PutUint32(buf[%s+%s:], uint32(count))", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    %s += 4", payloadOffsetVar))
	g.P(fmt.Sprintf("    currentOffset = %s + %s", payloadStartVar, payloadOffsetVar))
	g.P(fmt.Sprintf("    for _, item := range m.%s {", goName))
	g.P("        nestedData, err := item.MarshalSymphonyHybrid()")
	g.P("        if err != nil {")
	g.P("            return nil, fmt.Errorf(\"failed to marshal nested message: %w\", err)")
	g.P("        }")
	g.P("        nestedSize := len(nestedData)")
	g.P("        binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))")
	g.P("        copy(buf[currentOffset+4:], nestedData)")
	g.P("        currentOffset += 4 + nestedSize")
	g.P(fmt.Sprintf("        %s += 4 + nestedSize", payloadOffsetVar))
	g.P("    }")
	g.P()
}

// generateSegmentUnmarshal generates code to unmarshal fields from a segment (Symphony format)
func generateSegmentUnmarshal(g *protogen.GeneratedFile, fields []*protogen.Field, tableStartVar, dataVar string, offsetBaseVar ...string) {
	if len(fields) == 0 {
		return
	}

	// Check if we should use relative offsets (not used for public segment, but kept for compatibility)
	relativeBase := ""
	if len(offsetBaseVar) > 0 {
		relativeBase = offsetBaseVar[0]
	}

	tableOffset := 0
	for _, field := range fields {
		if isFixedLengthField(field) {
			fieldSize := getFieldSize(field)
			generateFixedFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar)
			tableOffset += fieldSize
		} else if isVariableLengthField(field) {
			generateVariableFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar, relativeBase)
			tableOffset += 4
		} else if isRepeatedFixedLengthField(field) {
			generateRepeatedFixedFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar, relativeBase)
			tableOffset += 4
		} else if isRepeatedVariableLengthField(field) {
			generateRepeatedVariableFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar, relativeBase)
			tableOffset += 4
		} else if isNestedMessageField(field) {
			generateNestedFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar, relativeBase)
			tableOffset += 4
		} else if isRepeatedNestedMessageField(field) {
			generateRepeatedNestedFieldUnmarshal(g, field, tableStartVar, tableOffset, dataVar, relativeBase)
			tableOffset += 4
		}
	}
}

func generateFixedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): fixed-length (%d bytes)", fieldNum, goName, fieldSize))
	g.P(fmt.Sprintf("    if len(%s) < %s+%d {", dataVar, tableStartVar, tableOffset+fieldSize))
	g.P("        return fmt.Errorf(\"invalid data: too short for field\")")
	g.P("    }")

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("    m.%s = %s[%s+%d] != 0", goName, dataVar, tableStartVar, tableOffset))
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("    m.%s = int32(binary.LittleEndian.Uint32(%s[%s+%d:]))", goName, dataVar, tableStartVar, tableOffset))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("    m.%s = binary.LittleEndian.Uint32(%s[%s+%d:])", goName, dataVar, tableStartVar, tableOffset))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("    m.%s = int64(binary.LittleEndian.Uint64(%s[%s+%d:]))", goName, dataVar, tableStartVar, tableOffset))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("    m.%s = binary.LittleEndian.Uint64(%s[%s+%d:])", goName, dataVar, tableStartVar, tableOffset))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32frombits"))
		g.P(fmt.Sprintf("    m.%s = %s(binary.LittleEndian.Uint32(%s[%s+%d:]))", goName, mathQualified, dataVar, tableStartVar, tableOffset))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64frombits"))
		g.P(fmt.Sprintf("    m.%s = %s(binary.LittleEndian.Uint64(%s[%s+%d:]))", goName, mathQualified, dataVar, tableStartVar, tableOffset))
	}
	g.P()
}

func generateVariableFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string, relativeBase ...string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): variable-length", fieldNum, goName))
	g.P(fmt.Sprintf("    if len(%s) >= %s+%d+4 {", dataVar, tableStartVar, tableOffset))
	g.P(fmt.Sprintf("        payloadOffset = int(binary.LittleEndian.Uint32(%s[%s+%d:]))", dataVar, tableStartVar, tableOffset))

	// If reading from a segment with relative offsets, add the base
	if len(relativeBase) > 0 && relativeBase[0] != "" {
		g.P("        if payloadOffset > 0 {")
		g.P(fmt.Sprintf("            payloadOffset += %s // convert relative offset to absolute", relativeBase[0]))
		g.P("        }")
	}

	g.P("        if payloadOffset > 0 && len(data) >= payloadOffset+4 {")
	g.P("            dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P("            if len(data) >= payloadOffset+4+dataLen {")
	if field.Desc.Kind() == protoreflect.StringKind {
		g.P(fmt.Sprintf("                m.%s = string(data[payloadOffset+4 : payloadOffset+4+dataLen])", goName))
	} else {
		g.P(fmt.Sprintf("                m.%s = make([]byte, dataLen)", goName))
		g.P(fmt.Sprintf("                copy(m.%s, data[payloadOffset+4:payloadOffset+4+dataLen])", goName))
	}
	g.P("            }")
	g.P("        }")
	g.P("    }")
	g.P()
}

func generateRepeatedFixedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string, relativeBase ...string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	fieldSize := getFieldSize(field)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated fixed-length", fieldNum, goName))
	g.P(fmt.Sprintf("    if len(%s) >= %s+%d+4 {", dataVar, tableStartVar, tableOffset))
	g.P(fmt.Sprintf("        payloadOffset = int(binary.LittleEndian.Uint32(%s[%s+%d:]))", dataVar, tableStartVar, tableOffset))

	// If reading from a segment with relative offsets, add the base
	if len(relativeBase) > 0 && relativeBase[0] != "" {
		g.P("        if payloadOffset > 0 {")
		g.P(fmt.Sprintf("            payloadOffset += %s // convert relative offset to absolute", relativeBase[0]))
		g.P("        }")
	}

	g.P("        if payloadOffset > 0 && len(data) >= payloadOffset+4 {")
	g.P("            count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P(fmt.Sprintf("            if len(data) >= payloadOffset+4+count*%d {", fieldSize))
	g.P(fmt.Sprintf("                m.%s = make([]%s, count)", goName, getGoTypeBase(g, field)))
	g.P("                for i := 0; i < count; i++ {")

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		g.P(fmt.Sprintf("                    m.%s[i] = data[payloadOffset+4+%d*i] != 0", goName, fieldSize))
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		g.P(fmt.Sprintf("                    m.%s[i] = int32(binary.LittleEndian.Uint32(data[payloadOffset+4+%d*i:]))", goName, fieldSize))
	case protoreflect.Uint32Kind:
		g.P(fmt.Sprintf("                    m.%s[i] = binary.LittleEndian.Uint32(data[payloadOffset+4+%d*i:])", goName, fieldSize))
	case protoreflect.Int64Kind:
		g.P(fmt.Sprintf("                    m.%s[i] = int64(binary.LittleEndian.Uint64(data[payloadOffset+4+%d*i:]))", goName, fieldSize))
	case protoreflect.Uint64Kind:
		g.P(fmt.Sprintf("                    m.%s[i] = binary.LittleEndian.Uint64(data[payloadOffset+4+%d*i:])", goName, fieldSize))
	case protoreflect.FloatKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float32frombits"))
		g.P(fmt.Sprintf("                    m.%s[i] = %s(binary.LittleEndian.Uint32(data[payloadOffset+4+%d*i:]))", goName, mathQualified, fieldSize))
	case protoreflect.DoubleKind:
		mathQualified := g.QualifiedGoIdent(math.Ident("Float64frombits"))
		g.P(fmt.Sprintf("                    m.%s[i] = %s(binary.LittleEndian.Uint64(data[payloadOffset+4+%d*i:]))", goName, mathQualified, fieldSize))
	}

	g.P("                }")
	g.P("            }")
	g.P("        }")
	g.P("    }")
	g.P()
}

func generateRepeatedVariableFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string, relativeBase ...string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName

	g.P(fmt.Sprintf("    // Field %d (%s): repeated variable-length", fieldNum, goName))
	g.P(fmt.Sprintf("    if len(%s) >= %s+%d+4 {", dataVar, tableStartVar, tableOffset))
	g.P(fmt.Sprintf("        payloadOffset = int(binary.LittleEndian.Uint32(%s[%s+%d:]))", dataVar, tableStartVar, tableOffset))

	// If reading from a segment with relative offsets, add the base
	if len(relativeBase) > 0 && relativeBase[0] != "" {
		g.P("        if payloadOffset > 0 {")
		g.P(fmt.Sprintf("            payloadOffset += %s // convert relative offset to absolute", relativeBase[0]))
		g.P("        }")
	}

	g.P("        if payloadOffset > 0 && len(data) >= payloadOffset+4 {")
	g.P("            count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P(fmt.Sprintf("            m.%s = make([]%s, 0, count)", goName, getGoTypeBase(g, field)))
	g.P("            currentOffset = payloadOffset + 4")
	g.P("            for i := 0; i < count; i++ {")
	g.P("                if len(data) >= currentOffset+4 {")
	g.P("                    itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))")
	g.P("                    if len(data) >= currentOffset+4+itemLen {")
	if field.Desc.Kind() == protoreflect.StringKind {
		g.P(fmt.Sprintf("                        m.%s = append(m.%s, string(data[currentOffset+4:currentOffset+4+itemLen]))", goName, goName))
	} else {
		g.P("                        itemData := make([]byte, itemLen)")
		g.P("                        copy(itemData, data[currentOffset+4:currentOffset+4+itemLen])")
		g.P(fmt.Sprintf("                        m.%s = append(m.%s, itemData)", goName, goName))
	}
	g.P("                        currentOffset += 4 + itemLen")
	g.P("                    }")
	g.P("                }")
	g.P("            }")
	g.P("        }")
	g.P("    }")
	g.P()
}

func generateNestedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string, relativeBase ...string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	msgType := g.QualifiedGoIdent(field.Message.GoIdent)

	g.P(fmt.Sprintf("    // Field %d (%s): nested message", fieldNum, goName))
	g.P(fmt.Sprintf("    if len(%s) >= %s+%d+4 {", dataVar, tableStartVar, tableOffset))
	g.P(fmt.Sprintf("        payloadOffset = int(binary.LittleEndian.Uint32(%s[%s+%d:]))", dataVar, tableStartVar, tableOffset))

	// If reading from a segment with relative offsets, add the base
	if len(relativeBase) > 0 && relativeBase[0] != "" {
		g.P("        if payloadOffset > 0 {")
		g.P(fmt.Sprintf("            payloadOffset += %s // convert relative offset to absolute", relativeBase[0]))
		g.P("        }")
	}

	g.P("        if payloadOffset > 0 && len(data) >= payloadOffset+4 {")
	g.P("            dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P("            if len(data) >= payloadOffset+4+dataLen {")
	g.P(fmt.Sprintf("                m.%s = &%s{}", goName, msgType))
	g.P(fmt.Sprintf("                if err := m.%s.UnmarshalSymphonyHybrid(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {", goName))
	g.P("                    return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
	g.P("                }")
	g.P("            }")
	g.P("        }")
	g.P("    }")
	g.P()
}

func generateRepeatedNestedFieldUnmarshal(g *protogen.GeneratedFile, field *protogen.Field, tableStartVar string, tableOffset int, dataVar string, relativeBase ...string) {
	fieldNum := field.Desc.Number()
	goName := field.GoName
	msgType := g.QualifiedGoIdent(field.Message.GoIdent)

	g.P(fmt.Sprintf("    // Field %d (%s): repeated nested message", fieldNum, goName))
	g.P(fmt.Sprintf("    if len(%s) >= %s+%d+4 {", dataVar, tableStartVar, tableOffset))
	g.P(fmt.Sprintf("        payloadOffset = int(binary.LittleEndian.Uint32(%s[%s+%d:]))", dataVar, tableStartVar, tableOffset))

	// If reading from a segment with relative offsets, add the base
	if len(relativeBase) > 0 && relativeBase[0] != "" {
		g.P("        if payloadOffset > 0 {")
		g.P(fmt.Sprintf("            payloadOffset += %s // convert relative offset to absolute", relativeBase[0]))
		g.P("        }")
	}

	g.P("        if payloadOffset > 0 && len(data) >= payloadOffset+4 {")
	g.P("            count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))")
	g.P(fmt.Sprintf("            m.%s = make([]*%s, 0, count)", goName, msgType))
	g.P("            currentOffset = payloadOffset + 4")
	g.P("            for i := 0; i < count; i++ {")
	g.P("                if len(data) >= currentOffset+4 {")
	g.P("                    itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))")
	g.P("                    if len(data) >= currentOffset+4+itemLen {")
	g.P(fmt.Sprintf("                        item := &%s{}", msgType))
	g.P("                        if err := item.UnmarshalSymphonyHybrid(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {")
	g.P("                            return fmt.Errorf(\"failed to unmarshal nested message: %w\", err)")
	g.P("                        }")
	g.P(fmt.Sprintf("                        m.%s = append(m.%s, item)", goName, goName))
	g.P("                        currentOffset += 4 + itemLen")
	g.P("                    }")
	g.P("                }")
	g.P("            }")
	g.P("        }")
	g.P("    }")
	g.P()
}

// Helper functions (reused from symphony plugin)

// isPublicField checks if field has is_public = true option
func isPublicField(field *protogen.Field) bool {
	if field.Desc.Options() == nil {
		return false
	}

	// Check the string representation as a workaround
	// Extensions appear in the format: "50001:1" where 50001 is the extension field number
	// and 1 means true (boolean true)
	optsStr := fmt.Sprintf("%v", field.Desc.Options())

	// Check if the options string contains "50001:1" (is_public = true)
	if optsStr != "" && optsStr != "<nil>" {
		// The extension 50001 with value 1 (true) appears as "50001:1"
		return containsSubstring(optsStr, "50001:1")
	}

	return false
}

func containsSubstring(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if i+len(substr) <= len(s) && s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// classifyFields splits fields into public and private lists, preserving declaration order
func classifyFields(msg *protogen.Message) (public, private []*protogen.Field) {
	for _, field := range msg.Fields {
		if isPublicField(field) {
			public = append(public, field)
		} else {
			private = append(private, field)
		}
	}
	return
}

// isFixedLengthField returns true if the field has a fixed size
func isFixedLengthField(field *protogen.Field) bool {
	if field.Desc.IsList() {
		return false // Repeated fields are variable-length (even if elements are fixed)
	}
	switch field.Desc.Kind() {
	case protoreflect.BoolKind, protoreflect.Int32Kind, protoreflect.Int64Kind,
		protoreflect.Uint32Kind, protoreflect.Uint64Kind,
		protoreflect.FloatKind, protoreflect.DoubleKind, protoreflect.EnumKind:
		return true
	default:
		return false
	}
}

// getFieldSize returns the size in bytes of a fixed-length field
func getFieldSize(field *protogen.Field) int {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return 1
	case protoreflect.Int32Kind, protoreflect.Uint32Kind, protoreflect.FloatKind, protoreflect.EnumKind:
		return 4
	case protoreflect.Int64Kind, protoreflect.Uint64Kind, protoreflect.DoubleKind:
		return 8
	default:
		panic(fmt.Sprintf("unknown fixed-length field kind: %s", field.Desc.Kind()))
	}
}

// isVariableLengthField returns true if the field is a variable-length field (string or bytes, singular, not nested)
func isVariableLengthField(field *protogen.Field) bool {
	if field.Desc.IsList() {
		return false // Repeated fields handled separately
	}
	if field.Desc.Kind() == protoreflect.MessageKind {
		return false // Nested messages handled separately
	}
	return field.Desc.Kind() == protoreflect.StringKind || field.Desc.Kind() == protoreflect.BytesKind
}

// isRepeatedFixedLengthField returns true if the field is a repeated fixed-length field
func isRepeatedFixedLengthField(field *protogen.Field) bool {
	if !field.Desc.IsList() {
		return false
	}
	if field.Desc.Kind() == protoreflect.MessageKind {
		return false // Repeated nested messages handled separately
	}
	switch field.Desc.Kind() {
	case protoreflect.BoolKind, protoreflect.Int32Kind, protoreflect.Int64Kind,
		protoreflect.Uint32Kind, protoreflect.Uint64Kind,
		protoreflect.FloatKind, protoreflect.DoubleKind, protoreflect.EnumKind:
		return true
	default:
		return false
	}
}

// isRepeatedVariableLengthField returns true if the field is a repeated variable-length field (repeated string or bytes)
func isRepeatedVariableLengthField(field *protogen.Field) bool {
	if !field.Desc.IsList() {
		return false
	}
	return field.Desc.Kind() == protoreflect.StringKind || field.Desc.Kind() == protoreflect.BytesKind
}

// isNestedMessageField returns true if the field is a singular nested message
func isNestedMessageField(field *protogen.Field) bool {
	if field.Desc.IsList() {
		return false // Repeated nested messages handled separately
	}
	return field.Desc.Kind() == protoreflect.MessageKind
}

// isRepeatedNestedMessageField returns true if the field is a repeated nested message
func isRepeatedNestedMessageField(field *protogen.Field) bool {
	return field.Desc.IsList() && field.Desc.Kind() == protoreflect.MessageKind
}

// getGoTypeBase returns the base Go type without the [] prefix for repeated fields
func getGoTypeBase(g *protogen.GeneratedFile, field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.EnumKind:
		return "int32"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Uint64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
	default:
		return "interface{}"
	}
}
