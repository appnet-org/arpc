// Code generated by protoc-gen-symphony. DO NOT EDIT.
package kv

import (
	"encoding/binary"
	"fmt"
)

func (m *GetRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Key): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Key
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Key)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Key)

	// === DATA REGION SECTION ===

	// Write string or bytes field (Key)
	buf = append(buf, []byte(m.Key)...)

	return buf, nil
}

func (m *GetRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Key
			// Unmarshal string or []byte field (Key)
			if entry, ok := offsets[1]; ok {
				m.Key = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *GetResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Value): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Value
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Value)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Value)

	// === DATA REGION SECTION ===

	// Write string or bytes field (Value)
	buf = append(buf, []byte(m.Value)...)

	return buf, nil
}

func (m *GetResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Value
			// Unmarshal string or []byte field (Value)
			if entry, ok := offsets[1]; ok {
				m.Value = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SetRequest) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 96)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Key): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Key
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Key)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Key)

	// Field 2 (Value): string or bytes
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Value
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Value)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Value)

	// === DATA REGION SECTION ===

	// Write string or bytes field (Key)
	buf = append(buf, []byte(m.Key)...)

	// Write string or bytes field (Value)
	buf = append(buf, []byte(m.Value)...)

	return buf, nil
}

func (m *SetRequest) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Key
			// Unmarshal string or []byte field (Key)
			if entry, ok := offsets[1]; ok {
				m.Key = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Value
			// Unmarshal string or []byte field (Value)
			if entry, ok := offsets[2]; ok {
				m.Value = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *SetResponse) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 48)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (Value): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Value
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Value)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Value)

	// === DATA REGION SECTION ===

	// Write string or bytes field (Value)
	buf = append(buf, []byte(m.Value)...)

	return buf, nil
}

func (m *SetResponse) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 2 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+1]
	offset += 1

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Value
			// Unmarshal string or []byte field (Value)
			if entry, ok := offsets[1]; ok {
				m.Value = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}
