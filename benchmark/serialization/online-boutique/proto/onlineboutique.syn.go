// Code generated by protoc-gen-symphony. DO NOT EDIT.
package onlineboutique

import (
	"encoding/binary"
	"fmt"
)

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *CartItem) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *CartItem) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	size += 4 + len(m.ProductId)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (ProductId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.ProductId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.ProductId)
	payloadOffset += 4 + len(m.ProductId)

	// Field 2 (Quantity): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(m.Quantity))

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *CartItem) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *CartItem) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (ProductId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.ProductId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Quantity): fixed-length (4 bytes)
	if len(data) < tableStart+8 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.Quantity = int32(binary.LittleEndian.Uint32(data[tableStart+4:]))

	return nil
}

func (m *CartItem) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (ProductId): variable-length payload
	size += 4 + len(m.ProductId) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (ProductId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.ProductId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.ProductId)
	privatePayloadOffset += 4 + len(m.ProductId)

	// Field 2 (Quantity): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32(m.Quantity))

	return buf, nil
}

func (m *CartItem) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (ProductId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.ProductId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Quantity): fixed-length (4 bytes)
	if len(data) < privateTableStart+8 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.Quantity = int32(binary.LittleEndian.Uint32(data[privateTableStart+4:]))

	return nil
}

type CartItemRaw []byte

func (m CartItemRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *CartItemRaw) UnmarshalSymphony(data []byte) error {
	*m = CartItemRaw(data)
	return nil
}

func (m CartItemRaw) GetProductId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (ProductId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m CartItemRaw) GetQuantity() int32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (Quantity): fixed-length (4 bytes)
	if len(m) < offsetToPrivate+5+4 {
		return 0
	}
	return int32(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
}

func (m *CartItemRaw) SetProductId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (ProductId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp CartItem
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.ProductId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = CartItemRaw(newData)
	return nil
}

func (m *CartItemRaw) SetQuantity(v int32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (Quantity): fixed-length (4 bytes)
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[offsetToPrivate+5:], uint32(v))
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *AddItemRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *AddItemRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	size += 4 + len(m.UserId)
	if m.Item != nil {
		nested, _ := m.Item.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.UserId)
	payloadOffset += 4 + len(m.UserId)

	// Field 2 (Item): nested message
	if m.Item != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.Item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+4:], 0)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *AddItemRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *AddItemRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (UserId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Item): nested message
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Item = &CartItem{}
				if err := m.Item.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

func (m *AddItemRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (UserId): variable-length payload
	size += 4 + len(m.UserId) // 4 bytes length prefix + data
	// Field 2 (Item): nested message payload
	if m.Item != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 8 // table entries
		// Field 1 (ProductId): variable-length payload
		nestedSize1 += 4 + len(m.Item.ProductId) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.UserId)
	privatePayloadOffset += 4 + len(m.UserId)

	// Field 2 (Item): nested message
	if m.Item != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.Item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+4:], 0)
	}

	return buf, nil
}

func (m *AddItemRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (UserId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Item): nested message
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Item = &CartItem{}
				if err := m.Item.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

type AddItemRequestRaw []byte

func (m AddItemRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *AddItemRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = AddItemRequestRaw(data)
	return nil
}

func (m AddItemRequestRaw) GetUserId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m AddItemRequestRaw) GetItem() CartItemRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (Item): nested message
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return CartItemRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m *AddItemRequestRaw) SetUserId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp AddItemRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.UserId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AddItemRequestRaw(newData)
	return nil
}

func (m *AddItemRequestRaw) SetItem(v CartItemRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (Item): nested message
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp AddItemRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.Item == nil {
		temp.Item = &CartItem{}
	}
	if err := temp.Item.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AddItemRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *EmptyCartRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *EmptyCartRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.UserId)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.UserId)
	payloadOffset += 4 + len(m.UserId)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *EmptyCartRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *EmptyCartRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (UserId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *EmptyCartRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (UserId): variable-length payload
	size += 4 + len(m.UserId) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.UserId)
	privatePayloadOffset += 4 + len(m.UserId)

	return buf, nil
}

func (m *EmptyCartRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (UserId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type EmptyCartRequestRaw []byte

func (m EmptyCartRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *EmptyCartRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = EmptyCartRequestRaw(data)
	return nil
}

func (m EmptyCartRequestRaw) GetUserId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *EmptyCartRequestRaw) SetUserId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp EmptyCartRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.UserId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = EmptyCartRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *GetCartRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *GetCartRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.UserId)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.UserId)
	payloadOffset += 4 + len(m.UserId)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *GetCartRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *GetCartRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (UserId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *GetCartRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (UserId): variable-length payload
	size += 4 + len(m.UserId) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.UserId)
	privatePayloadOffset += 4 + len(m.UserId)

	return buf, nil
}

func (m *GetCartRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (UserId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type GetCartRequestRaw []byte

func (m GetCartRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *GetCartRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = GetCartRequestRaw(data)
	return nil
}

func (m GetCartRequestRaw) GetUserId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *GetCartRequestRaw) SetUserId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp GetCartRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.UserId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = GetCartRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Cart) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Cart) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	size += 4 + len(m.UserId)
	size += 4 // count for Items
	for _, item := range m.Items {
		nested, _ := item.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.UserId)
	payloadOffset += 4 + len(m.UserId)

	// Field 2 (Items): repeated nested message
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	count = len(m.Items)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	payloadOffset += 4
	currentOffset = payloadStart + payloadOffset
	for _, item := range m.Items {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		payloadOffset += 4 + nestedSize
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Cart) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Cart) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (UserId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Items): repeated nested message
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Items = make([]*CartItem, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &CartItem{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Items = append(m.Items, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *Cart) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (UserId): variable-length payload
	size += 4 + len(m.UserId) // 4 bytes length prefix + data
	// Field 2 (Items): repeated nested message payload
	size += 4 // count
	for _, item := range m.Items {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 8 // table entries
		// Field 1 (ProductId): variable-length payload
		nestedSize1 += 4 + len(item.ProductId) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.UserId)
	privatePayloadOffset += 4 + len(m.UserId)

	// Field 2 (Items): repeated nested message
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.Items)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	privatePayloadOffset += 4
	currentOffset = privatePayloadStart + privatePayloadOffset
	for _, item := range m.Items {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		privatePayloadOffset += 4 + nestedSize
	}

	return buf, nil
}

func (m *Cart) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (UserId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Items): repeated nested message
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Items = make([]*CartItem, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &CartItem{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Items = append(m.Items, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type CartRaw []byte

func (m CartRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *CartRaw) UnmarshalSymphony(data []byte) error {
	*m = CartRaw(data)
	return nil
}

func (m CartRaw) GetUserId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m CartRaw) GetItems() []CartItemRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (Items): repeated nested message
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]CartItemRaw, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		nestedSize := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+nestedSize {
			return nil
		}
		result[i] = CartItemRaw(m[currentOffset+4 : currentOffset+4+nestedSize])
		currentOffset += 4 + nestedSize
	}
	return result
}

func (m *CartRaw) SetUserId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Cart
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.UserId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = CartRaw(newData)
	return nil
}

func (m *CartRaw) SetItems(v []CartItemRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (Items): repeated nested message
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes size + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemSize := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemSize
			currentOffset += 4 + itemSize
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes size + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemSize := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemSize))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemSize
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Cart
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Items = make([]*CartItem, len(v))
	for i, rawItem := range v {
		temp.Items[i] = &CartItem{}
		if err := temp.Items[i].UnmarshalSymphony([]byte(rawItem)); err != nil {
			return fmt.Errorf("failed to unmarshal nested message: %w", err)
		}
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = CartRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Empty) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Empty) MarshalSymphonyPrivate() ([]byte, error) {
	return []byte{}, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Empty) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Empty) UnmarshalSymphonyPrivate(data []byte) error {
	return nil
}

func (m *Empty) MarshalSymphony() ([]byte, error) {
	// Empty message - public segment with header only, empty private segment
	buf := make([]byte, 14)                     // 1 version + 12 reserved + 1 version for private
	buf[0] = 0x01                               // public version
	binary.LittleEndian.PutUint32(buf[1:5], 13) // offset_to_private
	// service_name and method_name stay 0
	buf[13] = 0x01 // private version
	return buf, nil
}

func (m *Empty) UnmarshalSymphony(data []byte) error {
	// Empty message - just validate version bytes
	if len(data) < 14 {
		return fmt.Errorf("invalid data: too short")
	}
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}
	return nil
}

type EmptyRaw []byte

func (m EmptyRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *EmptyRaw) UnmarshalSymphony(data []byte) error {
	*m = EmptyRaw(data)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *EmptyUser) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *EmptyUser) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.UserId)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.UserId)
	payloadOffset += 4 + len(m.UserId)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *EmptyUser) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *EmptyUser) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (UserId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *EmptyUser) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (UserId): variable-length payload
	size += 4 + len(m.UserId) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.UserId)
	privatePayloadOffset += 4 + len(m.UserId)

	return buf, nil
}

func (m *EmptyUser) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (UserId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type EmptyUserRaw []byte

func (m EmptyUserRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *EmptyUserRaw) UnmarshalSymphony(data []byte) error {
	*m = EmptyUserRaw(data)
	return nil
}

func (m EmptyUserRaw) GetUserId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *EmptyUserRaw) SetUserId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp EmptyUser
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.UserId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = EmptyUserRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *ListRecommendationsRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *ListRecommendationsRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	size += 4 + len(m.UserId)
	size += 4 // count for ProductIds
	for _, item := range m.ProductIds {
		size += 4 + len(item)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.UserId)
	payloadOffset += 4 + len(m.UserId)

	// Field 2 (ProductIds): repeated variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	count = len(m.ProductIds)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	currentOffset = payloadStart + payloadOffset + 4
	for _, item := range m.ProductIds {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	payloadOffset += 4 // count
	for _, item := range m.ProductIds {
		payloadOffset += 4 + len(item)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *ListRecommendationsRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *ListRecommendationsRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (UserId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (ProductIds): repeated variable-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.ProductIds = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.ProductIds = append(m.ProductIds, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *ListRecommendationsRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (UserId): variable-length payload
	size += 4 + len(m.UserId) // 4 bytes length prefix + data
	// Field 2 (ProductIds): repeated variable-length payload
	size += 4 // count
	for _, item := range m.ProductIds {
		size += 4 + len(item) // 4 bytes length prefix + data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.UserId)
	privatePayloadOffset += 4 + len(m.UserId)

	// Field 2 (ProductIds): repeated variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.ProductIds)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	currentOffset = privatePayloadStart + privatePayloadOffset + 4
	for _, item := range m.ProductIds {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	privatePayloadOffset += 4 // count
	for _, item := range m.ProductIds {
		privatePayloadOffset += 4 + len(item)
	}

	return buf, nil
}

func (m *ListRecommendationsRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (UserId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (ProductIds): repeated variable-length
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.ProductIds = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.ProductIds = append(m.ProductIds, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type ListRecommendationsRequestRaw []byte

func (m ListRecommendationsRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *ListRecommendationsRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = ListRecommendationsRequestRaw(data)
	return nil
}

func (m ListRecommendationsRequestRaw) GetUserId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m ListRecommendationsRequestRaw) GetProductIds() []string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (ProductIds): repeated variable-length
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]string, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		itemLen := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+itemLen {
			return nil
		}
		result[i] = string(m[currentOffset+4 : currentOffset+4+itemLen])
		currentOffset += 4 + itemLen
	}
	return result
}

func (m *ListRecommendationsRequestRaw) SetUserId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ListRecommendationsRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.UserId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ListRecommendationsRequestRaw(newData)
	return nil
}

func (m *ListRecommendationsRequestRaw) SetProductIds(v []string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (ProductIds): repeated variable-length
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes length + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemLen := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemLen
			currentOffset += 4 + itemLen
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes length + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemLen := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemLen))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemLen
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ListRecommendationsRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.ProductIds = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ListRecommendationsRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *ListRecommendationsResponse) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *ListRecommendationsResponse) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 // count for ProductIds
	for _, item := range m.ProductIds {
		size += 4 + len(item)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (ProductIds): repeated variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	count = len(m.ProductIds)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	currentOffset = payloadStart + payloadOffset + 4
	for _, item := range m.ProductIds {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	payloadOffset += 4 // count
	for _, item := range m.ProductIds {
		payloadOffset += 4 + len(item)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *ListRecommendationsResponse) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *ListRecommendationsResponse) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (ProductIds): repeated variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.ProductIds = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.ProductIds = append(m.ProductIds, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *ListRecommendationsResponse) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (ProductIds): repeated variable-length payload
	size += 4 // count
	for _, item := range m.ProductIds {
		size += 4 + len(item) // 4 bytes length prefix + data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (ProductIds): repeated variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.ProductIds)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	currentOffset = privatePayloadStart + privatePayloadOffset + 4
	for _, item := range m.ProductIds {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	privatePayloadOffset += 4 // count
	for _, item := range m.ProductIds {
		privatePayloadOffset += 4 + len(item)
	}

	return buf, nil
}

func (m *ListRecommendationsResponse) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (ProductIds): repeated variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.ProductIds = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.ProductIds = append(m.ProductIds, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type ListRecommendationsResponseRaw []byte

func (m ListRecommendationsResponseRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *ListRecommendationsResponseRaw) UnmarshalSymphony(data []byte) error {
	*m = ListRecommendationsResponseRaw(data)
	return nil
}

func (m ListRecommendationsResponseRaw) GetProductIds() []string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (ProductIds): repeated variable-length
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]string, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		itemLen := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+itemLen {
			return nil
		}
		result[i] = string(m[currentOffset+4 : currentOffset+4+itemLen])
		currentOffset += 4 + itemLen
	}
	return result
}

func (m *ListRecommendationsResponseRaw) SetProductIds(v []string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (ProductIds): repeated variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes length + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemLen := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemLen
			currentOffset += 4 + itemLen
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes length + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemLen := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemLen))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemLen
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ListRecommendationsResponse
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.ProductIds = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ListRecommendationsResponseRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Product) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Product) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 24 // table
	size += 4 + len(m.Id)
	size += 4 + len(m.Name)
	size += 4 + len(m.Description)
	size += 4 + len(m.Picture)
	if m.PriceUsd != nil {
		nested, _ := m.PriceUsd.MarshalSymphony()
		size += 4 + len(nested)
	}
	size += 4 // count for Categories
	for _, item := range m.Categories {
		size += 4 + len(item)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 24
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Id): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.Id)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.Id)
	payloadOffset += 4 + len(m.Id)

	// Field 2 (Name): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.Name)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.Name)
	payloadOffset += 4 + len(m.Name)

	// Field 3 (Description): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+8:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.Description)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.Description)
	payloadOffset += 4 + len(m.Description)

	// Field 4 (Picture): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+12:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.Picture)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.Picture)
	payloadOffset += 4 + len(m.Picture)

	// Field 5 (PriceUsd): nested message
	if m.PriceUsd != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+16:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.PriceUsd.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+16:], 0)
	}

	// Field 6 (Categories): repeated variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+20:], uint32(payloadStart+payloadOffset))
	count = len(m.Categories)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	currentOffset = payloadStart + payloadOffset + 4
	for _, item := range m.Categories {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	payloadOffset += 4 // count
	for _, item := range m.Categories {
		payloadOffset += 4 + len(item)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Product) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Product) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Id): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Id = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Name): variable-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Name = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 3 (Description): variable-length
	if len(data) >= tableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+8:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Description = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 4 (Picture): variable-length
	if len(data) >= tableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+12:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Picture = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 5 (PriceUsd): nested message
	if len(data) >= tableStart+16+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+16:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.PriceUsd = &Money{}
				if err := m.PriceUsd.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 6 (Categories): repeated variable-length
	if len(data) >= tableStart+20+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+20:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Categories = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.Categories = append(m.Categories, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *Product) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1  // version byte
	size += 24 // table entries
	// Field 1 (Id): variable-length payload
	size += 4 + len(m.Id) // 4 bytes length prefix + data
	// Field 2 (Name): variable-length payload
	size += 4 + len(m.Name) // 4 bytes length prefix + data
	// Field 3 (Description): variable-length payload
	size += 4 + len(m.Description) // 4 bytes length prefix + data
	// Field 4 (Picture): variable-length payload
	size += 4 + len(m.Picture) // 4 bytes length prefix + data
	// Field 5 (PriceUsd): nested message payload
	if m.PriceUsd != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 16 // table entries
		// Field 1 (CurrencyCode): variable-length payload
		nestedSize1 += 4 + len(m.PriceUsd.CurrencyCode) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Field 6 (Categories): repeated variable-length payload
	size += 4 // count
	for _, item := range m.Categories {
		size += 4 + len(item) // 4 bytes length prefix + data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 24 bytes table
	privatePayloadStart := privateTableStart + 24
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Id): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.Id)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.Id)
	privatePayloadOffset += 4 + len(m.Id)

	// Field 2 (Name): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.Name)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.Name)
	privatePayloadOffset += 4 + len(m.Name)

	// Field 3 (Description): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+8:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.Description)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.Description)
	privatePayloadOffset += 4 + len(m.Description)

	// Field 4 (Picture): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+12:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.Picture)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.Picture)
	privatePayloadOffset += 4 + len(m.Picture)

	// Field 5 (PriceUsd): nested message
	if m.PriceUsd != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+16:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.PriceUsd.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+16:], 0)
	}

	// Field 6 (Categories): repeated variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+20:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.Categories)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	currentOffset = privatePayloadStart + privatePayloadOffset + 4
	for _, item := range m.Categories {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	privatePayloadOffset += 4 // count
	for _, item := range m.Categories {
		privatePayloadOffset += 4 + len(item)
	}

	return buf, nil
}

func (m *Product) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Id): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Id = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Name): variable-length
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Name = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 3 (Description): variable-length
	if len(data) >= privateTableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+8:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Description = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 4 (Picture): variable-length
	if len(data) >= privateTableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+12:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Picture = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 5 (PriceUsd): nested message
	if len(data) >= privateTableStart+16+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+16:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.PriceUsd = &Money{}
				if err := m.PriceUsd.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 6 (Categories): repeated variable-length
	if len(data) >= privateTableStart+20+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+20:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Categories = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.Categories = append(m.Categories, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type ProductRaw []byte

func (m ProductRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *ProductRaw) UnmarshalSymphony(data []byte) error {
	*m = ProductRaw(data)
	return nil
}

func (m ProductRaw) GetId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Id): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m ProductRaw) GetName() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (Name): variable-length
	if len(m) < offsetToPrivate+5+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m ProductRaw) GetDescription() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 3 (Description): variable-length
	if len(m) < offsetToPrivate+9+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+9:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m ProductRaw) GetPicture() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 4 (Picture): variable-length
	if len(m) < offsetToPrivate+13+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+13:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m ProductRaw) GetPriceUsd() MoneyRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 5 (PriceUsd): nested message
	if len(m) < offsetToPrivate+17+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+17:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return MoneyRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m ProductRaw) GetCategories() []string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 6 (Categories): repeated variable-length
	if len(m) < offsetToPrivate+21+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+21:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]string, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		itemLen := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+itemLen {
			return nil
		}
		result[i] = string(m[currentOffset+4 : currentOffset+4+itemLen])
		currentOffset += 4 + itemLen
	}
	return result
}

func (m *ProductRaw) SetId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Id): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Product
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Id = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ProductRaw(newData)
	return nil
}

func (m *ProductRaw) SetName(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (Name): variable-length
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Product
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Name = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ProductRaw(newData)
	return nil
}

func (m *ProductRaw) SetDescription(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 3 (Description): variable-length
	if len(*m) < offsetToPrivate+9+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+9:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Product
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Description = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ProductRaw(newData)
	return nil
}

func (m *ProductRaw) SetPicture(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 4 (Picture): variable-length
	if len(*m) < offsetToPrivate+13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+13:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Product
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Picture = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ProductRaw(newData)
	return nil
}

func (m *ProductRaw) SetPriceUsd(v MoneyRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 5 (PriceUsd): nested message
	if len(*m) < offsetToPrivate+17+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+17:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Product
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.PriceUsd == nil {
		temp.PriceUsd = &Money{}
	}
	if err := temp.PriceUsd.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ProductRaw(newData)
	return nil
}

func (m *ProductRaw) SetCategories(v []string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 6 (Categories): repeated variable-length
	if len(*m) < offsetToPrivate+21+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+21:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes length + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemLen := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemLen
			currentOffset += 4 + itemLen
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes length + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemLen := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemLen))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemLen
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Product
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Categories = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ProductRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *ListProductsResponse) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *ListProductsResponse) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 // count for Products
	for _, item := range m.Products {
		nested, _ := item.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Products): repeated nested message
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	count = len(m.Products)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	payloadOffset += 4
	currentOffset = payloadStart + payloadOffset
	for _, item := range m.Products {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		payloadOffset += 4 + nestedSize
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *ListProductsResponse) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *ListProductsResponse) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Products): repeated nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Products = make([]*Product, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &Product{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Products = append(m.Products, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *ListProductsResponse) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (Products): repeated nested message payload
	size += 4 // count
	for _, item := range m.Products {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 24 // table entries
		// Field 1 (Id): variable-length payload
		nestedSize1 += 4 + len(item.Id) // 4 bytes length prefix + data
		// Field 2 (Name): variable-length payload
		nestedSize1 += 4 + len(item.Name) // 4 bytes length prefix + data
		// Field 3 (Description): variable-length payload
		nestedSize1 += 4 + len(item.Description) // 4 bytes length prefix + data
		// Field 4 (Picture): variable-length payload
		nestedSize1 += 4 + len(item.Picture) // 4 bytes length prefix + data
		// Field 5 (PriceUsd): nested message payload
		if item.PriceUsd != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			// Private segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 16 // table entries
			// Field 1 (CurrencyCode): variable-length payload
			nestedSize2 += 4 + len(item.PriceUsd.CurrencyCode) // 4 bytes length prefix + data

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}
		// Field 6 (Categories): repeated variable-length payload
		nestedSize1 += 4 // count
		for _, item := range item.Categories {
			nestedSize1 += 4 + len(item) // 4 bytes length prefix + data
		}

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Products): repeated nested message
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.Products)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	privatePayloadOffset += 4
	currentOffset = privatePayloadStart + privatePayloadOffset
	for _, item := range m.Products {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		privatePayloadOffset += 4 + nestedSize
	}

	return buf, nil
}

func (m *ListProductsResponse) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Products): repeated nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Products = make([]*Product, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &Product{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Products = append(m.Products, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type ListProductsResponseRaw []byte

func (m ListProductsResponseRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *ListProductsResponseRaw) UnmarshalSymphony(data []byte) error {
	*m = ListProductsResponseRaw(data)
	return nil
}

func (m ListProductsResponseRaw) GetProducts() []ProductRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Products): repeated nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]ProductRaw, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		nestedSize := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+nestedSize {
			return nil
		}
		result[i] = ProductRaw(m[currentOffset+4 : currentOffset+4+nestedSize])
		currentOffset += 4 + nestedSize
	}
	return result
}

func (m *ListProductsResponseRaw) SetProducts(v []ProductRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Products): repeated nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes size + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemSize := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemSize
			currentOffset += 4 + itemSize
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes size + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemSize := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemSize))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemSize
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ListProductsResponse
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Products = make([]*Product, len(v))
	for i, rawItem := range v {
		temp.Products[i] = &Product{}
		if err := temp.Products[i].UnmarshalSymphony([]byte(rawItem)); err != nil {
			return fmt.Errorf("failed to unmarshal nested message: %w", err)
		}
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ListProductsResponseRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *GetProductRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *GetProductRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.Id)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Id): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.Id)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.Id)
	payloadOffset += 4 + len(m.Id)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *GetProductRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *GetProductRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Id): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Id = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *GetProductRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (Id): variable-length payload
	size += 4 + len(m.Id) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Id): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.Id)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.Id)
	privatePayloadOffset += 4 + len(m.Id)

	return buf, nil
}

func (m *GetProductRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Id): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Id = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type GetProductRequestRaw []byte

func (m GetProductRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *GetProductRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = GetProductRequestRaw(data)
	return nil
}

func (m GetProductRequestRaw) GetId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Id): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *GetProductRequestRaw) SetId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Id): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp GetProductRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Id = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = GetProductRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *SearchProductsRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *SearchProductsRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.Query)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Query): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.Query)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.Query)
	payloadOffset += 4 + len(m.Query)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *SearchProductsRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *SearchProductsRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Query): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Query = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *SearchProductsRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (Query): variable-length payload
	size += 4 + len(m.Query) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Query): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.Query)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.Query)
	privatePayloadOffset += 4 + len(m.Query)

	return buf, nil
}

func (m *SearchProductsRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Query): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Query = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type SearchProductsRequestRaw []byte

func (m SearchProductsRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *SearchProductsRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = SearchProductsRequestRaw(data)
	return nil
}

func (m SearchProductsRequestRaw) GetQuery() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Query): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *SearchProductsRequestRaw) SetQuery(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Query): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp SearchProductsRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Query = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = SearchProductsRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *SearchProductsResponse) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *SearchProductsResponse) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 // count for Results
	for _, item := range m.Results {
		nested, _ := item.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Results): repeated nested message
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	count = len(m.Results)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	payloadOffset += 4
	currentOffset = payloadStart + payloadOffset
	for _, item := range m.Results {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		payloadOffset += 4 + nestedSize
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *SearchProductsResponse) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *SearchProductsResponse) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Results): repeated nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Results = make([]*Product, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &Product{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Results = append(m.Results, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *SearchProductsResponse) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (Results): repeated nested message payload
	size += 4 // count
	for _, item := range m.Results {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 24 // table entries
		// Field 1 (Id): variable-length payload
		nestedSize1 += 4 + len(item.Id) // 4 bytes length prefix + data
		// Field 2 (Name): variable-length payload
		nestedSize1 += 4 + len(item.Name) // 4 bytes length prefix + data
		// Field 3 (Description): variable-length payload
		nestedSize1 += 4 + len(item.Description) // 4 bytes length prefix + data
		// Field 4 (Picture): variable-length payload
		nestedSize1 += 4 + len(item.Picture) // 4 bytes length prefix + data
		// Field 5 (PriceUsd): nested message payload
		if item.PriceUsd != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			// Private segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 16 // table entries
			// Field 1 (CurrencyCode): variable-length payload
			nestedSize2 += 4 + len(item.PriceUsd.CurrencyCode) // 4 bytes length prefix + data

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}
		// Field 6 (Categories): repeated variable-length payload
		nestedSize1 += 4 // count
		for _, item := range item.Categories {
			nestedSize1 += 4 + len(item) // 4 bytes length prefix + data
		}

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Results): repeated nested message
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.Results)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	privatePayloadOffset += 4
	currentOffset = privatePayloadStart + privatePayloadOffset
	for _, item := range m.Results {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		privatePayloadOffset += 4 + nestedSize
	}

	return buf, nil
}

func (m *SearchProductsResponse) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Results): repeated nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Results = make([]*Product, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &Product{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Results = append(m.Results, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type SearchProductsResponseRaw []byte

func (m SearchProductsResponseRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *SearchProductsResponseRaw) UnmarshalSymphony(data []byte) error {
	*m = SearchProductsResponseRaw(data)
	return nil
}

func (m SearchProductsResponseRaw) GetResults() []ProductRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Results): repeated nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]ProductRaw, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		nestedSize := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+nestedSize {
			return nil
		}
		result[i] = ProductRaw(m[currentOffset+4 : currentOffset+4+nestedSize])
		currentOffset += 4 + nestedSize
	}
	return result
}

func (m *SearchProductsResponseRaw) SetResults(v []ProductRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Results): repeated nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes size + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemSize := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemSize
			currentOffset += 4 + itemSize
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes size + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemSize := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemSize))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemSize
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp SearchProductsResponse
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Results = make([]*Product, len(v))
	for i, rawItem := range v {
		temp.Results[i] = &Product{}
		if err := temp.Results[i].UnmarshalSymphony([]byte(rawItem)); err != nil {
			return fmt.Errorf("failed to unmarshal nested message: %w", err)
		}
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = SearchProductsResponseRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *GetQuoteRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *GetQuoteRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	if m.Address != nil {
		nested, _ := m.Address.MarshalSymphony()
		size += 4 + len(nested)
	}
	size += 4 // count for Items
	for _, item := range m.Items {
		nested, _ := item.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Address): nested message
	if m.Address != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.Address.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], 0)
	}

	// Field 2 (Items): repeated nested message
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	count = len(m.Items)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	payloadOffset += 4
	currentOffset = payloadStart + payloadOffset
	for _, item := range m.Items {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		payloadOffset += 4 + nestedSize
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *GetQuoteRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *GetQuoteRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Address): nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Address = &Address{}
				if err := m.Address.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 2 (Items): repeated nested message
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Items = make([]*CartItem, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &CartItem{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Items = append(m.Items, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *GetQuoteRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (Address): nested message payload
	if m.Address != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 20 // table entries
		// Field 1 (StreetAddress): variable-length payload
		nestedSize1 += 4 + len(m.Address.StreetAddress) // 4 bytes length prefix + data
		// Field 2 (City): variable-length payload
		nestedSize1 += 4 + len(m.Address.City) // 4 bytes length prefix + data
		// Field 3 (State): variable-length payload
		nestedSize1 += 4 + len(m.Address.State) // 4 bytes length prefix + data
		// Field 4 (Country): variable-length payload
		nestedSize1 += 4 + len(m.Address.Country) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Field 2 (Items): repeated nested message payload
	size += 4 // count
	for _, item := range m.Items {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 8 // table entries
		// Field 1 (ProductId): variable-length payload
		nestedSize1 += 4 + len(item.ProductId) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Address): nested message
	if m.Address != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.Address.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], 0)
	}

	// Field 2 (Items): repeated nested message
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.Items)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	privatePayloadOffset += 4
	currentOffset = privatePayloadStart + privatePayloadOffset
	for _, item := range m.Items {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		privatePayloadOffset += 4 + nestedSize
	}

	return buf, nil
}

func (m *GetQuoteRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Address): nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Address = &Address{}
				if err := m.Address.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 2 (Items): repeated nested message
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Items = make([]*CartItem, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &CartItem{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Items = append(m.Items, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type GetQuoteRequestRaw []byte

func (m GetQuoteRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *GetQuoteRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = GetQuoteRequestRaw(data)
	return nil
}

func (m GetQuoteRequestRaw) GetAddress() AddressRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Address): nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return AddressRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m GetQuoteRequestRaw) GetItems() []CartItemRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (Items): repeated nested message
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]CartItemRaw, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		nestedSize := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+nestedSize {
			return nil
		}
		result[i] = CartItemRaw(m[currentOffset+4 : currentOffset+4+nestedSize])
		currentOffset += 4 + nestedSize
	}
	return result
}

func (m *GetQuoteRequestRaw) SetAddress(v AddressRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Address): nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp GetQuoteRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.Address == nil {
		temp.Address = &Address{}
	}
	if err := temp.Address.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = GetQuoteRequestRaw(newData)
	return nil
}

func (m *GetQuoteRequestRaw) SetItems(v []CartItemRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (Items): repeated nested message
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes size + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemSize := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemSize
			currentOffset += 4 + itemSize
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes size + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemSize := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemSize))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemSize
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp GetQuoteRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Items = make([]*CartItem, len(v))
	for i, rawItem := range v {
		temp.Items[i] = &CartItem{}
		if err := temp.Items[i].UnmarshalSymphony([]byte(rawItem)); err != nil {
			return fmt.Errorf("failed to unmarshal nested message: %w", err)
		}
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = GetQuoteRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *GetQuoteResponse) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *GetQuoteResponse) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	if m.CostUsd != nil {
		nested, _ := m.CostUsd.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (CostUsd): nested message
	if m.CostUsd != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.CostUsd.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], 0)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *GetQuoteResponse) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *GetQuoteResponse) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (CostUsd): nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.CostUsd = &Money{}
				if err := m.CostUsd.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

func (m *GetQuoteResponse) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (CostUsd): nested message payload
	if m.CostUsd != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 16 // table entries
		// Field 1 (CurrencyCode): variable-length payload
		nestedSize1 += 4 + len(m.CostUsd.CurrencyCode) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (CostUsd): nested message
	if m.CostUsd != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.CostUsd.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], 0)
	}

	return buf, nil
}

func (m *GetQuoteResponse) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (CostUsd): nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.CostUsd = &Money{}
				if err := m.CostUsd.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

type GetQuoteResponseRaw []byte

func (m GetQuoteResponseRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *GetQuoteResponseRaw) UnmarshalSymphony(data []byte) error {
	*m = GetQuoteResponseRaw(data)
	return nil
}

func (m GetQuoteResponseRaw) GetCostUsd() MoneyRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (CostUsd): nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return MoneyRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m *GetQuoteResponseRaw) SetCostUsd(v MoneyRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (CostUsd): nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp GetQuoteResponse
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.CostUsd == nil {
		temp.CostUsd = &Money{}
	}
	if err := temp.CostUsd.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = GetQuoteResponseRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *ShipOrderRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *ShipOrderRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	if m.Address != nil {
		nested, _ := m.Address.MarshalSymphony()
		size += 4 + len(nested)
	}
	size += 4 // count for Items
	for _, item := range m.Items {
		nested, _ := item.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Address): nested message
	if m.Address != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.Address.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], 0)
	}

	// Field 2 (Items): repeated nested message
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	count = len(m.Items)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	payloadOffset += 4
	currentOffset = payloadStart + payloadOffset
	for _, item := range m.Items {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		payloadOffset += 4 + nestedSize
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *ShipOrderRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *ShipOrderRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Address): nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Address = &Address{}
				if err := m.Address.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 2 (Items): repeated nested message
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Items = make([]*CartItem, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &CartItem{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Items = append(m.Items, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *ShipOrderRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (Address): nested message payload
	if m.Address != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 20 // table entries
		// Field 1 (StreetAddress): variable-length payload
		nestedSize1 += 4 + len(m.Address.StreetAddress) // 4 bytes length prefix + data
		// Field 2 (City): variable-length payload
		nestedSize1 += 4 + len(m.Address.City) // 4 bytes length prefix + data
		// Field 3 (State): variable-length payload
		nestedSize1 += 4 + len(m.Address.State) // 4 bytes length prefix + data
		// Field 4 (Country): variable-length payload
		nestedSize1 += 4 + len(m.Address.Country) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Field 2 (Items): repeated nested message payload
	size += 4 // count
	for _, item := range m.Items {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 8 // table entries
		// Field 1 (ProductId): variable-length payload
		nestedSize1 += 4 + len(item.ProductId) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Address): nested message
	if m.Address != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.Address.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], 0)
	}

	// Field 2 (Items): repeated nested message
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.Items)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	privatePayloadOffset += 4
	currentOffset = privatePayloadStart + privatePayloadOffset
	for _, item := range m.Items {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		privatePayloadOffset += 4 + nestedSize
	}

	return buf, nil
}

func (m *ShipOrderRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Address): nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Address = &Address{}
				if err := m.Address.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 2 (Items): repeated nested message
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Items = make([]*CartItem, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &CartItem{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Items = append(m.Items, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type ShipOrderRequestRaw []byte

func (m ShipOrderRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *ShipOrderRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = ShipOrderRequestRaw(data)
	return nil
}

func (m ShipOrderRequestRaw) GetAddress() AddressRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Address): nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return AddressRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m ShipOrderRequestRaw) GetItems() []CartItemRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (Items): repeated nested message
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]CartItemRaw, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		nestedSize := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+nestedSize {
			return nil
		}
		result[i] = CartItemRaw(m[currentOffset+4 : currentOffset+4+nestedSize])
		currentOffset += 4 + nestedSize
	}
	return result
}

func (m *ShipOrderRequestRaw) SetAddress(v AddressRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Address): nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ShipOrderRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.Address == nil {
		temp.Address = &Address{}
	}
	if err := temp.Address.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ShipOrderRequestRaw(newData)
	return nil
}

func (m *ShipOrderRequestRaw) SetItems(v []CartItemRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (Items): repeated nested message
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes size + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemSize := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemSize
			currentOffset += 4 + itemSize
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes size + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemSize := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemSize))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemSize
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ShipOrderRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Items = make([]*CartItem, len(v))
	for i, rawItem := range v {
		temp.Items[i] = &CartItem{}
		if err := temp.Items[i].UnmarshalSymphony([]byte(rawItem)); err != nil {
			return fmt.Errorf("failed to unmarshal nested message: %w", err)
		}
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ShipOrderRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *ShipOrderResponse) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *ShipOrderResponse) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.TrackingId)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (TrackingId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.TrackingId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.TrackingId)
	payloadOffset += 4 + len(m.TrackingId)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *ShipOrderResponse) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *ShipOrderResponse) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (TrackingId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.TrackingId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *ShipOrderResponse) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (TrackingId): variable-length payload
	size += 4 + len(m.TrackingId) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (TrackingId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.TrackingId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.TrackingId)
	privatePayloadOffset += 4 + len(m.TrackingId)

	return buf, nil
}

func (m *ShipOrderResponse) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (TrackingId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.TrackingId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type ShipOrderResponseRaw []byte

func (m ShipOrderResponseRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *ShipOrderResponseRaw) UnmarshalSymphony(data []byte) error {
	*m = ShipOrderResponseRaw(data)
	return nil
}

func (m ShipOrderResponseRaw) GetTrackingId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (TrackingId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *ShipOrderResponseRaw) SetTrackingId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (TrackingId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ShipOrderResponse
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.TrackingId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ShipOrderResponseRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Address) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Address) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 20 // table
	size += 4 + len(m.StreetAddress)
	size += 4 + len(m.City)
	size += 4 + len(m.State)
	size += 4 + len(m.Country)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 20
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (StreetAddress): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.StreetAddress)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.StreetAddress)
	payloadOffset += 4 + len(m.StreetAddress)

	// Field 2 (City): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.City)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.City)
	payloadOffset += 4 + len(m.City)

	// Field 3 (State): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+8:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.State)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.State)
	payloadOffset += 4 + len(m.State)

	// Field 4 (Country): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+12:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.Country)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.Country)
	payloadOffset += 4 + len(m.Country)

	// Field 5 (ZipCode): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+16:], uint32(m.ZipCode))

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Address) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Address) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (StreetAddress): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.StreetAddress = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (City): variable-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.City = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 3 (State): variable-length
	if len(data) >= tableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+8:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.State = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 4 (Country): variable-length
	if len(data) >= tableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+12:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Country = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 5 (ZipCode): fixed-length (4 bytes)
	if len(data) < tableStart+20 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.ZipCode = int32(binary.LittleEndian.Uint32(data[tableStart+16:]))

	return nil
}

func (m *Address) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1  // version byte
	size += 20 // table entries
	// Field 1 (StreetAddress): variable-length payload
	size += 4 + len(m.StreetAddress) // 4 bytes length prefix + data
	// Field 2 (City): variable-length payload
	size += 4 + len(m.City) // 4 bytes length prefix + data
	// Field 3 (State): variable-length payload
	size += 4 + len(m.State) // 4 bytes length prefix + data
	// Field 4 (Country): variable-length payload
	size += 4 + len(m.Country) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 20 bytes table
	privatePayloadStart := privateTableStart + 20
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (StreetAddress): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.StreetAddress)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.StreetAddress)
	privatePayloadOffset += 4 + len(m.StreetAddress)

	// Field 2 (City): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.City)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.City)
	privatePayloadOffset += 4 + len(m.City)

	// Field 3 (State): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+8:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.State)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.State)
	privatePayloadOffset += 4 + len(m.State)

	// Field 4 (Country): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+12:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.Country)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.Country)
	privatePayloadOffset += 4 + len(m.Country)

	// Field 5 (ZipCode): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[privateTableStart+16:], uint32(m.ZipCode))

	return buf, nil
}

func (m *Address) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (StreetAddress): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.StreetAddress = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (City): variable-length
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.City = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 3 (State): variable-length
	if len(data) >= privateTableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+8:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.State = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 4 (Country): variable-length
	if len(data) >= privateTableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+12:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Country = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 5 (ZipCode): fixed-length (4 bytes)
	if len(data) < privateTableStart+20 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.ZipCode = int32(binary.LittleEndian.Uint32(data[privateTableStart+16:]))

	return nil
}

type AddressRaw []byte

func (m AddressRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *AddressRaw) UnmarshalSymphony(data []byte) error {
	*m = AddressRaw(data)
	return nil
}

func (m AddressRaw) GetStreetAddress() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (StreetAddress): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m AddressRaw) GetCity() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (City): variable-length
	if len(m) < offsetToPrivate+5+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m AddressRaw) GetState() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 3 (State): variable-length
	if len(m) < offsetToPrivate+9+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+9:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m AddressRaw) GetCountry() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 4 (Country): variable-length
	if len(m) < offsetToPrivate+13+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+13:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m AddressRaw) GetZipCode() int32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 5 (ZipCode): fixed-length (4 bytes)
	if len(m) < offsetToPrivate+17+4 {
		return 0
	}
	return int32(binary.LittleEndian.Uint32(m[offsetToPrivate+17:]))
}

func (m *AddressRaw) SetStreetAddress(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (StreetAddress): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Address
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.StreetAddress = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AddressRaw(newData)
	return nil
}

func (m *AddressRaw) SetCity(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (City): variable-length
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Address
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.City = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AddressRaw(newData)
	return nil
}

func (m *AddressRaw) SetState(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 3 (State): variable-length
	if len(*m) < offsetToPrivate+9+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+9:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Address
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.State = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AddressRaw(newData)
	return nil
}

func (m *AddressRaw) SetCountry(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 4 (Country): variable-length
	if len(*m) < offsetToPrivate+13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+13:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Address
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Country = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AddressRaw(newData)
	return nil
}

func (m *AddressRaw) SetZipCode(v int32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 5 (ZipCode): fixed-length (4 bytes)
	if len(*m) < offsetToPrivate+17+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[offsetToPrivate+17:], uint32(v))
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Money) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Money) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 16 // table
	size += 4 + len(m.CurrencyCode)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 16
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (CurrencyCode): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.CurrencyCode)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.CurrencyCode)
	payloadOffset += 4 + len(m.CurrencyCode)

	// Field 2 (Units): fixed-length (8 bytes)
	binary.LittleEndian.PutUint64(buf[tableStart+4:], uint64(m.Units))

	// Field 3 (Nanos): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+12:], uint32(m.Nanos))

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Money) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Money) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (CurrencyCode): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.CurrencyCode = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Units): fixed-length (8 bytes)
	if len(data) < tableStart+12 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.Units = int64(binary.LittleEndian.Uint64(data[tableStart+4:]))

	// Field 3 (Nanos): fixed-length (4 bytes)
	if len(data) < tableStart+16 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.Nanos = int32(binary.LittleEndian.Uint32(data[tableStart+12:]))

	return nil
}

func (m *Money) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1  // version byte
	size += 16 // table entries
	// Field 1 (CurrencyCode): variable-length payload
	size += 4 + len(m.CurrencyCode) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 16 bytes table
	privatePayloadStart := privateTableStart + 16
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (CurrencyCode): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.CurrencyCode)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.CurrencyCode)
	privatePayloadOffset += 4 + len(m.CurrencyCode)

	// Field 2 (Units): fixed-length (8 bytes)
	binary.LittleEndian.PutUint64(buf[privateTableStart+4:], uint64(m.Units))

	// Field 3 (Nanos): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[privateTableStart+12:], uint32(m.Nanos))

	return buf, nil
}

func (m *Money) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (CurrencyCode): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.CurrencyCode = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Units): fixed-length (8 bytes)
	if len(data) < privateTableStart+12 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.Units = int64(binary.LittleEndian.Uint64(data[privateTableStart+4:]))

	// Field 3 (Nanos): fixed-length (4 bytes)
	if len(data) < privateTableStart+16 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.Nanos = int32(binary.LittleEndian.Uint32(data[privateTableStart+12:]))

	return nil
}

type MoneyRaw []byte

func (m MoneyRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *MoneyRaw) UnmarshalSymphony(data []byte) error {
	*m = MoneyRaw(data)
	return nil
}

func (m MoneyRaw) GetCurrencyCode() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (CurrencyCode): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m MoneyRaw) GetUnits() int64 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (Units): fixed-length (8 bytes)
	if len(m) < offsetToPrivate+5+8 {
		return 0
	}
	return int64(binary.LittleEndian.Uint64(m[offsetToPrivate+5:]))
}

func (m MoneyRaw) GetNanos() int32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 3 (Nanos): fixed-length (4 bytes)
	if len(m) < offsetToPrivate+13+4 {
		return 0
	}
	return int32(binary.LittleEndian.Uint32(m[offsetToPrivate+13:]))
}

func (m *MoneyRaw) SetCurrencyCode(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (CurrencyCode): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Money
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.CurrencyCode = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = MoneyRaw(newData)
	return nil
}

func (m *MoneyRaw) SetUnits(v int64) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (Units): fixed-length (8 bytes)
	if len(*m) < offsetToPrivate+5+8 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint64((*m)[offsetToPrivate+5:], uint64(v))
	return nil
}

func (m *MoneyRaw) SetNanos(v int32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 3 (Nanos): fixed-length (4 bytes)
	if len(*m) < offsetToPrivate+13+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[offsetToPrivate+13:], uint32(v))
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *GetSupportedCurrenciesResponse) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *GetSupportedCurrenciesResponse) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 // count for CurrencyCodes
	for _, item := range m.CurrencyCodes {
		size += 4 + len(item)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (CurrencyCodes): repeated variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	count = len(m.CurrencyCodes)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	currentOffset = payloadStart + payloadOffset + 4
	for _, item := range m.CurrencyCodes {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	payloadOffset += 4 // count
	for _, item := range m.CurrencyCodes {
		payloadOffset += 4 + len(item)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *GetSupportedCurrenciesResponse) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *GetSupportedCurrenciesResponse) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (CurrencyCodes): repeated variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.CurrencyCodes = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.CurrencyCodes = append(m.CurrencyCodes, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *GetSupportedCurrenciesResponse) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (CurrencyCodes): repeated variable-length payload
	size += 4 // count
	for _, item := range m.CurrencyCodes {
		size += 4 + len(item) // 4 bytes length prefix + data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (CurrencyCodes): repeated variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.CurrencyCodes)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	currentOffset = privatePayloadStart + privatePayloadOffset + 4
	for _, item := range m.CurrencyCodes {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	privatePayloadOffset += 4 // count
	for _, item := range m.CurrencyCodes {
		privatePayloadOffset += 4 + len(item)
	}

	return buf, nil
}

func (m *GetSupportedCurrenciesResponse) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (CurrencyCodes): repeated variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.CurrencyCodes = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.CurrencyCodes = append(m.CurrencyCodes, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type GetSupportedCurrenciesResponseRaw []byte

func (m GetSupportedCurrenciesResponseRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *GetSupportedCurrenciesResponseRaw) UnmarshalSymphony(data []byte) error {
	*m = GetSupportedCurrenciesResponseRaw(data)
	return nil
}

func (m GetSupportedCurrenciesResponseRaw) GetCurrencyCodes() []string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (CurrencyCodes): repeated variable-length
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]string, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		itemLen := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+itemLen {
			return nil
		}
		result[i] = string(m[currentOffset+4 : currentOffset+4+itemLen])
		currentOffset += 4 + itemLen
	}
	return result
}

func (m *GetSupportedCurrenciesResponseRaw) SetCurrencyCodes(v []string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (CurrencyCodes): repeated variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes length + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemLen := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemLen
			currentOffset += 4 + itemLen
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes length + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemLen := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemLen))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemLen
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp GetSupportedCurrenciesResponse
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.CurrencyCodes = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = GetSupportedCurrenciesResponseRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *CurrencyConversionRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *CurrencyConversionRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 12 // table
	if m.From != nil {
		nested, _ := m.From.MarshalSymphony()
		size += 4 + len(nested)
	}
	size += 4 + len(m.ToCode)
	size += 4 + len(m.UserId)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 12
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (From): nested message
	if m.From != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.From.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], 0)
	}

	// Field 2 (ToCode): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.ToCode)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.ToCode)
	payloadOffset += 4 + len(m.ToCode)

	// Field 3 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+8:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.UserId)
	payloadOffset += 4 + len(m.UserId)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *CurrencyConversionRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *CurrencyConversionRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (From): nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.From = &Money{}
				if err := m.From.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 2 (ToCode): variable-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.ToCode = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 3 (UserId): variable-length
	if len(data) >= tableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+8:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *CurrencyConversionRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1  // version byte
	size += 12 // table entries
	// Field 1 (From): nested message payload
	if m.From != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 16 // table entries
		// Field 1 (CurrencyCode): variable-length payload
		nestedSize1 += 4 + len(m.From.CurrencyCode) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Field 2 (ToCode): variable-length payload
	size += 4 + len(m.ToCode) // 4 bytes length prefix + data
	// Field 3 (UserId): variable-length payload
	size += 4 + len(m.UserId) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 12 bytes table
	privatePayloadStart := privateTableStart + 12
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (From): nested message
	if m.From != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.From.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], 0)
	}

	// Field 2 (ToCode): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.ToCode)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.ToCode)
	privatePayloadOffset += 4 + len(m.ToCode)

	// Field 3 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+8:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.UserId)
	privatePayloadOffset += 4 + len(m.UserId)

	return buf, nil
}

func (m *CurrencyConversionRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (From): nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.From = &Money{}
				if err := m.From.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 2 (ToCode): variable-length
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.ToCode = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 3 (UserId): variable-length
	if len(data) >= privateTableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+8:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type CurrencyConversionRequestRaw []byte

func (m CurrencyConversionRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *CurrencyConversionRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = CurrencyConversionRequestRaw(data)
	return nil
}

func (m CurrencyConversionRequestRaw) GetFrom() MoneyRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (From): nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return MoneyRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m CurrencyConversionRequestRaw) GetToCode() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (ToCode): variable-length
	if len(m) < offsetToPrivate+5+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m CurrencyConversionRequestRaw) GetUserId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 3 (UserId): variable-length
	if len(m) < offsetToPrivate+9+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+9:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *CurrencyConversionRequestRaw) SetFrom(v MoneyRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (From): nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp CurrencyConversionRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.From == nil {
		temp.From = &Money{}
	}
	if err := temp.From.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = CurrencyConversionRequestRaw(newData)
	return nil
}

func (m *CurrencyConversionRequestRaw) SetToCode(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (ToCode): variable-length
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp CurrencyConversionRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.ToCode = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = CurrencyConversionRequestRaw(newData)
	return nil
}

func (m *CurrencyConversionRequestRaw) SetUserId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 3 (UserId): variable-length
	if len(*m) < offsetToPrivate+9+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+9:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp CurrencyConversionRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.UserId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = CurrencyConversionRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *CreditCardInfo) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *CreditCardInfo) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 16 // table
	size += 4 + len(m.CreditCardNumber)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 16
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (CreditCardNumber): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.CreditCardNumber)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.CreditCardNumber)
	payloadOffset += 4 + len(m.CreditCardNumber)

	// Field 2 (CreditCardCvv): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(m.CreditCardCvv))

	// Field 3 (CreditCardExpirationYear): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+8:], uint32(m.CreditCardExpirationYear))

	// Field 4 (CreditCardExpirationMonth): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[tableStart+12:], uint32(m.CreditCardExpirationMonth))

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *CreditCardInfo) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *CreditCardInfo) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (CreditCardNumber): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.CreditCardNumber = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (CreditCardCvv): fixed-length (4 bytes)
	if len(data) < tableStart+8 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.CreditCardCvv = int32(binary.LittleEndian.Uint32(data[tableStart+4:]))

	// Field 3 (CreditCardExpirationYear): fixed-length (4 bytes)
	if len(data) < tableStart+12 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.CreditCardExpirationYear = int32(binary.LittleEndian.Uint32(data[tableStart+8:]))

	// Field 4 (CreditCardExpirationMonth): fixed-length (4 bytes)
	if len(data) < tableStart+16 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.CreditCardExpirationMonth = int32(binary.LittleEndian.Uint32(data[tableStart+12:]))

	return nil
}

func (m *CreditCardInfo) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1  // version byte
	size += 16 // table entries
	// Field 1 (CreditCardNumber): variable-length payload
	size += 4 + len(m.CreditCardNumber) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 16 bytes table
	privatePayloadStart := privateTableStart + 16
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (CreditCardNumber): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.CreditCardNumber)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.CreditCardNumber)
	privatePayloadOffset += 4 + len(m.CreditCardNumber)

	// Field 2 (CreditCardCvv): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32(m.CreditCardCvv))

	// Field 3 (CreditCardExpirationYear): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[privateTableStart+8:], uint32(m.CreditCardExpirationYear))

	// Field 4 (CreditCardExpirationMonth): fixed-length (4 bytes)
	binary.LittleEndian.PutUint32(buf[privateTableStart+12:], uint32(m.CreditCardExpirationMonth))

	return buf, nil
}

func (m *CreditCardInfo) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (CreditCardNumber): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.CreditCardNumber = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (CreditCardCvv): fixed-length (4 bytes)
	if len(data) < privateTableStart+8 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.CreditCardCvv = int32(binary.LittleEndian.Uint32(data[privateTableStart+4:]))

	// Field 3 (CreditCardExpirationYear): fixed-length (4 bytes)
	if len(data) < privateTableStart+12 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.CreditCardExpirationYear = int32(binary.LittleEndian.Uint32(data[privateTableStart+8:]))

	// Field 4 (CreditCardExpirationMonth): fixed-length (4 bytes)
	if len(data) < privateTableStart+16 {
		return fmt.Errorf("invalid data: too short for field")
	}
	m.CreditCardExpirationMonth = int32(binary.LittleEndian.Uint32(data[privateTableStart+12:]))

	return nil
}

type CreditCardInfoRaw []byte

func (m CreditCardInfoRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *CreditCardInfoRaw) UnmarshalSymphony(data []byte) error {
	*m = CreditCardInfoRaw(data)
	return nil
}

func (m CreditCardInfoRaw) GetCreditCardNumber() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (CreditCardNumber): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m CreditCardInfoRaw) GetCreditCardCvv() int32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (CreditCardCvv): fixed-length (4 bytes)
	if len(m) < offsetToPrivate+5+4 {
		return 0
	}
	return int32(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
}

func (m CreditCardInfoRaw) GetCreditCardExpirationYear() int32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 3 (CreditCardExpirationYear): fixed-length (4 bytes)
	if len(m) < offsetToPrivate+9+4 {
		return 0
	}
	return int32(binary.LittleEndian.Uint32(m[offsetToPrivate+9:]))
}

func (m CreditCardInfoRaw) GetCreditCardExpirationMonth() int32 {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 4 (CreditCardExpirationMonth): fixed-length (4 bytes)
	if len(m) < offsetToPrivate+13+4 {
		return 0
	}
	return int32(binary.LittleEndian.Uint32(m[offsetToPrivate+13:]))
}

func (m *CreditCardInfoRaw) SetCreditCardNumber(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (CreditCardNumber): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp CreditCardInfo
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.CreditCardNumber = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = CreditCardInfoRaw(newData)
	return nil
}

func (m *CreditCardInfoRaw) SetCreditCardCvv(v int32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (CreditCardCvv): fixed-length (4 bytes)
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[offsetToPrivate+5:], uint32(v))
	return nil
}

func (m *CreditCardInfoRaw) SetCreditCardExpirationYear(v int32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 3 (CreditCardExpirationYear): fixed-length (4 bytes)
	if len(*m) < offsetToPrivate+9+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[offsetToPrivate+9:], uint32(v))
	return nil
}

func (m *CreditCardInfoRaw) SetCreditCardExpirationMonth(v int32) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 4 (CreditCardExpirationMonth): fixed-length (4 bytes)
	if len(*m) < offsetToPrivate+13+4 {
		return fmt.Errorf("buffer too short")
	}
	binary.LittleEndian.PutUint32((*m)[offsetToPrivate+13:], uint32(v))
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *ChargeRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *ChargeRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	if m.Amount != nil {
		nested, _ := m.Amount.MarshalSymphony()
		size += 4 + len(nested)
	}
	if m.CreditCard != nil {
		nested, _ := m.CreditCard.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Amount): nested message
	if m.Amount != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.Amount.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], 0)
	}

	// Field 2 (CreditCard): nested message
	if m.CreditCard != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.CreditCard.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+4:], 0)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *ChargeRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *ChargeRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Amount): nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Amount = &Money{}
				if err := m.Amount.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 2 (CreditCard): nested message
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.CreditCard = &CreditCardInfo{}
				if err := m.CreditCard.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

func (m *ChargeRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (Amount): nested message payload
	if m.Amount != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 16 // table entries
		// Field 1 (CurrencyCode): variable-length payload
		nestedSize1 += 4 + len(m.Amount.CurrencyCode) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Field 2 (CreditCard): nested message payload
	if m.CreditCard != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 16 // table entries
		// Field 1 (CreditCardNumber): variable-length payload
		nestedSize1 += 4 + len(m.CreditCard.CreditCardNumber) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Amount): nested message
	if m.Amount != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.Amount.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], 0)
	}

	// Field 2 (CreditCard): nested message
	if m.CreditCard != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.CreditCard.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+4:], 0)
	}

	return buf, nil
}

func (m *ChargeRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Amount): nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Amount = &Money{}
				if err := m.Amount.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 2 (CreditCard): nested message
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.CreditCard = &CreditCardInfo{}
				if err := m.CreditCard.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

type ChargeRequestRaw []byte

func (m ChargeRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *ChargeRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = ChargeRequestRaw(data)
	return nil
}

func (m ChargeRequestRaw) GetAmount() MoneyRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Amount): nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return MoneyRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m ChargeRequestRaw) GetCreditCard() CreditCardInfoRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (CreditCard): nested message
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return CreditCardInfoRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m *ChargeRequestRaw) SetAmount(v MoneyRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Amount): nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ChargeRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.Amount == nil {
		temp.Amount = &Money{}
	}
	if err := temp.Amount.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ChargeRequestRaw(newData)
	return nil
}

func (m *ChargeRequestRaw) SetCreditCard(v CreditCardInfoRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (CreditCard): nested message
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ChargeRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.CreditCard == nil {
		temp.CreditCard = &CreditCardInfo{}
	}
	if err := temp.CreditCard.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ChargeRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *ChargeResponse) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *ChargeResponse) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 + len(m.TransactionId)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (TransactionId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.TransactionId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.TransactionId)
	payloadOffset += 4 + len(m.TransactionId)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *ChargeResponse) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *ChargeResponse) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (TransactionId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.TransactionId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *ChargeResponse) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (TransactionId): variable-length payload
	size += 4 + len(m.TransactionId) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (TransactionId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.TransactionId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.TransactionId)
	privatePayloadOffset += 4 + len(m.TransactionId)

	return buf, nil
}

func (m *ChargeResponse) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (TransactionId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.TransactionId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type ChargeResponseRaw []byte

func (m ChargeResponseRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *ChargeResponseRaw) UnmarshalSymphony(data []byte) error {
	*m = ChargeResponseRaw(data)
	return nil
}

func (m ChargeResponseRaw) GetTransactionId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (TransactionId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *ChargeResponseRaw) SetTransactionId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (TransactionId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp ChargeResponse
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.TransactionId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = ChargeResponseRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *OrderItem) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *OrderItem) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	if m.Item != nil {
		nested, _ := m.Item.MarshalSymphony()
		size += 4 + len(nested)
	}
	if m.Cost != nil {
		nested, _ := m.Cost.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Item): nested message
	if m.Item != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.Item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], 0)
	}

	// Field 2 (Cost): nested message
	if m.Cost != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.Cost.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+4:], 0)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *OrderItem) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *OrderItem) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Item): nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Item = &CartItem{}
				if err := m.Item.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 2 (Cost): nested message
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Cost = &Money{}
				if err := m.Cost.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

func (m *OrderItem) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (Item): nested message payload
	if m.Item != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 8 // table entries
		// Field 1 (ProductId): variable-length payload
		nestedSize1 += 4 + len(m.Item.ProductId) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Field 2 (Cost): nested message payload
	if m.Cost != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 16 // table entries
		// Field 1 (CurrencyCode): variable-length payload
		nestedSize1 += 4 + len(m.Cost.CurrencyCode) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Item): nested message
	if m.Item != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.Item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], 0)
	}

	// Field 2 (Cost): nested message
	if m.Cost != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.Cost.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+4:], 0)
	}

	return buf, nil
}

func (m *OrderItem) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Item): nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Item = &CartItem{}
				if err := m.Item.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 2 (Cost): nested message
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Cost = &Money{}
				if err := m.Cost.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

type OrderItemRaw []byte

func (m OrderItemRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *OrderItemRaw) UnmarshalSymphony(data []byte) error {
	*m = OrderItemRaw(data)
	return nil
}

func (m OrderItemRaw) GetItem() CartItemRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Item): nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return CartItemRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m OrderItemRaw) GetCost() MoneyRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (Cost): nested message
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return MoneyRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m *OrderItemRaw) SetItem(v CartItemRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Item): nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp OrderItem
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.Item == nil {
		temp.Item = &CartItem{}
	}
	if err := temp.Item.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = OrderItemRaw(newData)
	return nil
}

func (m *OrderItemRaw) SetCost(v MoneyRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (Cost): nested message
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp OrderItem
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.Cost == nil {
		temp.Cost = &Money{}
	}
	if err := temp.Cost.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = OrderItemRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *OrderResult) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *OrderResult) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 20 // table
	size += 4 + len(m.OrderId)
	size += 4 + len(m.ShippingTrackingId)
	if m.ShippingCost != nil {
		nested, _ := m.ShippingCost.MarshalSymphony()
		size += 4 + len(nested)
	}
	if m.ShippingAddress != nil {
		nested, _ := m.ShippingAddress.MarshalSymphony()
		size += 4 + len(nested)
	}
	size += 4 // count for Items
	for _, item := range m.Items {
		nested, _ := item.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 20
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (OrderId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.OrderId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.OrderId)
	payloadOffset += 4 + len(m.OrderId)

	// Field 2 (ShippingTrackingId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.ShippingTrackingId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.ShippingTrackingId)
	payloadOffset += 4 + len(m.ShippingTrackingId)

	// Field 3 (ShippingCost): nested message
	if m.ShippingCost != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+8:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.ShippingCost.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+8:], 0)
	}

	// Field 4 (ShippingAddress): nested message
	if m.ShippingAddress != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+12:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.ShippingAddress.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+12:], 0)
	}

	// Field 5 (Items): repeated nested message
	binary.LittleEndian.PutUint32(buf[tableStart+16:], uint32(payloadStart+payloadOffset))
	count = len(m.Items)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	payloadOffset += 4
	currentOffset = payloadStart + payloadOffset
	for _, item := range m.Items {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		payloadOffset += 4 + nestedSize
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *OrderResult) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *OrderResult) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (OrderId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.OrderId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (ShippingTrackingId): variable-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.ShippingTrackingId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 3 (ShippingCost): nested message
	if len(data) >= tableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+8:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.ShippingCost = &Money{}
				if err := m.ShippingCost.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 4 (ShippingAddress): nested message
	if len(data) >= tableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+12:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.ShippingAddress = &Address{}
				if err := m.ShippingAddress.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 5 (Items): repeated nested message
	if len(data) >= tableStart+16+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+16:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Items = make([]*OrderItem, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &OrderItem{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Items = append(m.Items, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *OrderResult) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1  // version byte
	size += 20 // table entries
	// Field 1 (OrderId): variable-length payload
	size += 4 + len(m.OrderId) // 4 bytes length prefix + data
	// Field 2 (ShippingTrackingId): variable-length payload
	size += 4 + len(m.ShippingTrackingId) // 4 bytes length prefix + data
	// Field 3 (ShippingCost): nested message payload
	if m.ShippingCost != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 16 // table entries
		// Field 1 (CurrencyCode): variable-length payload
		nestedSize1 += 4 + len(m.ShippingCost.CurrencyCode) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Field 4 (ShippingAddress): nested message payload
	if m.ShippingAddress != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 20 // table entries
		// Field 1 (StreetAddress): variable-length payload
		nestedSize1 += 4 + len(m.ShippingAddress.StreetAddress) // 4 bytes length prefix + data
		// Field 2 (City): variable-length payload
		nestedSize1 += 4 + len(m.ShippingAddress.City) // 4 bytes length prefix + data
		// Field 3 (State): variable-length payload
		nestedSize1 += 4 + len(m.ShippingAddress.State) // 4 bytes length prefix + data
		// Field 4 (Country): variable-length payload
		nestedSize1 += 4 + len(m.ShippingAddress.Country) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Field 5 (Items): repeated nested message payload
	size += 4 // count
	for _, item := range m.Items {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 8 // table entries
		// Field 1 (Item): nested message payload
		if item.Item != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			// Private segment:
			nestedSize2 += 1 // version byte
			nestedSize2 += 8 // table entries
			// Field 1 (ProductId): variable-length payload
			nestedSize2 += 4 + len(item.Item.ProductId) // 4 bytes length prefix + data

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}
		// Field 2 (Cost): nested message payload
		if item.Cost != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			// Private segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 16 // table entries
			// Field 1 (CurrencyCode): variable-length payload
			nestedSize2 += 4 + len(item.Cost.CurrencyCode) // 4 bytes length prefix + data

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 20 bytes table
	privatePayloadStart := privateTableStart + 20
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (OrderId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.OrderId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.OrderId)
	privatePayloadOffset += 4 + len(m.OrderId)

	// Field 2 (ShippingTrackingId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.ShippingTrackingId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.ShippingTrackingId)
	privatePayloadOffset += 4 + len(m.ShippingTrackingId)

	// Field 3 (ShippingCost): nested message
	if m.ShippingCost != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+8:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.ShippingCost.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+8:], 0)
	}

	// Field 4 (ShippingAddress): nested message
	if m.ShippingAddress != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+12:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.ShippingAddress.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+12:], 0)
	}

	// Field 5 (Items): repeated nested message
	binary.LittleEndian.PutUint32(buf[privateTableStart+16:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.Items)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	privatePayloadOffset += 4
	currentOffset = privatePayloadStart + privatePayloadOffset
	for _, item := range m.Items {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		privatePayloadOffset += 4 + nestedSize
	}

	return buf, nil
}

func (m *OrderResult) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (OrderId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.OrderId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (ShippingTrackingId): variable-length
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.ShippingTrackingId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 3 (ShippingCost): nested message
	if len(data) >= privateTableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+8:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.ShippingCost = &Money{}
				if err := m.ShippingCost.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 4 (ShippingAddress): nested message
	if len(data) >= privateTableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+12:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.ShippingAddress = &Address{}
				if err := m.ShippingAddress.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 5 (Items): repeated nested message
	if len(data) >= privateTableStart+16+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+16:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Items = make([]*OrderItem, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &OrderItem{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Items = append(m.Items, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type OrderResultRaw []byte

func (m OrderResultRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *OrderResultRaw) UnmarshalSymphony(data []byte) error {
	*m = OrderResultRaw(data)
	return nil
}

func (m OrderResultRaw) GetOrderId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (OrderId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m OrderResultRaw) GetShippingTrackingId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (ShippingTrackingId): variable-length
	if len(m) < offsetToPrivate+5+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m OrderResultRaw) GetShippingCost() MoneyRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 3 (ShippingCost): nested message
	if len(m) < offsetToPrivate+9+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+9:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return MoneyRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m OrderResultRaw) GetShippingAddress() AddressRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 4 (ShippingAddress): nested message
	if len(m) < offsetToPrivate+13+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+13:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return AddressRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m OrderResultRaw) GetItems() []OrderItemRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 5 (Items): repeated nested message
	if len(m) < offsetToPrivate+17+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+17:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]OrderItemRaw, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		nestedSize := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+nestedSize {
			return nil
		}
		result[i] = OrderItemRaw(m[currentOffset+4 : currentOffset+4+nestedSize])
		currentOffset += 4 + nestedSize
	}
	return result
}

func (m *OrderResultRaw) SetOrderId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (OrderId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp OrderResult
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.OrderId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = OrderResultRaw(newData)
	return nil
}

func (m *OrderResultRaw) SetShippingTrackingId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (ShippingTrackingId): variable-length
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp OrderResult
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.ShippingTrackingId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = OrderResultRaw(newData)
	return nil
}

func (m *OrderResultRaw) SetShippingCost(v MoneyRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 3 (ShippingCost): nested message
	if len(*m) < offsetToPrivate+9+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+9:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp OrderResult
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.ShippingCost == nil {
		temp.ShippingCost = &Money{}
	}
	if err := temp.ShippingCost.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = OrderResultRaw(newData)
	return nil
}

func (m *OrderResultRaw) SetShippingAddress(v AddressRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 4 (ShippingAddress): nested message
	if len(*m) < offsetToPrivate+13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+13:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp OrderResult
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.ShippingAddress == nil {
		temp.ShippingAddress = &Address{}
	}
	if err := temp.ShippingAddress.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = OrderResultRaw(newData)
	return nil
}

func (m *OrderResultRaw) SetItems(v []OrderItemRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 5 (Items): repeated nested message
	if len(*m) < offsetToPrivate+17+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+17:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes size + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemSize := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemSize
			currentOffset += 4 + itemSize
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes size + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemSize := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemSize))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemSize
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp OrderResult
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Items = make([]*OrderItem, len(v))
	for i, rawItem := range v {
		temp.Items[i] = &OrderItem{}
		if err := temp.Items[i].UnmarshalSymphony([]byte(rawItem)); err != nil {
			return fmt.Errorf("failed to unmarshal nested message: %w", err)
		}
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = OrderResultRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *SendOrderConfirmationRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *SendOrderConfirmationRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	size += 4 + len(m.Email)
	if m.Order != nil {
		nested, _ := m.Order.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Email): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.Email)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.Email)
	payloadOffset += 4 + len(m.Email)

	// Field 2 (Order): nested message
	if m.Order != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.Order.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+4:], 0)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *SendOrderConfirmationRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *SendOrderConfirmationRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Email): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Email = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Order): nested message
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Order = &OrderResult{}
				if err := m.Order.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

func (m *SendOrderConfirmationRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (Email): variable-length payload
	size += 4 + len(m.Email) // 4 bytes length prefix + data
	// Field 2 (Order): nested message payload
	if m.Order != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 20 // table entries
		// Field 1 (OrderId): variable-length payload
		nestedSize1 += 4 + len(m.Order.OrderId) // 4 bytes length prefix + data
		// Field 2 (ShippingTrackingId): variable-length payload
		nestedSize1 += 4 + len(m.Order.ShippingTrackingId) // 4 bytes length prefix + data
		// Field 3 (ShippingCost): nested message payload
		if m.Order.ShippingCost != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			// Private segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 16 // table entries
			// Field 1 (CurrencyCode): variable-length payload
			nestedSize2 += 4 + len(m.Order.ShippingCost.CurrencyCode) // 4 bytes length prefix + data

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}
		// Field 4 (ShippingAddress): nested message payload
		if m.Order.ShippingAddress != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			// Private segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 20 // table entries
			// Field 1 (StreetAddress): variable-length payload
			nestedSize2 += 4 + len(m.Order.ShippingAddress.StreetAddress) // 4 bytes length prefix + data
			// Field 2 (City): variable-length payload
			nestedSize2 += 4 + len(m.Order.ShippingAddress.City) // 4 bytes length prefix + data
			// Field 3 (State): variable-length payload
			nestedSize2 += 4 + len(m.Order.ShippingAddress.State) // 4 bytes length prefix + data
			// Field 4 (Country): variable-length payload
			nestedSize2 += 4 + len(m.Order.ShippingAddress.Country) // 4 bytes length prefix + data

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}
		// Field 5 (Items): repeated nested message payload
		nestedSize1 += 4 // count
		for _, item := range m.Order.Items {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			// Private segment:
			nestedSize2 += 1 // version byte
			nestedSize2 += 8 // table entries
			// Field 1 (Item): nested message payload
			if item.Item != nil {
				nestedSize3 := 0
				// Public segment:
				nestedSize3 += 1  // version byte
				nestedSize3 += 12 // reserved: offset_to_private, service_name, method_name
				// Private segment:
				nestedSize3 += 1 // version byte
				nestedSize3 += 8 // table entries
				// Field 1 (ProductId): variable-length payload
				nestedSize3 += 4 + len(item.Item.ProductId) // 4 bytes length prefix + data

				nestedSize2 += 4 + nestedSize3 // 4 bytes size + message data
			}
			// Field 2 (Cost): nested message payload
			if item.Cost != nil {
				nestedSize3 := 0
				// Public segment:
				nestedSize3 += 1  // version byte
				nestedSize3 += 12 // reserved: offset_to_private, service_name, method_name
				// Private segment:
				nestedSize3 += 1  // version byte
				nestedSize3 += 16 // table entries
				// Field 1 (CurrencyCode): variable-length payload
				nestedSize3 += 4 + len(item.Cost.CurrencyCode) // 4 bytes length prefix + data

				nestedSize2 += 4 + nestedSize3 // 4 bytes size + message data
			}

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Email): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.Email)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.Email)
	privatePayloadOffset += 4 + len(m.Email)

	// Field 2 (Order): nested message
	if m.Order != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.Order.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+4:], 0)
	}

	return buf, nil
}

func (m *SendOrderConfirmationRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Email): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Email = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Order): nested message
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Order = &OrderResult{}
				if err := m.Order.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

type SendOrderConfirmationRequestRaw []byte

func (m SendOrderConfirmationRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *SendOrderConfirmationRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = SendOrderConfirmationRequestRaw(data)
	return nil
}

func (m SendOrderConfirmationRequestRaw) GetEmail() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Email): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m SendOrderConfirmationRequestRaw) GetOrder() OrderResultRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (Order): nested message
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return OrderResultRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m *SendOrderConfirmationRequestRaw) SetEmail(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Email): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp SendOrderConfirmationRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Email = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = SendOrderConfirmationRequestRaw(newData)
	return nil
}

func (m *SendOrderConfirmationRequestRaw) SetOrder(v OrderResultRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (Order): nested message
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp SendOrderConfirmationRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.Order == nil {
		temp.Order = &OrderResult{}
	}
	if err := temp.Order.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = SendOrderConfirmationRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *PlaceOrderRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *PlaceOrderRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 20 // table
	size += 4 + len(m.UserId)
	size += 4 + len(m.UserCurrency)
	if m.Address != nil {
		nested, _ := m.Address.MarshalSymphony()
		size += 4 + len(nested)
	}
	size += 4 + len(m.Email)
	if m.CreditCard != nil {
		nested, _ := m.CreditCard.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 20
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.UserId)
	payloadOffset += 4 + len(m.UserId)

	// Field 2 (UserCurrency): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.UserCurrency)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.UserCurrency)
	payloadOffset += 4 + len(m.UserCurrency)

	// Field 3 (Address): nested message
	if m.Address != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+8:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.Address.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+8:], 0)
	}

	// Field 5 (Email): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+12:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.Email)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.Email)
	payloadOffset += 4 + len(m.Email)

	// Field 6 (CreditCard): nested message
	if m.CreditCard != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+16:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.CreditCard.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+16:], 0)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *PlaceOrderRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *PlaceOrderRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (UserId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (UserCurrency): variable-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserCurrency = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 3 (Address): nested message
	if len(data) >= tableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+8:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Address = &Address{}
				if err := m.Address.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 5 (Email): variable-length
	if len(data) >= tableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+12:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Email = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 6 (CreditCard): nested message
	if len(data) >= tableStart+16+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+16:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.CreditCard = &CreditCardInfo{}
				if err := m.CreditCard.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

func (m *PlaceOrderRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1  // version byte
	size += 20 // table entries
	// Field 1 (UserId): variable-length payload
	size += 4 + len(m.UserId) // 4 bytes length prefix + data
	// Field 2 (UserCurrency): variable-length payload
	size += 4 + len(m.UserCurrency) // 4 bytes length prefix + data
	// Field 3 (Address): nested message payload
	if m.Address != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 20 // table entries
		// Field 1 (StreetAddress): variable-length payload
		nestedSize1 += 4 + len(m.Address.StreetAddress) // 4 bytes length prefix + data
		// Field 2 (City): variable-length payload
		nestedSize1 += 4 + len(m.Address.City) // 4 bytes length prefix + data
		// Field 3 (State): variable-length payload
		nestedSize1 += 4 + len(m.Address.State) // 4 bytes length prefix + data
		// Field 4 (Country): variable-length payload
		nestedSize1 += 4 + len(m.Address.Country) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}
	// Field 5 (Email): variable-length payload
	size += 4 + len(m.Email) // 4 bytes length prefix + data
	// Field 6 (CreditCard): nested message payload
	if m.CreditCard != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 16 // table entries
		// Field 1 (CreditCardNumber): variable-length payload
		nestedSize1 += 4 + len(m.CreditCard.CreditCardNumber) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 20 bytes table
	privatePayloadStart := privateTableStart + 20
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.UserId)
	privatePayloadOffset += 4 + len(m.UserId)

	// Field 2 (UserCurrency): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.UserCurrency)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.UserCurrency)
	privatePayloadOffset += 4 + len(m.UserCurrency)

	// Field 3 (Address): nested message
	if m.Address != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+8:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.Address.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+8:], 0)
	}

	// Field 5 (Email): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+12:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.Email)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.Email)
	privatePayloadOffset += 4 + len(m.Email)

	// Field 6 (CreditCard): nested message
	if m.CreditCard != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+16:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.CreditCard.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+16:], 0)
	}

	return buf, nil
}

func (m *PlaceOrderRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (UserId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (UserCurrency): variable-length
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserCurrency = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 3 (Address): nested message
	if len(data) >= privateTableStart+8+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+8:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Address = &Address{}
				if err := m.Address.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	// Field 5 (Email): variable-length
	if len(data) >= privateTableStart+12+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+12:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Email = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 6 (CreditCard): nested message
	if len(data) >= privateTableStart+16+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+16:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.CreditCard = &CreditCardInfo{}
				if err := m.CreditCard.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

type PlaceOrderRequestRaw []byte

func (m PlaceOrderRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *PlaceOrderRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = PlaceOrderRequestRaw(data)
	return nil
}

func (m PlaceOrderRequestRaw) GetUserId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m PlaceOrderRequestRaw) GetUserCurrency() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (UserCurrency): variable-length
	if len(m) < offsetToPrivate+5+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m PlaceOrderRequestRaw) GetAddress() AddressRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 3 (Address): nested message
	if len(m) < offsetToPrivate+9+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+9:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return AddressRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m PlaceOrderRequestRaw) GetEmail() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 5 (Email): variable-length
	if len(m) < offsetToPrivate+13+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+13:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m PlaceOrderRequestRaw) GetCreditCard() CreditCardInfoRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 6 (CreditCard): nested message
	if len(m) < offsetToPrivate+17+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+17:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return CreditCardInfoRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m *PlaceOrderRequestRaw) SetUserId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp PlaceOrderRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.UserId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = PlaceOrderRequestRaw(newData)
	return nil
}

func (m *PlaceOrderRequestRaw) SetUserCurrency(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (UserCurrency): variable-length
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp PlaceOrderRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.UserCurrency = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = PlaceOrderRequestRaw(newData)
	return nil
}

func (m *PlaceOrderRequestRaw) SetAddress(v AddressRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 3 (Address): nested message
	if len(*m) < offsetToPrivate+9+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+9:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp PlaceOrderRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.Address == nil {
		temp.Address = &Address{}
	}
	if err := temp.Address.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = PlaceOrderRequestRaw(newData)
	return nil
}

func (m *PlaceOrderRequestRaw) SetEmail(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 5 (Email): variable-length
	if len(*m) < offsetToPrivate+13+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+13:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp PlaceOrderRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Email = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = PlaceOrderRequestRaw(newData)
	return nil
}

func (m *PlaceOrderRequestRaw) SetCreditCard(v CreditCardInfoRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 6 (CreditCard): nested message
	if len(*m) < offsetToPrivate+17+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+17:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp PlaceOrderRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.CreditCard == nil {
		temp.CreditCard = &CreditCardInfo{}
	}
	if err := temp.CreditCard.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = PlaceOrderRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *PlaceOrderResponse) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *PlaceOrderResponse) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	if m.Order != nil {
		nested, _ := m.Order.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Order): nested message
	if m.Order != nil {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
		nestedData, err := m.Order.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(nestedSize))
		copy(buf[payloadStart+payloadOffset+4:], nestedData)
		payloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[tableStart+0:], 0)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *PlaceOrderResponse) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *PlaceOrderResponse) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Order): nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Order = &OrderResult{}
				if err := m.Order.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

func (m *PlaceOrderResponse) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (Order): nested message payload
	if m.Order != nil {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 20 // table entries
		// Field 1 (OrderId): variable-length payload
		nestedSize1 += 4 + len(m.Order.OrderId) // 4 bytes length prefix + data
		// Field 2 (ShippingTrackingId): variable-length payload
		nestedSize1 += 4 + len(m.Order.ShippingTrackingId) // 4 bytes length prefix + data
		// Field 3 (ShippingCost): nested message payload
		if m.Order.ShippingCost != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			// Private segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 16 // table entries
			// Field 1 (CurrencyCode): variable-length payload
			nestedSize2 += 4 + len(m.Order.ShippingCost.CurrencyCode) // 4 bytes length prefix + data

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}
		// Field 4 (ShippingAddress): nested message payload
		if m.Order.ShippingAddress != nil {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			// Private segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 20 // table entries
			// Field 1 (StreetAddress): variable-length payload
			nestedSize2 += 4 + len(m.Order.ShippingAddress.StreetAddress) // 4 bytes length prefix + data
			// Field 2 (City): variable-length payload
			nestedSize2 += 4 + len(m.Order.ShippingAddress.City) // 4 bytes length prefix + data
			// Field 3 (State): variable-length payload
			nestedSize2 += 4 + len(m.Order.ShippingAddress.State) // 4 bytes length prefix + data
			// Field 4 (Country): variable-length payload
			nestedSize2 += 4 + len(m.Order.ShippingAddress.Country) // 4 bytes length prefix + data

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}
		// Field 5 (Items): repeated nested message payload
		nestedSize1 += 4 // count
		for _, item := range m.Order.Items {
			nestedSize2 := 0
			// Public segment:
			nestedSize2 += 1  // version byte
			nestedSize2 += 12 // reserved: offset_to_private, service_name, method_name
			// Private segment:
			nestedSize2 += 1 // version byte
			nestedSize2 += 8 // table entries
			// Field 1 (Item): nested message payload
			if item.Item != nil {
				nestedSize3 := 0
				// Public segment:
				nestedSize3 += 1  // version byte
				nestedSize3 += 12 // reserved: offset_to_private, service_name, method_name
				// Private segment:
				nestedSize3 += 1 // version byte
				nestedSize3 += 8 // table entries
				// Field 1 (ProductId): variable-length payload
				nestedSize3 += 4 + len(item.Item.ProductId) // 4 bytes length prefix + data

				nestedSize2 += 4 + nestedSize3 // 4 bytes size + message data
			}
			// Field 2 (Cost): nested message payload
			if item.Cost != nil {
				nestedSize3 := 0
				// Public segment:
				nestedSize3 += 1  // version byte
				nestedSize3 += 12 // reserved: offset_to_private, service_name, method_name
				// Private segment:
				nestedSize3 += 1  // version byte
				nestedSize3 += 16 // table entries
				// Field 1 (CurrencyCode): variable-length payload
				nestedSize3 += 4 + len(item.Cost.CurrencyCode) // 4 bytes length prefix + data

				nestedSize2 += 4 + nestedSize3 // 4 bytes size + message data
			}

			nestedSize1 += 4 + nestedSize2 // 4 bytes size + message data
		}

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Order): nested message
	if m.Order != nil {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
		nestedData, err := m.Order.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(nestedSize))
		copy(buf[privatePayloadStart+privatePayloadOffset+4:], nestedData)
		privatePayloadOffset += 4 + nestedSize
	} else {
		binary.LittleEndian.PutUint32(buf[privateTableStart+0:], 0)
	}

	return buf, nil
}

func (m *PlaceOrderResponse) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Order): nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Order = &OrderResult{}
				if err := m.Order.UnmarshalSymphony(data[payloadOffset+4 : payloadOffset+4+dataLen]); err != nil {
					return fmt.Errorf("failed to unmarshal nested message: %w", err)
				}
			}
		}
	}

	return nil
}

type PlaceOrderResponseRaw []byte

func (m PlaceOrderResponseRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *PlaceOrderResponseRaw) UnmarshalSymphony(data []byte) error {
	*m = PlaceOrderResponseRaw(data)
	return nil
}

func (m PlaceOrderResponseRaw) GetOrder() OrderResultRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Order): nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	nestedSize := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+nestedSize {
		return nil
	}
	return OrderResultRaw(m[payloadOffset+4 : payloadOffset+4+nestedSize])
}

func (m *PlaceOrderResponseRaw) SetOrder(v OrderResultRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Order): nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldNestedSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldNestedSize = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newNestedSize := len(v)
	if oldPayloadOffset > 0 && newNestedSize <= oldNestedSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newNestedSize))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp PlaceOrderResponse
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	if temp.Order == nil {
		temp.Order = &OrderResult{}
	}
	if err := temp.Order.UnmarshalSymphony([]byte(v)); err != nil {
		return fmt.Errorf("failed to unmarshal nested message: %w", err)
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = PlaceOrderResponseRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *AdRequest) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *AdRequest) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	size += 4 + len(m.UserId)
	size += 4 // count for ContextKeys
	for _, item := range m.ContextKeys {
		size += 4 + len(item)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.UserId)
	payloadOffset += 4 + len(m.UserId)

	// Field 2 (ContextKeys): repeated variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	count = len(m.ContextKeys)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	currentOffset = payloadStart + payloadOffset + 4
	for _, item := range m.ContextKeys {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	payloadOffset += 4 // count
	for _, item := range m.ContextKeys {
		payloadOffset += 4 + len(item)
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *AdRequest) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *AdRequest) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (UserId): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (ContextKeys): repeated variable-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.ContextKeys = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.ContextKeys = append(m.ContextKeys, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *AdRequest) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (UserId): variable-length payload
	size += 4 + len(m.UserId) // 4 bytes length prefix + data
	// Field 2 (ContextKeys): repeated variable-length payload
	size += 4 // count
	for _, item := range m.ContextKeys {
		size += 4 + len(item) // 4 bytes length prefix + data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (UserId): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.UserId)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.UserId)
	privatePayloadOffset += 4 + len(m.UserId)

	// Field 2 (ContextKeys): repeated variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.ContextKeys)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	currentOffset = privatePayloadStart + privatePayloadOffset + 4
	for _, item := range m.ContextKeys {
		itemLen := len(item)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(itemLen))
		copy(buf[currentOffset+4:], item)
		currentOffset += 4 + itemLen
	}
	privatePayloadOffset += 4 // count
	for _, item := range m.ContextKeys {
		privatePayloadOffset += 4 + len(item)
	}

	return buf, nil
}

func (m *AdRequest) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (UserId): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.UserId = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (ContextKeys): repeated variable-length
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.ContextKeys = make([]string, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						m.ContextKeys = append(m.ContextKeys, string(data[currentOffset+4:currentOffset+4+itemLen]))
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type AdRequestRaw []byte

func (m AdRequestRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *AdRequestRaw) UnmarshalSymphony(data []byte) error {
	*m = AdRequestRaw(data)
	return nil
}

func (m AdRequestRaw) GetUserId() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m AdRequestRaw) GetContextKeys() []string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (ContextKeys): repeated variable-length
	if len(m) < offsetToPrivate+5+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]string, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		itemLen := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+itemLen {
			return nil
		}
		result[i] = string(m[currentOffset+4 : currentOffset+4+itemLen])
		currentOffset += 4 + itemLen
	}
	return result
}

func (m *AdRequestRaw) SetUserId(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (UserId): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp AdRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.UserId = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AdRequestRaw(newData)
	return nil
}

func (m *AdRequestRaw) SetContextKeys(v []string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (ContextKeys): repeated variable-length
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes length + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemLen := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemLen
			currentOffset += 4 + itemLen
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes length + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemLen := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemLen))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemLen
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp AdRequest
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.ContextKeys = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AdRequestRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *AdResponse) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *AdResponse) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 4 // table
	size += 4 // count for Ads
	for _, item := range m.Ads {
		nested, _ := item.MarshalSymphony()
		size += 4 + len(nested)
	}
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 4
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (Ads): repeated nested message
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	count = len(m.Ads)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(count))
	payloadOffset += 4
	currentOffset = payloadStart + payloadOffset
	for _, item := range m.Ads {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		payloadOffset += 4 + nestedSize
	}

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *AdResponse) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *AdResponse) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (Ads): repeated nested message
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Ads = make([]*Ad, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &Ad{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Ads = append(m.Ads, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

func (m *AdResponse) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 4 // table entries
	// Field 1 (Ads): repeated nested message payload
	size += 4 // count
	for _, item := range m.Ads {
		nestedSize1 := 0
		// Public segment:
		nestedSize1 += 1  // version byte
		nestedSize1 += 12 // reserved: offset_to_private, service_name, method_name
		// Private segment:
		nestedSize1 += 1 // version byte
		nestedSize1 += 8 // table entries
		// Field 1 (RedirectUrl): variable-length payload
		nestedSize1 += 4 + len(item.RedirectUrl) // 4 bytes length prefix + data
		// Field 2 (Text): variable-length payload
		nestedSize1 += 4 + len(item.Text) // 4 bytes length prefix + data

		size += 4 + nestedSize1 // 4 bytes size + message data
	}

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 4 bytes table
	privatePayloadStart := privateTableStart + 4
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (Ads): repeated nested message
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	count = len(m.Ads)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(count))
	privatePayloadOffset += 4
	currentOffset = privatePayloadStart + privatePayloadOffset
	for _, item := range m.Ads {
		nestedData, err := item.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal nested message: %w", err)
		}
		nestedSize := len(nestedData)
		binary.LittleEndian.PutUint32(buf[currentOffset:], uint32(nestedSize))
		copy(buf[currentOffset+4:], nestedData)
		currentOffset += 4 + nestedSize
		privatePayloadOffset += 4 + nestedSize
	}

	return buf, nil
}

func (m *AdResponse) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (Ads): repeated nested message
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			count = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			m.Ads = make([]*Ad, 0, count)
			currentOffset = payloadOffset + 4
			for i := 0; i < count; i++ {
				if len(data) >= currentOffset+4 {
					itemLen := int(binary.LittleEndian.Uint32(data[currentOffset:]))
					if len(data) >= currentOffset+4+itemLen {
						item := &Ad{}
						if err := item.UnmarshalSymphony(data[currentOffset+4 : currentOffset+4+itemLen]); err != nil {
							return fmt.Errorf("failed to unmarshal nested message: %w", err)
						}
						m.Ads = append(m.Ads, item)
						currentOffset += 4 + itemLen
					}
				}
			}
		}
	}

	return nil
}

type AdResponseRaw []byte

func (m AdResponseRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *AdResponseRaw) UnmarshalSymphony(data []byte) error {
	*m = AdResponseRaw(data)
	return nil
}

func (m AdResponseRaw) GetAds() []AdRaw {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (Ads): repeated nested message
	if len(m) < offsetToPrivate+1+4 {
		return nil
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return nil
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return nil
	}
	count := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	result := make([]AdRaw, count)
	currentOffset := payloadOffset + 4
	for i := 0; i < count; i++ {
		if len(m) < currentOffset+4 {
			return nil
		}
		nestedSize := int(binary.LittleEndian.Uint32(m[currentOffset:]))
		if len(m) < currentOffset+4+nestedSize {
			return nil
		}
		result[i] = AdRaw(m[currentOffset+4 : currentOffset+4+nestedSize])
		currentOffset += 4 + nestedSize
	}
	return result
}

func (m *AdResponseRaw) SetAds(v []AdRaw) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (Ads): repeated nested message
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldCount int
	var oldDataSize int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldCount = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
		// Calculate old data size: 4 bytes count + for each item: 4 bytes size + data
		oldDataSize = 4
		currentOffset := oldPayloadOffset + 4
		for i := 0; i < oldCount; i++ {
			if len(*m) < currentOffset+4 {
				break
			}
			itemSize := int(binary.LittleEndian.Uint32((*m)[currentOffset:]))
			oldDataSize += 4 + itemSize
			currentOffset += 4 + itemSize
		}
	}
	newCount := len(v)
	newDataSize := 4 // count
	for _, item := range v {
		newDataSize += 4 + len(item) // 4 bytes size + data
	}
	if oldPayloadOffset > 0 && newDataSize <= oldDataSize {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newCount))
		currentOffset := oldPayloadOffset + 4
		for _, item := range v {
			itemSize := len(item)
			binary.LittleEndian.PutUint32((*m)[currentOffset:], uint32(itemSize))
			copy((*m)[currentOffset+4:], item)
			currentOffset += 4 + itemSize
		}
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp AdResponse
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Ads = make([]*Ad, len(v))
	for i, rawItem := range v {
		temp.Ads[i] = &Ad{}
		if err := temp.Ads[i].UnmarshalSymphony([]byte(rawItem)); err != nil {
			return fmt.Errorf("failed to unmarshal nested message: %w", err)
		}
	}
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AdResponseRaw(newData)
	return nil
}

// MarshalSymphonyPublic marshals only the public fields (without header)
func (m *Ad) MarshalSymphonyPublic() ([]byte, error) {
	return []byte{}, nil
}

// MarshalSymphonyPrivate marshals only the private fields (without header)
func (m *Ad) MarshalSymphonyPrivate() ([]byte, error) {
	size := 0
	size += 8 // table
	size += 4 + len(m.RedirectUrl)
	size += 4 + len(m.Text)
	buf := make([]byte, size)
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	payloadStart := tableStart + 8
	payloadOffset := 0
	_ = payloadStart
	_ = payloadOffset

	// Field 1 (RedirectUrl): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+0:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.RedirectUrl)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.RedirectUrl)
	payloadOffset += 4 + len(m.RedirectUrl)

	// Field 2 (Text): variable-length
	binary.LittleEndian.PutUint32(buf[tableStart+4:], uint32(payloadStart+payloadOffset))
	dataLen = len(m.Text)
	binary.LittleEndian.PutUint32(buf[payloadStart+payloadOffset:], uint32(dataLen))
	copy(buf[payloadStart+payloadOffset+4:], m.Text)
	payloadOffset += 4 + len(m.Text)

	return buf, nil
}

// UnmarshalSymphonyPublic unmarshals only the public fields (without header)
func (m *Ad) UnmarshalSymphonyPublic(data []byte) error {
	return nil
}

// UnmarshalSymphonyPrivate unmarshals only the private fields (without header)
func (m *Ad) UnmarshalSymphonyPrivate(data []byte) error {
	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset
	tableStart := 0
	_ = tableStart

	// Field 1 (RedirectUrl): variable-length
	if len(data) >= tableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+0:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.RedirectUrl = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Text): variable-length
	if len(data) >= tableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[tableStart+4:]))
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Text = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

func (m *Ad) MarshalSymphony() ([]byte, error) {
	size := 0
	// Public segment:
	size += 1  // version byte
	size += 12 // reserved: offset_to_private, service_name, method_name
	// Private segment:
	size += 1 // version byte
	size += 8 // table entries
	// Field 1 (RedirectUrl): variable-length payload
	size += 4 + len(m.RedirectUrl) // 4 bytes length prefix + data
	// Field 2 (Text): variable-length payload
	size += 4 + len(m.Text) // 4 bytes length prefix + data

	buf := make([]byte, size)

	dataLen := 0 // avoid no new variables warning
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC SEGMENT ===
	buf[0] = 0x01 // version byte

	// Calculate offset to private segment
	publicSegmentSize := 13

	// Write reserved header
	binary.LittleEndian.PutUint32(buf[1:5], uint32(publicSegmentSize)) // offset_to_private
	binary.LittleEndian.PutUint32(buf[5:9], 0)                         // service_id
	binary.LittleEndian.PutUint32(buf[9:13], 0)                        // method_id

	// Write public fields
	publicTableStart := 13
	publicPayloadStart := publicTableStart + 0
	publicPayloadOffset := 0
	_ = publicPayloadStart
	_ = publicPayloadOffset

	// === PRIVATE SEGMENT ===
	privateStart := publicSegmentSize
	buf[privateStart] = 0x01 // version byte

	// Write private fields
	privateTableStart := privateStart + 1 // 8 bytes table
	privatePayloadStart := privateTableStart + 8
	privatePayloadOffset := 0
	_ = privatePayloadStart
	_ = privatePayloadOffset

	// Private segment offsets are stored relative to privateStart
	// Field 1 (RedirectUrl): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+0:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.RedirectUrl)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.RedirectUrl)
	privatePayloadOffset += 4 + len(m.RedirectUrl)

	// Field 2 (Text): variable-length
	binary.LittleEndian.PutUint32(buf[privateTableStart+4:], uint32((privatePayloadStart+privatePayloadOffset)-privateStart))
	dataLen = len(m.Text)
	binary.LittleEndian.PutUint32(buf[privatePayloadStart+privatePayloadOffset:], uint32(dataLen))
	copy(buf[privatePayloadStart+privatePayloadOffset+4:], m.Text)
	privatePayloadOffset += 4 + len(m.Text)

	return buf, nil
}

func (m *Ad) UnmarshalSymphony(data []byte) error {
	if len(data) < 13 {
		return fmt.Errorf("invalid data: too short")
	}

	// Validate public segment version
	if data[0] != 0x01 {
		return fmt.Errorf("invalid data: wrong public version")
	}

	// Read reserved header
	offsetToPrivate := int(binary.LittleEndian.Uint32(data[1:5]))
	// service_name := binary.LittleEndian.Uint32(data[5:9])  // not used yet
	// method_name := binary.LittleEndian.Uint32(data[9:13])  // not used yet

	// Assert private segment exists
	if offsetToPrivate >= len(data) || data[offsetToPrivate] != 0x01 {
		return fmt.Errorf("missing private segment")
	}

	payloadOffset := 0
	_ = payloadOffset
	dataLen := 0
	_ = dataLen
	count := 0
	_ = count
	currentOffset := 0
	_ = currentOffset

	// === PUBLIC FIELDS ===
	publicTableStart := 13
	_ = publicTableStart
	// === PRIVATE FIELDS ===
	privateTableStart := offsetToPrivate + 1
	_ = privateTableStart
	// Private segment offsets are relative to offsetToPrivate
	// Field 1 (RedirectUrl): variable-length
	if len(data) >= privateTableStart+0+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+0:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.RedirectUrl = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	// Field 2 (Text): variable-length
	if len(data) >= privateTableStart+4+4 {
		payloadOffset = int(binary.LittleEndian.Uint32(data[privateTableStart+4:]))
		if payloadOffset > 0 {
			payloadOffset += offsetToPrivate // convert relative offset to absolute
		}
		if payloadOffset > 0 && len(data) >= payloadOffset+4 {
			dataLen = int(binary.LittleEndian.Uint32(data[payloadOffset:]))
			if len(data) >= payloadOffset+4+dataLen {
				m.Text = string(data[payloadOffset+4 : payloadOffset+4+dataLen])
			}
		}
	}

	return nil
}

type AdRaw []byte

func (m AdRaw) MarshalSymphony() ([]byte, error) {
	return []byte(m), nil
}

func (m *AdRaw) UnmarshalSymphony(data []byte) error {
	*m = AdRaw(data)
	return nil
}

func (m AdRaw) GetRedirectUrl() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 1 (RedirectUrl): variable-length
	if len(m) < offsetToPrivate+1+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+1:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m AdRaw) GetText() string {
	// ASSERT: Private field requires complete buffer
	if len(m) < 5 {
		panic("private getter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32(m[1:5]))
	if offsetToPrivate >= len(m) || m[offsetToPrivate] != 0x01 {
		panic("private getter called on public-only buffer")
	}
	// Field 2 (Text): variable-length
	if len(m) < offsetToPrivate+5+4 {
		return ""
	}
	payloadOffset := int(binary.LittleEndian.Uint32(m[offsetToPrivate+5:]))
	if payloadOffset == 0 {
		return ""
	}
	payloadOffset += offsetToPrivate // convert relative offset to absolute
	if len(m) < payloadOffset+4 {
		return ""
	}
	dataLen := int(binary.LittleEndian.Uint32(m[payloadOffset:]))
	if len(m) < payloadOffset+4+dataLen {
		return ""
	}
	return string(m[payloadOffset+4 : payloadOffset+4+dataLen])
}

func (m *AdRaw) SetRedirectUrl(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 1 (RedirectUrl): variable-length
	if len(*m) < offsetToPrivate+1+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+1:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Ad
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.RedirectUrl = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AdRaw(newData)
	return nil
}

func (m *AdRaw) SetText(v string) error {
	// ASSERT: Private field setter requires complete buffer
	if len(*m) < 5 {
		panic("private setter called on invalid buffer")
	}
	offsetToPrivate := int(binary.LittleEndian.Uint32((*m)[1:5]))
	if offsetToPrivate >= len(*m) || (*m)[offsetToPrivate] != 0x01 {
		panic("private setter called on public-only buffer")
	}
	// Field 2 (Text): variable-length
	if len(*m) < offsetToPrivate+5+4 {
		return fmt.Errorf("buffer too short for table entry")
	}
	oldPayloadOffset := int(binary.LittleEndian.Uint32((*m)[offsetToPrivate+5:]))
	if oldPayloadOffset > 0 {
		oldPayloadOffset += offsetToPrivate // convert relative offset to absolute
	}
	var oldDataLen int
	if oldPayloadOffset > 0 && len(*m) >= oldPayloadOffset+4 {
		oldDataLen = int(binary.LittleEndian.Uint32((*m)[oldPayloadOffset:]))
	}
	newDataLen := len(v)
	if oldPayloadOffset > 0 && newDataLen <= oldDataLen {
		// Update in-place (waste space)
		binary.LittleEndian.PutUint32((*m)[oldPayloadOffset:], uint32(newDataLen))
		copy((*m)[oldPayloadOffset+4:], v)
		return nil
	}
	// Need to remarshal: unmarshal, update, marshal
	var temp Ad
	if err := temp.UnmarshalSymphony([]byte(*m)); err != nil {
		return fmt.Errorf("failed to unmarshal: %w", err)
	}
	temp.Text = v
	newData, err := temp.MarshalSymphony()
	if err != nil {
		return fmt.Errorf("failed to marshal: %w", err)
	}
	*m = AdRaw(newData)
	return nil
}
