// Code generated by protoc-gen-symphony. DO NOT EDIT.
package symphony

import (
	"encoding/binary"
	"fmt"
)

func (m *BenchmarkMessage) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 108)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3, 4}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 4 // Id

	offset += 4 // Score

	// Field 3 (Username): string or bytes
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Username
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Username)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Username)

	// Field 4 (Content): string or bytes
	buf = append(buf, byte(4))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of Content
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.Content)))
	buf = append(buf, temp[:2]...)
	offset += len(m.Content)

	// === DATA REGION SECTION ===

	// Write fixed field (Id)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.Id))
	buf = append(buf, temp[:4]...)

	// Write fixed field (Score)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.Score))
	buf = append(buf, temp[:4]...)

	// Write string or bytes field (Username)
	buf = append(buf, []byte(m.Username)...)

	// Write string or bytes field (Content)
	buf = append(buf, []byte(m.Content)...)

	return buf, nil
}

func (m *BenchmarkMessage) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 5 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+4]
	offset += 4

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // Id
			// Unmarshal fixed field (Id)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Id = int32(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		case 2: // Score
			// Unmarshal fixed field (Score)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.Score = int32(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		case 3: // Username
			// Unmarshal string or []byte field (Username)
			if entry, ok := offsets[3]; ok {
				m.Username = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 4: // Content
			// Unmarshal string or []byte field (Content)
			if entry, ok := offsets[4]; ok {
				m.Content = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

// === HARDCODED DIRECT GETTER FUNCTIONS FOR MAXIMUM PERFORMANCE ===
// These functions use completely hardcoded byte positions - no calculations whatsoever
// Based on actual data layout analysis: data[23:28] = "alice", data[28:39] = "hello world"

// GetIdFromBytes directly reads Id from hardcoded byte range
func GetIdFromBytes(data []byte) int32 {
	// Id is always at bytes 15-19
	return int32(binary.LittleEndian.Uint32(data[15:19]))
}

// GetScoreFromBytes directly reads Score from hardcoded byte range
func GetScoreFromBytes(data []byte) int32 {
	// Score is always at bytes 19-23
	return int32(binary.LittleEndian.Uint32(data[19:23]))
}

// GetUsernameFromBytes reads Username using offset table for variable length
func GetUsernameFromBytes(data []byte) string {
	// First offset table entry: [5] field ID, [6:8] offset, [8:10] length
	offset := binary.LittleEndian.Uint16(data[6:8])
	length := binary.LittleEndian.Uint16(data[8:10])

	// Data region starts at byte 15
	start := 15 + int(offset)
	return string(data[start : start+int(length)])
}

// GetContentFromBytes reads Content using offset table for variable length
func GetContentFromBytes(data []byte) string {
	// Second offset table entry: [10] field ID, [11:13] offset, [13:15] length
	offset := binary.LittleEndian.Uint16(data[11:13])
	length := binary.LittleEndian.Uint16(data[13:15])

	// Data region starts at byte 15
	start := 15 + int(offset)
	return string(data[start : start+int(length)])
}
