// Code generated by capnpc-go. DO NOT EDIT.

package benchmark_capnp

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type BenchmarkMessage capnp.Struct

// BenchmarkMessage_TypeID is the unique identifier for the type BenchmarkMessage.
const BenchmarkMessage_TypeID = 0xf01d6f84d73ee8f2

func NewBenchmarkMessage(s *capnp.Segment) (BenchmarkMessage, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return BenchmarkMessage(st), err
}

func NewRootBenchmarkMessage(s *capnp.Segment) (BenchmarkMessage, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return BenchmarkMessage(st), err
}

func ReadRootBenchmarkMessage(msg *capnp.Message) (BenchmarkMessage, error) {
	root, err := msg.Root()
	return BenchmarkMessage(root.Struct()), err
}

func (s BenchmarkMessage) String() string {
	str, _ := text.Marshal(0xf01d6f84d73ee8f2, capnp.Struct(s))
	return str
}

func (s BenchmarkMessage) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (BenchmarkMessage) DecodeFromPtr(p capnp.Ptr) BenchmarkMessage {
	return BenchmarkMessage(capnp.Struct{}.DecodeFromPtr(p))
}

func (s BenchmarkMessage) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s BenchmarkMessage) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s BenchmarkMessage) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s BenchmarkMessage) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s BenchmarkMessage) Id() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s BenchmarkMessage) SetId(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s BenchmarkMessage) Score() int32 {
	return int32(capnp.Struct(s).Uint32(4))
}

func (s BenchmarkMessage) SetScore(v int32) {
	capnp.Struct(s).SetUint32(4, uint32(v))
}

func (s BenchmarkMessage) Username() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s BenchmarkMessage) HasUsername() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s BenchmarkMessage) UsernameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s BenchmarkMessage) SetUsername(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s BenchmarkMessage) Content() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s BenchmarkMessage) HasContent() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s BenchmarkMessage) ContentBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s BenchmarkMessage) SetContent(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// BenchmarkMessage_List is a list of BenchmarkMessage.
type BenchmarkMessage_List = capnp.StructList[BenchmarkMessage]

// NewBenchmarkMessage creates a new list of BenchmarkMessage.
func NewBenchmarkMessage_List(s *capnp.Segment, sz int32) (BenchmarkMessage_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[BenchmarkMessage](l), err
}

// BenchmarkMessage_Future is a wrapper for a BenchmarkMessage promised by a client call.
type BenchmarkMessage_Future struct{ *capnp.Future }

func (f BenchmarkMessage_Future) Struct() (BenchmarkMessage, error) {
	p, err := f.Future.Ptr()
	return BenchmarkMessage(p.Struct()), err
}

const schema_bf5147bb3b06fa3d = "x\xda4\xc8\xbdJ\x03A\x14\x05\xe0s\xeeL\x92&" +
	"B\x06\x16\x0bA|\x02\x95XF\xfc!\x8d \x08\xde" +
	"\xde\xc2q\xbd\xb8\xc1d6\xee\xae`'\x82oe\x91" +
	"\xca\x07\xb0\x10\x1fAK\xb1\xb4YQL\xf9}\x83\x87" +
	"C?\\Y\x10\xa2Y\xa7\xdb~}\xec\xbf=\x96\xeb" +
	"\x9f\xd0U\xb2\xdd\xfb\xee\xee>\x1d\xe9\x02\x1d\xe9\x01\xc3" +
	"\xe7\x11\xc3k\x0f\x08/\xef\xd8l\xf38O\xf3\xed\x0b" +
	"s)/f\xb1\xba\xde\xfa\x8b\xd1\xd8\xfe}r`u" +
	"\x1d\xaf\xec\x94\xd4\x81\xf3\x80'\x10\xe2\x1a\xa0g\x8eZ" +
	"\x08\x03\x99\xf17m\x07\xd0sG\x9d\x0a)\x19\x05\x08" +
	"\x93c@\x0bGm\x84\xc11\xa3\x03\xc2\xcd\x18\xd0\xa9" +
	"\xa3\xde\x09\xdd\xe4\x92\x1eB\x0fn\xd4yY\xd9R\xed" +
	"mmU\x8a3\x03\xc0>\x84}\xf0>/Sc\xa9" +
	"Y\xfa'\x00\x00\xff\xff\xbf+6V"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_bf5147bb3b06fa3d,
		Nodes: []uint64{
			0xf01d6f84d73ee8f2,
		},
		Compressed: true,
	})
}
