// Code generated by protoc-gen-symphony. DO NOT EDIT.
package symphony

import (
	"encoding/binary"
	"fmt"
)

func (m *RuntimeEnvUris) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 96)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (WorkingDirUri): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of WorkingDirUri
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.WorkingDirUri)))
	buf = append(buf, temp[:2]...)
	offset += len(m.WorkingDirUri)

	// Field 2 (PyModulesUris): repeated variable-length
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of PyModulesUris
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.PyModulesUris {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write string or bytes field (WorkingDirUri)
	buf = append(buf, []byte(m.WorkingDirUri)...)

	// Write repeated variable-length field (PyModulesUris)
	for _, item := range m.PyModulesUris {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *RuntimeEnvUris) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 3 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+2]
	offset += 2

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 10
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 2; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // WorkingDirUri
			// Unmarshal string or []byte field (WorkingDirUri)
			if entry, ok := offsets[1]; ok {
				m.WorkingDirUri = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // PyModulesUris
			// Unmarshal repeated variable-length field (PyModulesUris)
			if entry, ok := offsets[2]; ok {
				m.PyModulesUris = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.PyModulesUris = append(m.PyModulesUris, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.PyModulesUris = append(m.PyModulesUris, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *RuntimeEnvConfig) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 57)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3}...)

	// === OFFSET TABLE SECTION ===
	offset := 0

	offset += 4 // SetupTimeoutSeconds

	offset += 1 // EagerInstall

	// Field 3 (LogFiles): repeated variable-length
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of LogFiles
	buf = append(buf, temp[:2]...)
	totalLen := 0
	for _, item := range m.LogFiles {
		totalLen += 4 + len(item) // 4 bytes for length + (string or bytes) data
	}
	binary.LittleEndian.PutUint16(temp[:2], uint16(totalLen))
	buf = append(buf, temp[:2]...)
	offset += totalLen

	// === DATA REGION SECTION ===

	// Write fixed field (SetupTimeoutSeconds)
	binary.LittleEndian.PutUint32(temp[:4], uint32(m.SetupTimeoutSeconds))
	buf = append(buf, temp[:4]...)

	// Write fixed field (EagerInstall)
	if m.EagerInstall {
		buf = append(buf, 1)
	} else {
		buf = append(buf, 0)
	}

	// Write repeated variable-length field (LogFiles)
	for _, item := range m.LogFiles {
		binary.LittleEndian.PutUint32(temp[:4], uint32(len(item)))
		buf = append(buf, temp[:4]...)
		buf = append(buf, []byte(item)...)
	}

	return buf, nil
}

func (m *RuntimeEnvConfig) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 4 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+3]
	offset += 3

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 5
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 1; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // SetupTimeoutSeconds
			// Unmarshal fixed field (SetupTimeoutSeconds)
			if dataOffset+4 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.SetupTimeoutSeconds = int32(binary.LittleEndian.Uint32(dataRegion[dataOffset : dataOffset+4]))
			dataOffset += 4
		case 2: // EagerInstall
			// Unmarshal fixed field (EagerInstall)
			if dataOffset+1 > len(dataRegion) {
				return fmt.Errorf("insufficient data for fixed field")
			}
			m.EagerInstall = dataRegion[dataOffset] != 0
			dataOffset += 1
		case 3: // LogFiles
			// Unmarshal repeated variable-length field (LogFiles)
			if entry, ok := offsets[3]; ok {
				m.LogFiles = make([]string, 0)
				fieldData := dataRegion[entry.offset : entry.offset+entry.length]
				fieldOffset := 0
				for fieldOffset < len(fieldData) {
					if fieldOffset+4 > len(fieldData) {
						return fmt.Errorf("insufficient data for item length")
					}
					itemLen := binary.LittleEndian.Uint32(fieldData[fieldOffset : fieldOffset+4])
					fieldOffset += 4
					if itemLen == 0 {
						m.LogFiles = append(m.LogFiles, "")
						continue
					}
					if fieldOffset+int(itemLen) > len(fieldData) {
						return fmt.Errorf("insufficient data for item data")
					}
					itemData := fieldData[fieldOffset : fieldOffset+int(itemLen)]
					fieldOffset += int(itemLen)
					m.LogFiles = append(m.LogFiles, string(itemData))
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}

func (m *RuntimeEnvInfo) MarshalSymphony() ([]byte, error) {
	// Pre-allocate buffer with estimated size
	buf := make([]byte, 0, 223)
	var temp [8]byte // Reusable temp buffer for encoding

	// === HEADER SECTION ===
	buf = append(buf, 0x00) // layout header
	buf = append(buf, []byte{1, 2, 3}...)

	// === PRE-MARSHAL/CACHE SECTION FOR NESTED MESSAGES ===

	var err error
	cachedSingularMessages := make(map[byte][]byte)
	// Cache field 2 (Uris): singular message
	if m.Uris != nil {
		cachedSingularMessages[2], err = m.Uris.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field Uris: %w", err)
		}
	}

	// Cache field 3 (RuntimeEnvConfig): singular message
	if m.RuntimeEnvConfig != nil {
		cachedSingularMessages[3], err = m.RuntimeEnvConfig.MarshalSymphony()
		if err != nil {
			return nil, fmt.Errorf("failed to marshal singular message field RuntimeEnvConfig: %w", err)
		}
	}

	// === OFFSET TABLE SECTION ===
	offset := 0

	// Field 1 (SerializedRuntimeEnv): string or bytes
	buf = append(buf, byte(1))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset)) // offset of SerializedRuntimeEnv
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(m.SerializedRuntimeEnv)))
	buf = append(buf, temp[:2]...)
	offset += len(m.SerializedRuntimeEnv)

	// Field 2 (Uris): nested message
	buf = append(buf, byte(2))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[2])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[2])

	// Field 3 (RuntimeEnvConfig): nested message
	buf = append(buf, byte(3))
	binary.LittleEndian.PutUint16(temp[:2], uint16(offset))
	buf = append(buf, temp[:2]...)
	binary.LittleEndian.PutUint16(temp[:2], uint16(len(cachedSingularMessages[3])))
	buf = append(buf, temp[:2]...)
	offset += len(cachedSingularMessages[3])

	// === DATA REGION SECTION ===

	// Write string or bytes field (SerializedRuntimeEnv)
	buf = append(buf, []byte(m.SerializedRuntimeEnv)...)

	// Write nested message field (Uris)
	buf = append(buf, cachedSingularMessages[2]...)

	// Write nested message field (RuntimeEnvConfig)
	buf = append(buf, cachedSingularMessages[3]...)

	return buf, nil
}

func (m *RuntimeEnvInfo) UnmarshalSymphony(data []byte) error {
	// === HEADER PARSING SECTION ===
	if len(data) < 4 {
		return fmt.Errorf("data too short for header")
	}
	offset := 0
	_ = data[offset] // header byte (currently unused)
	offset++

	fieldOrder := data[offset : offset+3]
	offset += 3

	// === OFFSET TABLE PARSING SECTION ===
	type offsetEntry struct{ offset, length uint16 }
	offsets := map[byte]offsetEntry{}
	offsetTableSize := 15
	if len(data) < offset+offsetTableSize {
		return fmt.Errorf("data too short for offset table")
	}
	for i := 0; i < 3; i++ {
		entryOffset := offset + i*5
		fieldID := data[entryOffset]
		off := binary.LittleEndian.Uint16(data[entryOffset+1 : entryOffset+3])
		len := binary.LittleEndian.Uint16(data[entryOffset+3 : entryOffset+5])
		offsets[fieldID] = offsetEntry{off, len}
	}
	offset += offsetTableSize

	// === DATA REGION EXTRACTION SECTION ===
	dataRegion := data[offset:]
	dataOffset := 0

	// === FIELD UNMARSHALING SECTION ===
	for _, fieldNum := range fieldOrder {
		switch fieldNum {
		case 1: // SerializedRuntimeEnv
			// Unmarshal string or []byte field (SerializedRuntimeEnv)
			if entry, ok := offsets[1]; ok {
				m.SerializedRuntimeEnv = string(dataRegion[entry.offset : entry.offset+entry.length])
				dataOffset += int(entry.length)
			}
		case 2: // Uris
			// Unmarshal nested message field (Uris)
			if entry, ok := offsets[2]; ok {
				if entry.length == 0 {
					m.Uris = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.Uris == nil {
						m.Uris = &RuntimeEnvUris{}
					}
					if err := m.Uris.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		case 3: // RuntimeEnvConfig
			// Unmarshal nested message field (RuntimeEnvConfig)
			if entry, ok := offsets[3]; ok {
				if entry.length == 0 {
					m.RuntimeEnvConfig = nil
				} else {
					fieldData := dataRegion[entry.offset : entry.offset+entry.length]
					if m.RuntimeEnvConfig == nil {
						m.RuntimeEnvConfig = &RuntimeEnvConfig{}
					}
					if err := m.RuntimeEnvConfig.UnmarshalSymphony(fieldData); err != nil {
						return fmt.Errorf("failed to unmarshal singular nested message: %w", err)
					}
				}
				dataOffset += int(entry.length)
			}
		}
	}

	return nil
}
